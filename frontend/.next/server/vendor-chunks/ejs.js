"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ejs";
exports.ids = ["vendor-chunks/ejs"];
exports.modules = {

/***/ "(rsc)/../backend/node_modules/ejs/lib/ejs.js":
/*!**********************************************!*\
  !*** ../backend/node_modules/ejs/lib/ejs.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n\n\n/**\n * @file Embedded JavaScript templating engine. {@link http://ejs.co}\n * @author Matthew Eernisse <mde@fleegix.org>\n * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n * @project EJS\n * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n */\n\n/**\n * EJS internal functions.\n *\n * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n * the sake of organization all the private functions re grouped into this\n * module.\n *\n * @module ejs-internal\n * @private\n */\n\n/**\n * Embedded JavaScript templating engine.\n *\n * @module ejs\n * @public\n */\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/../backend/node_modules/ejs/lib/utils.js\");\n\nvar scopeOptionWarned = false;\n/** @type {string} */\nvar _VERSION_STRING = (__webpack_require__(/*! ../package.json */ \"(rsc)/../backend/node_modules/ejs/package.json\").version);\nvar _DEFAULT_OPEN_DELIMITER = '<';\nvar _DEFAULT_CLOSE_DELIMITER = '>';\nvar _DEFAULT_DELIMITER = '%';\nvar _DEFAULT_LOCALS_NAME = 'locals';\nvar _NAME = 'ejs';\nvar _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\nvar _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',\n  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];\n// We don't allow 'cache' option to be passed in the data obj for\n// the normal `render` call, but this is where Express 2 & 3 put it\n// so we make an exception for `renderFile`\nvar _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');\nvar _BOM = /^\\uFEFF/;\nvar _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\n\n/**\n * EJS template function cache. This can be a LRU object from lru-cache NPM\n * module. By default, it is {@link module:utils.cache}, a simple in-process\n * cache that grows continuously.\n *\n * @type {Cache}\n */\n\nexports.cache = utils.cache;\n\n/**\n * Custom file loader. Useful for template preprocessing or restricting access\n * to a certain part of the filesystem.\n *\n * @type {fileLoader}\n */\n\nexports.fileLoader = fs.readFileSync;\n\n/**\n * Name of the object containing the locals.\n *\n * This variable is overridden by {@link Options}`.localsName` if it is not\n * `undefined`.\n *\n * @type {String}\n * @public\n */\n\nexports.localsName = _DEFAULT_LOCALS_NAME;\n\n/**\n * Promise implementation -- defaults to the native implementation if available\n * This is mostly just for testability\n *\n * @type {PromiseConstructorLike}\n * @public\n */\n\nexports.promiseImpl = (new Function('return this;'))().Promise;\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * @param {String}  name     specified path\n * @param {String}  filename parent file path\n * @param {Boolean} [isDir=false] whether the parent file path is a directory\n * @return {String}\n */\nexports.resolveInclude = function(name, filename, isDir) {\n  var dirname = path.dirname;\n  var extname = path.extname;\n  var resolve = path.resolve;\n  var includePath = resolve(isDir ? filename : dirname(filename), name);\n  var ext = extname(name);\n  if (!ext) {\n    includePath += '.ejs';\n  }\n  return includePath;\n};\n\n/**\n * Try to resolve file path on multiple directories\n *\n * @param  {String}        name  specified path\n * @param  {Array<String>} paths list of possible parent directory paths\n * @return {String}\n */\nfunction resolvePaths(name, paths) {\n  var filePath;\n  if (paths.some(function (v) {\n    filePath = exports.resolveInclude(name, v, true);\n    return fs.existsSync(filePath);\n  })) {\n    return filePath;\n  }\n}\n\n/**\n * Get the path to the included file by Options\n *\n * @param  {String}  path    specified path\n * @param  {Options} options compilation options\n * @return {String}\n */\nfunction getIncludePath(path, options) {\n  var includePath;\n  var filePath;\n  var views = options.views;\n  var match = /^[A-Za-z]+:\\\\|^\\//.exec(path);\n\n  // Abs path\n  if (match && match.length) {\n    path = path.replace(/^\\/*/, '');\n    if (Array.isArray(options.root)) {\n      includePath = resolvePaths(path, options.root);\n    } else {\n      includePath = exports.resolveInclude(path, options.root || '/', true);\n    }\n  }\n  // Relative paths\n  else {\n    // Look relative to a passed filename first\n    if (options.filename) {\n      filePath = exports.resolveInclude(path, options.filename);\n      if (fs.existsSync(filePath)) {\n        includePath = filePath;\n      }\n    }\n    // Then look in any views directories\n    if (!includePath && Array.isArray(views)) {\n      includePath = resolvePaths(path, views);\n    }\n    if (!includePath && typeof options.includer !== 'function') {\n      throw new Error('Could not find the include file \"' +\n          options.escapeFunction(path) + '\"');\n    }\n  }\n  return includePath;\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `template` is not set, the file specified in `options.filename` will be\n * read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @memberof module:ejs-internal\n * @param {Options} options   compilation options\n * @param {String} [template] template source\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned.\n * @static\n */\n\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fileLoader(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fileLoader(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @memberof module:ejs-internal\n * @param {Options} options    compilation options\n * @param {Object} data        template data\n * @param {RenderFileCallback} cb callback\n * @static\n */\n\nfunction tryHandleCache(options, data, cb) {\n  var result;\n  if (!cb) {\n    if (typeof exports.promiseImpl == 'function') {\n      return new exports.promiseImpl(function (resolve, reject) {\n        try {\n          result = handleCache(options)(data);\n          resolve(result);\n        }\n        catch (err) {\n          reject(err);\n        }\n      });\n    }\n    else {\n      throw new Error('Please provide a callback function');\n    }\n  }\n  else {\n    try {\n      result = handleCache(options)(data);\n    }\n    catch (err) {\n      return cb(err);\n    }\n\n    cb(null, result);\n  }\n}\n\n/**\n * fileLoader is independent\n *\n * @param {String} filePath ejs file path.\n * @return {String} The contents of the specified file.\n * @static\n */\n\nfunction fileLoader(filePath){\n  return exports.fileLoader(filePath);\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned\n * @static\n */\n\nfunction includeFile(path, options) {\n  var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);\n  opts.filename = getIncludePath(path, opts);\n  if (typeof options.includer === 'function') {\n    var includerResult = options.includer(path, opts.filename);\n    if (includerResult) {\n      if (includerResult.filename) {\n        opts.filename = includerResult.filename;\n      }\n      if (includerResult.template) {\n        return handleCache(opts, includerResult.template);\n      }\n    }\n  }\n  return handleCache(opts);\n}\n\n/**\n * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n * `lineno`.\n *\n * @implements {RethrowCallback}\n * @memberof module:ejs-internal\n * @param {Error}  err      Error object\n * @param {String} str      EJS source\n * @param {String} flnm     file name of the EJS file\n * @param {Number} lineno   line number of the error\n * @param {EscapeCallback} esc\n * @static\n */\n\nfunction rethrow(err, str, flnm, lineno, esc) {\n  var lines = str.split('\\n');\n  var start = Math.max(lineno - 3, 0);\n  var end = Math.min(lines.length, lineno + 3);\n  var filename = esc(flnm);\n  // Error context\n  var context = lines.slice(start, end).map(function (line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':'\n    + lineno + '\\n'\n    + context + '\\n\\n'\n    + err.message;\n\n  throw err;\n}\n\nfunction stripSemi(str){\n  return str.replace(/;(\\s*$)/, '$1');\n}\n\n/**\n * Compile the given `str` of ejs into a template function.\n *\n * @param {String}  template EJS template\n *\n * @param {Options} [opts] compilation options\n *\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `opts.client`, either type might be returned.\n * Note that the return type of the function also depends on the value of `opts.async`.\n * @public\n */\n\nexports.compile = function compile(template, opts) {\n  var templ;\n\n  // v1 compat\n  // 'scope' is 'context'\n  // FIXME: Remove this in a future version\n  if (opts && opts.scope) {\n    if (!scopeOptionWarned){\n      console.warn('`scope` option is deprecated and will be removed in EJS 3');\n      scopeOptionWarned = true;\n    }\n    if (!opts.context) {\n      opts.context = opts.scope;\n    }\n    delete opts.scope;\n  }\n  templ = new Template(template, opts);\n  return templ.compile();\n};\n\n/**\n * Render the given `template` of ejs.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}   template EJS template\n * @param {Object}  [data={}] template data\n * @param {Options} [opts={}] compilation and rendering options\n * @return {(String|Promise<String>)}\n * Return value type depends on `opts.async`.\n * @public\n */\n\nexports.render = function (template, d, o) {\n  var data = d || utils.createNullProtoObjWherePossible();\n  var opts = o || utils.createNullProtoObjWherePossible();\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 2) {\n    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);\n  }\n\n  return handleCache(opts, template)(data);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `cb(err, str)`.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}             path     path to the EJS file\n * @param {Object}            [data={}] template data\n * @param {Options}           [opts={}] compilation and rendering options\n * @param {RenderFileCallback} cb callback\n * @public\n */\n\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var filename = args.shift();\n  var cb;\n  var opts = {filename: filename};\n  var data;\n  var viewOpts;\n\n  // Do we have a callback?\n  if (typeof arguments[arguments.length - 1] == 'function') {\n    cb = args.pop();\n  }\n  // Do we have data/opts?\n  if (args.length) {\n    // Should always have data obj\n    data = args.shift();\n    // Normal passed opts (data obj + opts obj)\n    if (args.length) {\n      // Use shallowCopy so we don't pollute passed in opts obj with new vals\n      utils.shallowCopy(opts, args.pop());\n    }\n    // Special casing for Express (settings + opts-in-data)\n    else {\n      // Express 3 and 4\n      if (data.settings) {\n        // Pull a few things from known locations\n        if (data.settings.views) {\n          opts.views = data.settings.views;\n        }\n        if (data.settings['view cache']) {\n          opts.cache = true;\n        }\n        // Undocumented after Express 2, but still usable, esp. for\n        // items that are unsafe to be passed along with data, like `root`\n        viewOpts = data.settings['view options'];\n        if (viewOpts) {\n          utils.shallowCopy(opts, viewOpts);\n        }\n      }\n      // Express 2 and lower, values set in app.locals, or people who just\n      // want to pass options in their data. NOTE: These values will override\n      // anything previously set in settings  or settings['view options']\n      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n    }\n    opts.filename = filename;\n  }\n  else {\n    data = utils.createNullProtoObjWherePossible();\n  }\n\n  return tryHandleCache(opts, data, cb);\n};\n\n/**\n * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n * @public\n */\n\n/**\n * EJS template class\n * @public\n */\nexports.Template = Template;\n\nexports.clearCache = function () {\n  exports.cache.reset();\n};\n\nfunction Template(text, optsParam) {\n  var opts = utils.hasOwnOnlyObject(optsParam);\n  var options = utils.createNullProtoObjWherePossible();\n  this.templateText = text;\n  /** @type {string | null} */\n  this.mode = null;\n  this.truncate = false;\n  this.currentLine = 1;\n  this.source = '';\n  options.client = opts.client || false;\n  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;\n  options.compileDebug = opts.compileDebug !== false;\n  options.debug = !!opts.debug;\n  options.filename = opts.filename;\n  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;\n  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;\n  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n  options.strict = opts.strict || false;\n  options.context = opts.context;\n  options.cache = opts.cache || false;\n  options.rmWhitespace = opts.rmWhitespace;\n  options.root = opts.root;\n  options.includer = opts.includer;\n  options.outputFunctionName = opts.outputFunctionName;\n  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n  options.views = opts.views;\n  options.async = opts.async;\n  options.destructuredLocals = opts.destructuredLocals;\n  options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;\n\n  if (options.strict) {\n    options._with = false;\n  }\n  else {\n    options._with = typeof opts._with != 'undefined' ? opts._with : true;\n  }\n\n  this.opts = options;\n\n  this.regex = this.createRegex();\n}\n\nTemplate.modes = {\n  EVAL: 'eval',\n  ESCAPED: 'escaped',\n  RAW: 'raw',\n  COMMENT: 'comment',\n  LITERAL: 'literal'\n};\n\nTemplate.prototype = {\n  createRegex: function () {\n    var str = _REGEX_STRING;\n    var delim = utils.escapeRegExpChars(this.opts.delimiter);\n    var open = utils.escapeRegExpChars(this.opts.openDelimiter);\n    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);\n    str = str.replace(/%/g, delim)\n      .replace(/</g, open)\n      .replace(/>/g, close);\n    return new RegExp(str);\n  },\n\n  compile: function () {\n    /** @type {string} */\n    var src;\n    /** @type {ClientFunction} */\n    var fn;\n    var opts = this.opts;\n    var prepended = '';\n    var appended = '';\n    /** @type {EscapeCallback} */\n    var escapeFn = opts.escapeFunction;\n    /** @type {FunctionConstructor} */\n    var ctor;\n    /** @type {string} */\n    var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';\n\n    if (!this.source) {\n      this.generateSource();\n      prepended +=\n        '  var __output = \"\";\\n' +\n        '  function __append(s) { if (s !== undefined && s !== null) __output += s }\\n';\n      if (opts.outputFunctionName) {\n        if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {\n          throw new Error('outputFunctionName is not a valid JS identifier.');\n        }\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n      }\n      if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {\n        throw new Error('localsName is not a valid JS identifier.');\n      }\n      if (opts.destructuredLocals && opts.destructuredLocals.length) {\n        var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\\n';\n        for (var i = 0; i < opts.destructuredLocals.length; i++) {\n          var name = opts.destructuredLocals[i];\n          if (!_JS_IDENTIFIER.test(name)) {\n            throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.');\n          }\n          if (i > 0) {\n            destructuring += ',\\n  ';\n          }\n          destructuring += name + ' = __locals.' + name;\n        }\n        prepended += destructuring + ';\\n';\n      }\n      if (opts._with !== false) {\n        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\\n';\n        appended += '  }' + '\\n';\n      }\n      appended += '  return __output;' + '\\n';\n      this.source = prepended + this.source + appended;\n    }\n\n    if (opts.compileDebug) {\n      src = 'var __line = 1' + '\\n'\n        + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n        + '  , __filename = ' + sanitizedFilename + ';' + '\\n'\n        + 'try {' + '\\n'\n        + this.source\n        + '} catch (e) {' + '\\n'\n        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n'\n        + '}' + '\\n';\n    }\n    else {\n      src = this.source;\n    }\n\n    if (opts.client) {\n      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n      if (opts.compileDebug) {\n        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n      }\n    }\n\n    if (opts.strict) {\n      src = '\"use strict\";\\n' + src;\n    }\n    if (opts.debug) {\n      console.log(src);\n    }\n    if (opts.compileDebug && opts.filename) {\n      src = src + '\\n'\n        + '//# sourceURL=' + sanitizedFilename + '\\n';\n    }\n\n    try {\n      if (opts.async) {\n        // Have to use generated function for this, since in envs without support,\n        // it breaks in parsing\n        try {\n          ctor = (new Function('return (async function(){}).constructor;'))();\n        }\n        catch(e) {\n          if (e instanceof SyntaxError) {\n            throw new Error('This environment does not support async/await');\n          }\n          else {\n            throw e;\n          }\n        }\n      }\n      else {\n        ctor = Function;\n      }\n      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);\n    }\n    catch(e) {\n      // istanbul ignore else\n      if (e instanceof SyntaxError) {\n        if (opts.filename) {\n          e.message += ' in ' + opts.filename;\n        }\n        e.message += ' while compiling ejs\\n\\n';\n        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n        e.message += 'https://github.com/RyanZim/EJS-Lint';\n        if (!opts.async) {\n          e.message += '\\n';\n          e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';\n        }\n      }\n      throw e;\n    }\n\n    // Return a callable function which will execute the function\n    // created by the source-code, with the passed data as locals\n    // Adds a local `include` function which allows full recursive include\n    var returnedFn = opts.client ? fn : function anonymous(data) {\n      var include = function (path, includeData) {\n        var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);\n        if (includeData) {\n          d = utils.shallowCopy(d, includeData);\n        }\n        return includeFile(path, opts)(d);\n      };\n      return fn.apply(opts.context,\n        [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);\n    };\n    if (opts.filename && typeof Object.defineProperty === 'function') {\n      var filename = opts.filename;\n      var basename = path.basename(filename, path.extname(filename));\n      try {\n        Object.defineProperty(returnedFn, 'name', {\n          value: basename,\n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n      } catch (e) {/* ignore */}\n    }\n    return returnedFn;\n  },\n\n  generateSource: function () {\n    var opts = this.opts;\n\n    if (opts.rmWhitespace) {\n      // Have to use two separate replace here as `^` and `$` operators don't\n      // work well with `\\r` and empty lines don't work well with the `m` flag.\n      this.templateText =\n        this.templateText.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '');\n    }\n\n    // Slurp spaces and tabs before <%_ and after _%>\n    this.templateText =\n      this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n    var self = this;\n    var matches = this.parseTemplateText();\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n\n    if (matches && matches.length) {\n      matches.forEach(function (line, index) {\n        var closing;\n        // If this is an opening tag, check for closing tags\n        // FIXME: May end up with some false positives here\n        // Better to store modes as k/v with openDelimiter + delimiter as key\n        // Then this can simply check against the map\n        if ( line.indexOf(o + d) === 0        // If it is a tag\n          && line.indexOf(o + d + d) !== 0) { // and is not escaped\n          closing = matches[index + 2];\n          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {\n            throw new Error('Could not find matching close tag for \"' + line + '\".');\n          }\n        }\n        self.scanLine(line);\n      });\n    }\n\n  },\n\n  parseTemplateText: function () {\n    var str = this.templateText;\n    var pat = this.regex;\n    var result = pat.exec(str);\n    var arr = [];\n    var firstPos;\n\n    while (result) {\n      firstPos = result.index;\n\n      if (firstPos !== 0) {\n        arr.push(str.substring(0, firstPos));\n        str = str.slice(firstPos);\n      }\n\n      arr.push(result[0]);\n      str = str.slice(result[0].length);\n      result = pat.exec(str);\n    }\n\n    if (str) {\n      arr.push(str);\n    }\n\n    return arr;\n  },\n\n  _addOutput: function (line) {\n    if (this.truncate) {\n      // Only replace single leading linebreak in the line after\n      // -%> tag -- this is the single, trailing linebreak\n      // after the tag that the truncation mode replaces\n      // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n      // combo first in the regex-or\n      line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n      this.truncate = false;\n    }\n    if (!line) {\n      return line;\n    }\n\n    // Preserve literal slashes\n    line = line.replace(/\\\\/g, '\\\\\\\\');\n\n    // Convert linebreaks\n    line = line.replace(/\\n/g, '\\\\n');\n    line = line.replace(/\\r/g, '\\\\r');\n\n    // Escape double-quotes\n    // - this will be the delimiter during execution\n    line = line.replace(/\"/g, '\\\\\"');\n    this.source += '    ; __append(\"' + line + '\")' + '\\n';\n  },\n\n  scanLine: function (line) {\n    var self = this;\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n    var newLineCount = 0;\n\n    newLineCount = (line.split('\\n').length - 1);\n\n    switch (line) {\n    case o + d:\n    case o + d + '_':\n      this.mode = Template.modes.EVAL;\n      break;\n    case o + d + '=':\n      this.mode = Template.modes.ESCAPED;\n      break;\n    case o + d + '-':\n      this.mode = Template.modes.RAW;\n      break;\n    case o + d + '#':\n      this.mode = Template.modes.COMMENT;\n      break;\n    case o + d + d:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(o + d + d, o + d) + '\")' + '\\n';\n      break;\n    case d + d + c:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(d + d + c, d + c) + '\")' + '\\n';\n      break;\n    case d + c:\n    case '-' + d + c:\n    case '_' + d + c:\n      if (this.mode == Template.modes.LITERAL) {\n        this._addOutput(line);\n      }\n\n      this.mode = null;\n      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n      break;\n    default:\n      // In script mode, depends on type of tag\n      if (this.mode) {\n        // If '//' is found without a line break, add a line break.\n        switch (this.mode) {\n        case Template.modes.EVAL:\n        case Template.modes.ESCAPED:\n        case Template.modes.RAW:\n          if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n            line += '\\n';\n          }\n        }\n        switch (this.mode) {\n        // Just executing code\n        case Template.modes.EVAL:\n          this.source += '    ; ' + line + '\\n';\n          break;\n          // Exec, esc, and output\n        case Template.modes.ESCAPED:\n          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\\n';\n          break;\n          // Exec and output\n        case Template.modes.RAW:\n          this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n          break;\n        case Template.modes.COMMENT:\n          // Do nothing\n          break;\n          // Literal <%% mode, append as raw output\n        case Template.modes.LITERAL:\n          this._addOutput(line);\n          break;\n        }\n      }\n      // In string mode, just add the output\n      else {\n        this._addOutput(line);\n      }\n    }\n\n    if (self.opts.compileDebug && newLineCount) {\n      this.currentLine += newLineCount;\n      this.source += '    ; __line = ' + this.currentLine + '\\n';\n    }\n  }\n};\n\n/**\n * Escape characters reserved in XML.\n *\n * This is simply an export of {@link module:utils.escapeXML}.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @public\n * @func\n * */\nexports.escapeXML = utils.escapeXML;\n\n/**\n * Express.js support.\n *\n * This is an alias for {@link module:ejs.renderFile}, in order to support\n * Express.js out-of-the-box.\n *\n * @func\n */\n\nexports.__express = exports.renderFile;\n\n/**\n * Version of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.VERSION = _VERSION_STRING;\n\n/**\n * Name for detection of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.name = _NAME;\n\n/* istanbul ignore if */\nif (typeof window != 'undefined') {\n  window.ejs = exports;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvZWpzL2xpYi9lanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLCtEQUFTOztBQUU3QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixzQkFBc0Isc0dBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxtQkFBbUIsOEJBQThCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9lanMvbGliL2Vqcy5qcz82ODdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBFSlMgRW1iZWRkZWQgSmF2YVNjcmlwdCB0ZW1wbGF0ZXNcbiAqIENvcHlyaWdodCAyMTEyIE1hdHRoZXcgRWVybmlzc2UgKG1kZUBmbGVlZ2l4Lm9yZylcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAZmlsZSBFbWJlZGRlZCBKYXZhU2NyaXB0IHRlbXBsYXRpbmcgZW5naW5lLiB7QGxpbmsgaHR0cDovL2Vqcy5jb31cbiAqIEBhdXRob3IgTWF0dGhldyBFZXJuaXNzZSA8bWRlQGZsZWVnaXgub3JnPlxuICogQGF1dGhvciBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3UgPHRpbW90aHlndTk5QGdtYWlsLmNvbT5cbiAqIEBwcm9qZWN0IEVKU1xuICogQGxpY2Vuc2Uge0BsaW5rIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjB9XG4gKi9cblxuLyoqXG4gKiBFSlMgaW50ZXJuYWwgZnVuY3Rpb25zLlxuICpcbiAqIFRlY2huaWNhbGx5IHRoaXMgXCJtb2R1bGVcIiBsaWVzIGluIHRoZSBzYW1lIGZpbGUgYXMge0BsaW5rIG1vZHVsZTplanN9LCBmb3JcbiAqIHRoZSBzYWtlIG9mIG9yZ2FuaXphdGlvbiBhbGwgdGhlIHByaXZhdGUgZnVuY3Rpb25zIHJlIGdyb3VwZWQgaW50byB0aGlzXG4gKiBtb2R1bGUuXG4gKlxuICogQG1vZHVsZSBlanMtaW50ZXJuYWxcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBFbWJlZGRlZCBKYXZhU2NyaXB0IHRlbXBsYXRpbmcgZW5naW5lLlxuICpcbiAqIEBtb2R1bGUgZWpzXG4gKiBAcHVibGljXG4gKi9cblxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBzY29wZU9wdGlvbldhcm5lZCA9IGZhbHNlO1xuLyoqIEB0eXBlIHtzdHJpbmd9ICovXG52YXIgX1ZFUlNJT05fU1RSSU5HID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbnZhciBfREVGQVVMVF9PUEVOX0RFTElNSVRFUiA9ICc8JztcbnZhciBfREVGQVVMVF9DTE9TRV9ERUxJTUlURVIgPSAnPic7XG52YXIgX0RFRkFVTFRfREVMSU1JVEVSID0gJyUnO1xudmFyIF9ERUZBVUxUX0xPQ0FMU19OQU1FID0gJ2xvY2Fscyc7XG52YXIgX05BTUUgPSAnZWpzJztcbnZhciBfUkVHRVhfU1RSSU5HID0gJyg8JSV8JSU+fDwlPXw8JS18PCVffDwlI3w8JXwlPnwtJT58XyU+KSc7XG52YXIgX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBID0gWydkZWxpbWl0ZXInLCAnc2NvcGUnLCAnY29udGV4dCcsICdkZWJ1ZycsICdjb21waWxlRGVidWcnLFxuICAnY2xpZW50JywgJ193aXRoJywgJ3JtV2hpdGVzcGFjZScsICdzdHJpY3QnLCAnZmlsZW5hbWUnLCAnYXN5bmMnXTtcbi8vIFdlIGRvbid0IGFsbG93ICdjYWNoZScgb3B0aW9uIHRvIGJlIHBhc3NlZCBpbiB0aGUgZGF0YSBvYmogZm9yXG4vLyB0aGUgbm9ybWFsIGByZW5kZXJgIGNhbGwsIGJ1dCB0aGlzIGlzIHdoZXJlIEV4cHJlc3MgMiAmIDMgcHV0IGl0XG4vLyBzbyB3ZSBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgYHJlbmRlckZpbGVgXG52YXIgX09QVFNfUEFTU0FCTEVfV0lUSF9EQVRBX0VYUFJFU1MgPSBfT1BUU19QQVNTQUJMRV9XSVRIX0RBVEEuY29uY2F0KCdjYWNoZScpO1xudmFyIF9CT00gPSAvXlxcdUZFRkYvO1xudmFyIF9KU19JREVOVElGSUVSID0gL15bYS16QS1aXyRdWzAtOWEtekEtWl8kXSokLztcblxuLyoqXG4gKiBFSlMgdGVtcGxhdGUgZnVuY3Rpb24gY2FjaGUuIFRoaXMgY2FuIGJlIGEgTFJVIG9iamVjdCBmcm9tIGxydS1jYWNoZSBOUE1cbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgaXQgaXMge0BsaW5rIG1vZHVsZTp1dGlscy5jYWNoZX0sIGEgc2ltcGxlIGluLXByb2Nlc3NcbiAqIGNhY2hlIHRoYXQgZ3Jvd3MgY29udGludW91c2x5LlxuICpcbiAqIEB0eXBlIHtDYWNoZX1cbiAqL1xuXG5leHBvcnRzLmNhY2hlID0gdXRpbHMuY2FjaGU7XG5cbi8qKlxuICogQ3VzdG9tIGZpbGUgbG9hZGVyLiBVc2VmdWwgZm9yIHRlbXBsYXRlIHByZXByb2Nlc3Npbmcgb3IgcmVzdHJpY3RpbmcgYWNjZXNzXG4gKiB0byBhIGNlcnRhaW4gcGFydCBvZiB0aGUgZmlsZXN5c3RlbS5cbiAqXG4gKiBAdHlwZSB7ZmlsZUxvYWRlcn1cbiAqL1xuXG5leHBvcnRzLmZpbGVMb2FkZXIgPSBmcy5yZWFkRmlsZVN5bmM7XG5cbi8qKlxuICogTmFtZSBvZiB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxvY2Fscy5cbiAqXG4gKiBUaGlzIHZhcmlhYmxlIGlzIG92ZXJyaWRkZW4gYnkge0BsaW5rIE9wdGlvbnN9YC5sb2NhbHNOYW1lYCBpZiBpdCBpcyBub3RcbiAqIGB1bmRlZmluZWRgLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5sb2NhbHNOYW1lID0gX0RFRkFVTFRfTE9DQUxTX05BTUU7XG5cbi8qKlxuICogUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiAtLSBkZWZhdWx0cyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZVxuICogVGhpcyBpcyBtb3N0bHkganVzdCBmb3IgdGVzdGFiaWxpdHlcbiAqXG4gKiBAdHlwZSB7UHJvbWlzZUNvbnN0cnVjdG9yTGlrZX1cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb21pc2VJbXBsID0gKG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXM7JykpKCkuUHJvbWlzZTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhdGggdG8gdGhlIGluY2x1ZGVkIGZpbGUgZnJvbSB0aGUgcGFyZW50IGZpbGUgcGF0aCBhbmQgdGhlXG4gKiBzcGVjaWZpZWQgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gIG5hbWUgICAgIHNwZWNpZmllZCBwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gIGZpbGVuYW1lIHBhcmVudCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzRGlyPWZhbHNlXSB3aGV0aGVyIHRoZSBwYXJlbnQgZmlsZSBwYXRoIGlzIGEgZGlyZWN0b3J5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMucmVzb2x2ZUluY2x1ZGUgPSBmdW5jdGlvbihuYW1lLCBmaWxlbmFtZSwgaXNEaXIpIHtcbiAgdmFyIGRpcm5hbWUgPSBwYXRoLmRpcm5hbWU7XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lO1xuICB2YXIgcmVzb2x2ZSA9IHBhdGgucmVzb2x2ZTtcbiAgdmFyIGluY2x1ZGVQYXRoID0gcmVzb2x2ZShpc0RpciA/IGZpbGVuYW1lIDogZGlybmFtZShmaWxlbmFtZSksIG5hbWUpO1xuICB2YXIgZXh0ID0gZXh0bmFtZShuYW1lKTtcbiAgaWYgKCFleHQpIHtcbiAgICBpbmNsdWRlUGF0aCArPSAnLmVqcyc7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVQYXRoO1xufTtcblxuLyoqXG4gKiBUcnkgdG8gcmVzb2x2ZSBmaWxlIHBhdGggb24gbXVsdGlwbGUgZGlyZWN0b3JpZXNcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICBuYW1lICBzcGVjaWZpZWQgcGF0aFxuICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gcGF0aHMgbGlzdCBvZiBwb3NzaWJsZSBwYXJlbnQgZGlyZWN0b3J5IHBhdGhzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVQYXRocyhuYW1lLCBwYXRocykge1xuICB2YXIgZmlsZVBhdGg7XG4gIGlmIChwYXRocy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgZmlsZVBhdGggPSBleHBvcnRzLnJlc29sdmVJbmNsdWRlKG5hbWUsIHYsIHRydWUpO1xuICAgIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKTtcbiAgfSkpIHtcbiAgICByZXR1cm4gZmlsZVBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHBhdGggdG8gdGhlIGluY2x1ZGVkIGZpbGUgYnkgT3B0aW9uc1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHBhdGggICAgc3BlY2lmaWVkIHBhdGhcbiAqIEBwYXJhbSAge09wdGlvbnN9IG9wdGlvbnMgY29tcGlsYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRJbmNsdWRlUGF0aChwYXRoLCBvcHRpb25zKSB7XG4gIHZhciBpbmNsdWRlUGF0aDtcbiAgdmFyIGZpbGVQYXRoO1xuICB2YXIgdmlld3MgPSBvcHRpb25zLnZpZXdzO1xuICB2YXIgbWF0Y2ggPSAvXltBLVphLXpdKzpcXFxcfF5cXC8vLmV4ZWMocGF0aCk7XG5cbiAgLy8gQWJzIHBhdGhcbiAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCkge1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8qLywgJycpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucm9vdCkpIHtcbiAgICAgIGluY2x1ZGVQYXRoID0gcmVzb2x2ZVBhdGhzKHBhdGgsIG9wdGlvbnMucm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluY2x1ZGVQYXRoID0gZXhwb3J0cy5yZXNvbHZlSW5jbHVkZShwYXRoLCBvcHRpb25zLnJvb3QgfHwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgLy8gUmVsYXRpdmUgcGF0aHNcbiAgZWxzZSB7XG4gICAgLy8gTG9vayByZWxhdGl2ZSB0byBhIHBhc3NlZCBmaWxlbmFtZSBmaXJzdFxuICAgIGlmIChvcHRpb25zLmZpbGVuYW1lKSB7XG4gICAgICBmaWxlUGF0aCA9IGV4cG9ydHMucmVzb2x2ZUluY2x1ZGUocGF0aCwgb3B0aW9ucy5maWxlbmFtZSk7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcbiAgICAgICAgaW5jbHVkZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlbiBsb29rIGluIGFueSB2aWV3cyBkaXJlY3Rvcmllc1xuICAgIGlmICghaW5jbHVkZVBhdGggJiYgQXJyYXkuaXNBcnJheSh2aWV3cykpIHtcbiAgICAgIGluY2x1ZGVQYXRoID0gcmVzb2x2ZVBhdGhzKHBhdGgsIHZpZXdzKTtcbiAgICB9XG4gICAgaWYgKCFpbmNsdWRlUGF0aCAmJiB0eXBlb2Ygb3B0aW9ucy5pbmNsdWRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0aGUgaW5jbHVkZSBmaWxlIFwiJyArXG4gICAgICAgICAgb3B0aW9ucy5lc2NhcGVGdW5jdGlvbihwYXRoKSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5jbHVkZVBhdGg7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZmlsZSwgZWl0aGVyIGNvbXBpbGVkIG9uLXRoZS1mbHkgb3JcbiAqIHJlYWQgZnJvbSBjYWNoZSAoaWYgZW5hYmxlZCksIGFuZCBjYWNoZSB0aGUgdGVtcGxhdGUgaWYgbmVlZGVkLlxuICpcbiAqIElmIGB0ZW1wbGF0ZWAgaXMgbm90IHNldCwgdGhlIGZpbGUgc3BlY2lmaWVkIGluIGBvcHRpb25zLmZpbGVuYW1lYCB3aWxsIGJlXG4gKiByZWFkLlxuICpcbiAqIElmIGBvcHRpb25zLmNhY2hlYCBpcyB0cnVlLCB0aGlzIGZ1bmN0aW9uIHJlYWRzIHRoZSBmaWxlIGZyb21cbiAqIGBvcHRpb25zLmZpbGVuYW1lYCBzbyBpdCBtdXN0IGJlIHNldCBwcmlvciB0byBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTplanMtaW50ZXJuYWxcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyAgIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdGVtcGxhdGVdIHRlbXBsYXRlIHNvdXJjZVxuICogQHJldHVybiB7KFRlbXBsYXRlRnVuY3Rpb258Q2xpZW50RnVuY3Rpb24pfVxuICogRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBgb3B0aW9ucy5jbGllbnRgLCBlaXRoZXIgdHlwZSBtaWdodCBiZSByZXR1cm5lZC5cbiAqIEBzdGF0aWNcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVDYWNoZShvcHRpb25zLCB0ZW1wbGF0ZSkge1xuICB2YXIgZnVuYztcbiAgdmFyIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgdmFyIGhhc1RlbXBsYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG5cbiAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhY2hlIG9wdGlvbiByZXF1aXJlcyBhIGZpbGVuYW1lJyk7XG4gICAgfVxuICAgIGZ1bmMgPSBleHBvcnRzLmNhY2hlLmdldChmaWxlbmFtZSk7XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICBpZiAoIWhhc1RlbXBsYXRlKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGZpbGVMb2FkZXIoZmlsZW5hbWUpLnRvU3RyaW5nKCkucmVwbGFjZShfQk9NLCAnJyk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKCFoYXNUZW1wbGF0ZSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZjogc2hvdWxkIG5vdCBoYXBwZW4gYXQgYWxsXG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFSlMgZXJyb3I6IG5vIGZpbGUgbmFtZSBvciB0ZW1wbGF0ZSAnXG4gICAgICAgICAgICAgICAgICAgICsgJ3Byb3ZpZGVkJyk7XG4gICAgfVxuICAgIHRlbXBsYXRlID0gZmlsZUxvYWRlcihmaWxlbmFtZSkudG9TdHJpbmcoKS5yZXBsYWNlKF9CT00sICcnKTtcbiAgfVxuICBmdW5jID0gZXhwb3J0cy5jb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICBleHBvcnRzLmNhY2hlLnNldChmaWxlbmFtZSwgZnVuYyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8qKlxuICogVHJ5IGNhbGxpbmcgaGFuZGxlQ2FjaGUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGF0YSBhbmQgY2FsbCB0aGVcbiAqIGNhbGxiYWNrIHdpdGggdGhlIHJlc3VsdC4gSWYgYW4gZXJyb3Igb2NjdXJzLCBjYWxsIHRoZSBjYWxsYmFjayB3aXRoXG4gKiB0aGUgZXJyb3IuIFVzZWQgYnkgcmVuZGVyRmlsZSgpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZWpzLWludGVybmFsXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgICAgY29tcGlsYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgIHRlbXBsYXRlIGRhdGFcbiAqIEBwYXJhbSB7UmVuZGVyRmlsZUNhbGxiYWNrfSBjYiBjYWxsYmFja1xuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIHRyeUhhbmRsZUNhY2hlKG9wdGlvbnMsIGRhdGEsIGNiKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICghY2IpIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMucHJvbWlzZUltcGwgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLnByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBoYW5kbGVDYWNoZShvcHRpb25zKShkYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZnVuY3Rpb24nKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGhhbmRsZUNhY2hlKG9wdGlvbnMpKGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICBjYihudWxsLCByZXN1bHQpO1xuICB9XG59XG5cbi8qKlxuICogZmlsZUxvYWRlciBpcyBpbmRlcGVuZGVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlUGF0aCBlanMgZmlsZSBwYXRoLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIGZpbGVMb2FkZXIoZmlsZVBhdGgpe1xuICByZXR1cm4gZXhwb3J0cy5maWxlTG9hZGVyKGZpbGVQYXRoKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICpcbiAqIElmIGBvcHRpb25zLmNhY2hlYCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRlbXBsYXRlIGlzIGNhY2hlZC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmVqcy1pbnRlcm5hbFxuICogQHBhcmFtIHtTdHJpbmd9ICBwYXRoICAgIHBhdGggZm9yIHRoZSBzcGVjaWZpZWQgZmlsZVxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4geyhUZW1wbGF0ZUZ1bmN0aW9ufENsaWVudEZ1bmN0aW9uKX1cbiAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuY2xpZW50YCwgZWl0aGVyIHR5cGUgbWlnaHQgYmUgcmV0dXJuZWRcbiAqIEBzdGF0aWNcbiAqL1xuXG5mdW5jdGlvbiBpbmNsdWRlRmlsZShwYXRoLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdXRpbHMuc2hhbGxvd0NvcHkodXRpbHMuY3JlYXRlTnVsbFByb3RvT2JqV2hlcmVQb3NzaWJsZSgpLCBvcHRpb25zKTtcbiAgb3B0cy5maWxlbmFtZSA9IGdldEluY2x1ZGVQYXRoKHBhdGgsIG9wdHMpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5jbHVkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgaW5jbHVkZXJSZXN1bHQgPSBvcHRpb25zLmluY2x1ZGVyKHBhdGgsIG9wdHMuZmlsZW5hbWUpO1xuICAgIGlmIChpbmNsdWRlclJlc3VsdCkge1xuICAgICAgaWYgKGluY2x1ZGVyUmVzdWx0LmZpbGVuYW1lKSB7XG4gICAgICAgIG9wdHMuZmlsZW5hbWUgPSBpbmNsdWRlclJlc3VsdC5maWxlbmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlclJlc3VsdC50ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FjaGUob3B0cywgaW5jbHVkZXJSZXN1bHQudGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlQ2FjaGUob3B0cyk7XG59XG5cbi8qKlxuICogUmUtdGhyb3cgdGhlIGdpdmVuIGBlcnJgIGluIGNvbnRleHQgdG8gdGhlIGBzdHJgIG9mIGVqcywgYGZpbGVuYW1lYCwgYW5kXG4gKiBgbGluZW5vYC5cbiAqXG4gKiBAaW1wbGVtZW50cyB7UmV0aHJvd0NhbGxiYWNrfVxuICogQG1lbWJlcm9mIG1vZHVsZTplanMtaW50ZXJuYWxcbiAqIEBwYXJhbSB7RXJyb3J9ICBlcnIgICAgICBFcnJvciBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICBFSlMgc291cmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxubSAgICAgZmlsZSBuYW1lIG9mIHRoZSBFSlMgZmlsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVubyAgIGxpbmUgbnVtYmVyIG9mIHRoZSBlcnJvclxuICogQHBhcmFtIHtFc2NhcGVDYWxsYmFja30gZXNjXG4gKiBAc3RhdGljXG4gKi9cblxuZnVuY3Rpb24gcmV0aHJvdyhlcnIsIHN0ciwgZmxubSwgbGluZW5vLCBlc2MpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgobGluZW5vIC0gMywgMCk7XG4gIHZhciBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVubyArIDMpO1xuICB2YXIgZmlsZW5hbWUgPSBlc2MoZmxubSk7XG4gIC8vIEVycm9yIGNvbnRleHRcbiAgdmFyIGNvbnRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpe1xuICAgIHZhciBjdXJyID0gaSArIHN0YXJ0ICsgMTtcbiAgICByZXR1cm4gKGN1cnIgPT0gbGluZW5vID8gJyA+PiAnIDogJyAgICAnKVxuICAgICAgKyBjdXJyXG4gICAgICArICd8ICdcbiAgICAgICsgbGluZTtcbiAgfSkuam9pbignXFxuJyk7XG5cbiAgLy8gQWx0ZXIgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgZXJyLnBhdGggPSBmaWxlbmFtZTtcbiAgZXJyLm1lc3NhZ2UgPSAoZmlsZW5hbWUgfHwgJ2VqcycpICsgJzonXG4gICAgKyBsaW5lbm8gKyAnXFxuJ1xuICAgICsgY29udGV4dCArICdcXG5cXG4nXG4gICAgKyBlcnIubWVzc2FnZTtcblxuICB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIHN0cmlwU2VtaShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLzsoXFxzKiQpLywgJyQxJyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYHN0cmAgb2YgZWpzIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gIHRlbXBsYXRlIEVKUyB0ZW1wbGF0ZVxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdHNdIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHsoVGVtcGxhdGVGdW5jdGlvbnxDbGllbnRGdW5jdGlvbil9XG4gKiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGBvcHRzLmNsaWVudGAsIGVpdGhlciB0eXBlIG1pZ2h0IGJlIHJldHVybmVkLlxuICogTm90ZSB0aGF0IHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgZnVuY3Rpb24gYWxzbyBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBgb3B0cy5hc3luY2AuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0cykge1xuICB2YXIgdGVtcGw7XG5cbiAgLy8gdjEgY29tcGF0XG4gIC8vICdzY29wZScgaXMgJ2NvbnRleHQnXG4gIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gIGlmIChvcHRzICYmIG9wdHMuc2NvcGUpIHtcbiAgICBpZiAoIXNjb3BlT3B0aW9uV2FybmVkKXtcbiAgICAgIGNvbnNvbGUud2FybignYHNjb3BlYCBvcHRpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIEVKUyAzJyk7XG4gICAgICBzY29wZU9wdGlvbldhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghb3B0cy5jb250ZXh0KSB7XG4gICAgICBvcHRzLmNvbnRleHQgPSBvcHRzLnNjb3BlO1xuICAgIH1cbiAgICBkZWxldGUgb3B0cy5zY29wZTtcbiAgfVxuICB0ZW1wbCA9IG5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3B0cyk7XG4gIHJldHVybiB0ZW1wbC5jb21waWxlKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBvZiBlanMuXG4gKlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gaW5jbHVkZSBvcHRpb25zIGJ1dCBub3QgZGF0YSwgeW91IG5lZWQgdG8gZXhwbGljaXRseVxuICogY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggYGRhdGFgIGJlaW5nIGFuIGVtcHR5IG9iamVjdCBvciBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICAgdGVtcGxhdGUgRUpTIHRlbXBsYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gIFtkYXRhPXt9XSB0ZW1wbGF0ZSBkYXRhXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRzPXt9XSBjb21waWxhdGlvbiBhbmQgcmVuZGVyaW5nIG9wdGlvbnNcbiAqIEByZXR1cm4geyhTdHJpbmd8UHJvbWlzZTxTdHJpbmc+KX1cbiAqIFJldHVybiB2YWx1ZSB0eXBlIGRlcGVuZHMgb24gYG9wdHMuYXN5bmNgLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVuZGVyID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkLCBvKSB7XG4gIHZhciBkYXRhID0gZCB8fCB1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7XG4gIHZhciBvcHRzID0gbyB8fCB1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7XG5cbiAgLy8gTm8gb3B0aW9ucyBvYmplY3QgLS0gaWYgdGhlcmUgYXJlIG9wdGlvbnkgbmFtZXNcbiAgLy8gaW4gdGhlIGRhdGEsIGNvcHkgdGhlbSB0byBvcHRpb25zXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICB1dGlscy5zaGFsbG93Q29weUZyb21MaXN0KG9wdHMsIGRhdGEsIF9PUFRTX1BBU1NBQkxFX1dJVEhfREFUQSk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlQ2FjaGUob3B0cywgdGVtcGxhdGUpKGRhdGEpO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgYW4gRUpTIGZpbGUgYXQgdGhlIGdpdmVuIGBwYXRoYCBhbmQgY2FsbGJhY2sgYGNiKGVyciwgc3RyKWAuXG4gKlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gaW5jbHVkZSBvcHRpb25zIGJ1dCBub3QgZGF0YSwgeW91IG5lZWQgdG8gZXhwbGljaXRseVxuICogY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggYGRhdGFgIGJlaW5nIGFuIGVtcHR5IG9iamVjdCBvciBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIHBhdGggICAgIHBhdGggdG8gdGhlIEVKUyBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICBbZGF0YT17fV0gdGVtcGxhdGUgZGF0YVxuICogQHBhcmFtIHtPcHRpb25zfSAgICAgICAgICAgW29wdHM9e31dIGNvbXBpbGF0aW9uIGFuZCByZW5kZXJpbmcgb3B0aW9uc1xuICogQHBhcmFtIHtSZW5kZXJGaWxlQ2FsbGJhY2t9IGNiIGNhbGxiYWNrXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZW5kZXJGaWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBmaWxlbmFtZSA9IGFyZ3Muc2hpZnQoKTtcbiAgdmFyIGNiO1xuICB2YXIgb3B0cyA9IHtmaWxlbmFtZTogZmlsZW5hbWV9O1xuICB2YXIgZGF0YTtcbiAgdmFyIHZpZXdPcHRzO1xuXG4gIC8vIERvIHdlIGhhdmUgYSBjYWxsYmFjaz9cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGFyZ3MucG9wKCk7XG4gIH1cbiAgLy8gRG8gd2UgaGF2ZSBkYXRhL29wdHM/XG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgaGF2ZSBkYXRhIG9ialxuICAgIGRhdGEgPSBhcmdzLnNoaWZ0KCk7XG4gICAgLy8gTm9ybWFsIHBhc3NlZCBvcHRzIChkYXRhIG9iaiArIG9wdHMgb2JqKVxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgLy8gVXNlIHNoYWxsb3dDb3B5IHNvIHdlIGRvbid0IHBvbGx1dGUgcGFzc2VkIGluIG9wdHMgb2JqIHdpdGggbmV3IHZhbHNcbiAgICAgIHV0aWxzLnNoYWxsb3dDb3B5KG9wdHMsIGFyZ3MucG9wKCkpO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2luZyBmb3IgRXhwcmVzcyAoc2V0dGluZ3MgKyBvcHRzLWluLWRhdGEpXG4gICAgZWxzZSB7XG4gICAgICAvLyBFeHByZXNzIDMgYW5kIDRcbiAgICAgIGlmIChkYXRhLnNldHRpbmdzKSB7XG4gICAgICAgIC8vIFB1bGwgYSBmZXcgdGhpbmdzIGZyb20ga25vd24gbG9jYXRpb25zXG4gICAgICAgIGlmIChkYXRhLnNldHRpbmdzLnZpZXdzKSB7XG4gICAgICAgICAgb3B0cy52aWV3cyA9IGRhdGEuc2V0dGluZ3Mudmlld3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2V0dGluZ3NbJ3ZpZXcgY2FjaGUnXSkge1xuICAgICAgICAgIG9wdHMuY2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVuZG9jdW1lbnRlZCBhZnRlciBFeHByZXNzIDIsIGJ1dCBzdGlsbCB1c2FibGUsIGVzcC4gZm9yXG4gICAgICAgIC8vIGl0ZW1zIHRoYXQgYXJlIHVuc2FmZSB0byBiZSBwYXNzZWQgYWxvbmcgd2l0aCBkYXRhLCBsaWtlIGByb290YFxuICAgICAgICB2aWV3T3B0cyA9IGRhdGEuc2V0dGluZ3NbJ3ZpZXcgb3B0aW9ucyddO1xuICAgICAgICBpZiAodmlld09wdHMpIHtcbiAgICAgICAgICB1dGlscy5zaGFsbG93Q29weShvcHRzLCB2aWV3T3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEV4cHJlc3MgMiBhbmQgbG93ZXIsIHZhbHVlcyBzZXQgaW4gYXBwLmxvY2Fscywgb3IgcGVvcGxlIHdobyBqdXN0XG4gICAgICAvLyB3YW50IHRvIHBhc3Mgb3B0aW9ucyBpbiB0aGVpciBkYXRhLiBOT1RFOiBUaGVzZSB2YWx1ZXMgd2lsbCBvdmVycmlkZVxuICAgICAgLy8gYW55dGhpbmcgcHJldmlvdXNseSBzZXQgaW4gc2V0dGluZ3MgIG9yIHNldHRpbmdzWyd2aWV3IG9wdGlvbnMnXVxuICAgICAgdXRpbHMuc2hhbGxvd0NvcHlGcm9tTGlzdChvcHRzLCBkYXRhLCBfT1BUU19QQVNTQUJMRV9XSVRIX0RBVEFfRVhQUkVTUyk7XG4gICAgfVxuICAgIG9wdHMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkYXRhID0gdXRpbHMuY3JlYXRlTnVsbFByb3RvT2JqV2hlcmVQb3NzaWJsZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRyeUhhbmRsZUNhY2hlKG9wdHMsIGRhdGEsIGNiKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgaW50ZXJtZWRpYXRlIEphdmFTY3JpcHQgY2FjaGUuIENhbGxzIHtAbGluayBDYWNoZSNyZXNldH0uXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBFSlMgdGVtcGxhdGUgY2xhc3NcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5UZW1wbGF0ZSA9IFRlbXBsYXRlO1xuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGV4cG9ydHMuY2FjaGUucmVzZXQoKTtcbn07XG5cbmZ1bmN0aW9uIFRlbXBsYXRlKHRleHQsIG9wdHNQYXJhbSkge1xuICB2YXIgb3B0cyA9IHV0aWxzLmhhc093bk9ubHlPYmplY3Qob3B0c1BhcmFtKTtcbiAgdmFyIG9wdGlvbnMgPSB1dGlscy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7XG4gIHRoaXMudGVtcGxhdGVUZXh0ID0gdGV4dDtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuICB0aGlzLm1vZGUgPSBudWxsO1xuICB0aGlzLnRydW5jYXRlID0gZmFsc2U7XG4gIHRoaXMuY3VycmVudExpbmUgPSAxO1xuICB0aGlzLnNvdXJjZSA9ICcnO1xuICBvcHRpb25zLmNsaWVudCA9IG9wdHMuY2xpZW50IHx8IGZhbHNlO1xuICBvcHRpb25zLmVzY2FwZUZ1bmN0aW9uID0gb3B0cy5lc2NhcGUgfHwgb3B0cy5lc2NhcGVGdW5jdGlvbiB8fCB1dGlscy5lc2NhcGVYTUw7XG4gIG9wdGlvbnMuY29tcGlsZURlYnVnID0gb3B0cy5jb21waWxlRGVidWcgIT09IGZhbHNlO1xuICBvcHRpb25zLmRlYnVnID0gISFvcHRzLmRlYnVnO1xuICBvcHRpb25zLmZpbGVuYW1lID0gb3B0cy5maWxlbmFtZTtcbiAgb3B0aW9ucy5vcGVuRGVsaW1pdGVyID0gb3B0cy5vcGVuRGVsaW1pdGVyIHx8IGV4cG9ydHMub3BlbkRlbGltaXRlciB8fCBfREVGQVVMVF9PUEVOX0RFTElNSVRFUjtcbiAgb3B0aW9ucy5jbG9zZURlbGltaXRlciA9IG9wdHMuY2xvc2VEZWxpbWl0ZXIgfHwgZXhwb3J0cy5jbG9zZURlbGltaXRlciB8fCBfREVGQVVMVF9DTE9TRV9ERUxJTUlURVI7XG4gIG9wdGlvbnMuZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgZXhwb3J0cy5kZWxpbWl0ZXIgfHwgX0RFRkFVTFRfREVMSU1JVEVSO1xuICBvcHRpb25zLnN0cmljdCA9IG9wdHMuc3RyaWN0IHx8IGZhbHNlO1xuICBvcHRpb25zLmNvbnRleHQgPSBvcHRzLmNvbnRleHQ7XG4gIG9wdGlvbnMuY2FjaGUgPSBvcHRzLmNhY2hlIHx8IGZhbHNlO1xuICBvcHRpb25zLnJtV2hpdGVzcGFjZSA9IG9wdHMucm1XaGl0ZXNwYWNlO1xuICBvcHRpb25zLnJvb3QgPSBvcHRzLnJvb3Q7XG4gIG9wdGlvbnMuaW5jbHVkZXIgPSBvcHRzLmluY2x1ZGVyO1xuICBvcHRpb25zLm91dHB1dEZ1bmN0aW9uTmFtZSA9IG9wdHMub3V0cHV0RnVuY3Rpb25OYW1lO1xuICBvcHRpb25zLmxvY2Fsc05hbWUgPSBvcHRzLmxvY2Fsc05hbWUgfHwgZXhwb3J0cy5sb2NhbHNOYW1lIHx8IF9ERUZBVUxUX0xPQ0FMU19OQU1FO1xuICBvcHRpb25zLnZpZXdzID0gb3B0cy52aWV3cztcbiAgb3B0aW9ucy5hc3luYyA9IG9wdHMuYXN5bmM7XG4gIG9wdGlvbnMuZGVzdHJ1Y3R1cmVkTG9jYWxzID0gb3B0cy5kZXN0cnVjdHVyZWRMb2NhbHM7XG4gIG9wdGlvbnMubGVnYWN5SW5jbHVkZSA9IHR5cGVvZiBvcHRzLmxlZ2FjeUluY2x1ZGUgIT0gJ3VuZGVmaW5lZCcgPyAhIW9wdHMubGVnYWN5SW5jbHVkZSA6IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgb3B0aW9ucy5fd2l0aCA9IGZhbHNlO1xuICB9XG4gIGVsc2Uge1xuICAgIG9wdGlvbnMuX3dpdGggPSB0eXBlb2Ygb3B0cy5fd2l0aCAhPSAndW5kZWZpbmVkJyA/IG9wdHMuX3dpdGggOiB0cnVlO1xuICB9XG5cbiAgdGhpcy5vcHRzID0gb3B0aW9ucztcblxuICB0aGlzLnJlZ2V4ID0gdGhpcy5jcmVhdGVSZWdleCgpO1xufVxuXG5UZW1wbGF0ZS5tb2RlcyA9IHtcbiAgRVZBTDogJ2V2YWwnLFxuICBFU0NBUEVEOiAnZXNjYXBlZCcsXG4gIFJBVzogJ3JhdycsXG4gIENPTU1FTlQ6ICdjb21tZW50JyxcbiAgTElURVJBTDogJ2xpdGVyYWwnXG59O1xuXG5UZW1wbGF0ZS5wcm90b3R5cGUgPSB7XG4gIGNyZWF0ZVJlZ2V4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0ciA9IF9SRUdFWF9TVFJJTkc7XG4gICAgdmFyIGRlbGltID0gdXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLmRlbGltaXRlcik7XG4gICAgdmFyIG9wZW4gPSB1dGlscy5lc2NhcGVSZWdFeHBDaGFycyh0aGlzLm9wdHMub3BlbkRlbGltaXRlcik7XG4gICAgdmFyIGNsb3NlID0gdXRpbHMuZXNjYXBlUmVnRXhwQ2hhcnModGhpcy5vcHRzLmNsb3NlRGVsaW1pdGVyKTtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvJS9nLCBkZWxpbSlcbiAgICAgIC5yZXBsYWNlKC88L2csIG9wZW4pXG4gICAgICAucmVwbGFjZSgvPi9nLCBjbG9zZSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3RyKTtcbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIHNyYztcbiAgICAvKiogQHR5cGUge0NsaWVudEZ1bmN0aW9ufSAqL1xuICAgIHZhciBmbjtcbiAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICB2YXIgcHJlcGVuZGVkID0gJyc7XG4gICAgdmFyIGFwcGVuZGVkID0gJyc7XG4gICAgLyoqIEB0eXBlIHtFc2NhcGVDYWxsYmFja30gKi9cbiAgICB2YXIgZXNjYXBlRm4gPSBvcHRzLmVzY2FwZUZ1bmN0aW9uO1xuICAgIC8qKiBAdHlwZSB7RnVuY3Rpb25Db25zdHJ1Y3Rvcn0gKi9cbiAgICB2YXIgY3RvcjtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgc2FuaXRpemVkRmlsZW5hbWUgPSBvcHRzLmZpbGVuYW1lID8gSlNPTi5zdHJpbmdpZnkob3B0cy5maWxlbmFtZSkgOiAndW5kZWZpbmVkJztcblxuICAgIGlmICghdGhpcy5zb3VyY2UpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVTb3VyY2UoKTtcbiAgICAgIHByZXBlbmRlZCArPVxuICAgICAgICAnICB2YXIgX19vdXRwdXQgPSBcIlwiO1xcbicgK1xuICAgICAgICAnICBmdW5jdGlvbiBfX2FwcGVuZChzKSB7IGlmIChzICE9PSB1bmRlZmluZWQgJiYgcyAhPT0gbnVsbCkgX19vdXRwdXQgKz0gcyB9XFxuJztcbiAgICAgIGlmIChvcHRzLm91dHB1dEZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBpZiAoIV9KU19JREVOVElGSUVSLnRlc3Qob3B0cy5vdXRwdXRGdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRGdW5jdGlvbk5hbWUgaXMgbm90IGEgdmFsaWQgSlMgaWRlbnRpZmllci4nKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwZW5kZWQgKz0gJyAgdmFyICcgKyBvcHRzLm91dHB1dEZ1bmN0aW9uTmFtZSArICcgPSBfX2FwcGVuZDsnICsgJ1xcbic7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5sb2NhbHNOYW1lICYmICFfSlNfSURFTlRJRklFUi50ZXN0KG9wdHMubG9jYWxzTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbHNOYW1lIGlzIG5vdCBhIHZhbGlkIEpTIGlkZW50aWZpZXIuJyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5kZXN0cnVjdHVyZWRMb2NhbHMgJiYgb3B0cy5kZXN0cnVjdHVyZWRMb2NhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBkZXN0cnVjdHVyaW5nID0gJyAgdmFyIF9fbG9jYWxzID0gKCcgKyBvcHRzLmxvY2Fsc05hbWUgKyAnIHx8IHt9KSxcXG4nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMuZGVzdHJ1Y3R1cmVkTG9jYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzLmRlc3RydWN0dXJlZExvY2Fsc1tpXTtcbiAgICAgICAgICBpZiAoIV9KU19JREVOVElGSUVSLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdHJ1Y3R1cmVkTG9jYWxzWycgKyBpICsgJ10gaXMgbm90IGEgdmFsaWQgSlMgaWRlbnRpZmllci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBkZXN0cnVjdHVyaW5nICs9ICcsXFxuICAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0cnVjdHVyaW5nICs9IG5hbWUgKyAnID0gX19sb2NhbHMuJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGVuZGVkICs9IGRlc3RydWN0dXJpbmcgKyAnO1xcbic7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5fd2l0aCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcHJlcGVuZGVkICs9ICAnICB3aXRoICgnICsgb3B0cy5sb2NhbHNOYW1lICsgJyB8fCB7fSkgeycgKyAnXFxuJztcbiAgICAgICAgYXBwZW5kZWQgKz0gJyAgfScgKyAnXFxuJztcbiAgICAgIH1cbiAgICAgIGFwcGVuZGVkICs9ICcgIHJldHVybiBfX291dHB1dDsnICsgJ1xcbic7XG4gICAgICB0aGlzLnNvdXJjZSA9IHByZXBlbmRlZCArIHRoaXMuc291cmNlICsgYXBwZW5kZWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY29tcGlsZURlYnVnKSB7XG4gICAgICBzcmMgPSAndmFyIF9fbGluZSA9IDEnICsgJ1xcbidcbiAgICAgICAgKyAnICAsIF9fbGluZXMgPSAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZW1wbGF0ZVRleHQpICsgJ1xcbidcbiAgICAgICAgKyAnICAsIF9fZmlsZW5hbWUgPSAnICsgc2FuaXRpemVkRmlsZW5hbWUgKyAnOycgKyAnXFxuJ1xuICAgICAgICArICd0cnkgeycgKyAnXFxuJ1xuICAgICAgICArIHRoaXMuc291cmNlXG4gICAgICAgICsgJ30gY2F0Y2ggKGUpIHsnICsgJ1xcbidcbiAgICAgICAgKyAnICByZXRocm93KGUsIF9fbGluZXMsIF9fZmlsZW5hbWUsIF9fbGluZSwgZXNjYXBlRm4pOycgKyAnXFxuJ1xuICAgICAgICArICd9JyArICdcXG4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNyYyA9IHRoaXMuc291cmNlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNsaWVudCkge1xuICAgICAgc3JjID0gJ2VzY2FwZUZuID0gZXNjYXBlRm4gfHwgJyArIGVzY2FwZUZuLnRvU3RyaW5nKCkgKyAnOycgKyAnXFxuJyArIHNyYztcbiAgICAgIGlmIChvcHRzLmNvbXBpbGVEZWJ1Zykge1xuICAgICAgICBzcmMgPSAncmV0aHJvdyA9IHJldGhyb3cgfHwgJyArIHJldGhyb3cudG9TdHJpbmcoKSArICc7JyArICdcXG4nICsgc3JjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLnN0cmljdCkge1xuICAgICAgc3JjID0gJ1widXNlIHN0cmljdFwiO1xcbicgKyBzcmM7XG4gICAgfVxuICAgIGlmIChvcHRzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhzcmMpO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb21waWxlRGVidWcgJiYgb3B0cy5maWxlbmFtZSkge1xuICAgICAgc3JjID0gc3JjICsgJ1xcbidcbiAgICAgICAgKyAnLy8jIHNvdXJjZVVSTD0nICsgc2FuaXRpemVkRmlsZW5hbWUgKyAnXFxuJztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMuYXN5bmMpIHtcbiAgICAgICAgLy8gSGF2ZSB0byB1c2UgZ2VuZXJhdGVkIGZ1bmN0aW9uIGZvciB0aGlzLCBzaW5jZSBpbiBlbnZzIHdpdGhvdXQgc3VwcG9ydCxcbiAgICAgICAgLy8gaXQgYnJlYWtzIGluIHBhcnNpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjdG9yID0gKG5ldyBGdW5jdGlvbigncmV0dXJuIChhc3luYyBmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yOycpKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBhc3luYy9hd2FpdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3RvciA9IEZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgZm4gPSBuZXcgY3RvcihvcHRzLmxvY2Fsc05hbWUgKyAnLCBlc2NhcGVGbiwgaW5jbHVkZSwgcmV0aHJvdycsIHNyYyk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIGlmIChvcHRzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9ICcgaW4gJyArIG9wdHMuZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZS5tZXNzYWdlICs9ICcgd2hpbGUgY29tcGlsaW5nIGVqc1xcblxcbic7XG4gICAgICAgIGUubWVzc2FnZSArPSAnSWYgdGhlIGFib3ZlIGVycm9yIGlzIG5vdCBoZWxwZnVsLCB5b3UgbWF5IHdhbnQgdG8gdHJ5IEVKUy1MaW50Olxcbic7XG4gICAgICAgIGUubWVzc2FnZSArPSAnaHR0cHM6Ly9naXRodWIuY29tL1J5YW5aaW0vRUpTLUxpbnQnO1xuICAgICAgICBpZiAoIW9wdHMuYXN5bmMpIHtcbiAgICAgICAgICBlLm1lc3NhZ2UgKz0gJ1xcbic7XG4gICAgICAgICAgZS5tZXNzYWdlICs9ICdPciwgaWYgeW91IG1lYW50IHRvIGNyZWF0ZSBhbiBhc3luYyBmdW5jdGlvbiwgcGFzcyBgYXN5bmM6IHRydWVgIGFzIGFuIG9wdGlvbi4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAgICAvLyBjcmVhdGVkIGJ5IHRoZSBzb3VyY2UtY29kZSwgd2l0aCB0aGUgcGFzc2VkIGRhdGEgYXMgbG9jYWxzXG4gICAgLy8gQWRkcyBhIGxvY2FsIGBpbmNsdWRlYCBmdW5jdGlvbiB3aGljaCBhbGxvd3MgZnVsbCByZWN1cnNpdmUgaW5jbHVkZVxuICAgIHZhciByZXR1cm5lZEZuID0gb3B0cy5jbGllbnQgPyBmbiA6IGZ1bmN0aW9uIGFub255bW91cyhkYXRhKSB7XG4gICAgICB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uIChwYXRoLCBpbmNsdWRlRGF0YSkge1xuICAgICAgICB2YXIgZCA9IHV0aWxzLnNoYWxsb3dDb3B5KHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKSwgZGF0YSk7XG4gICAgICAgIGlmIChpbmNsdWRlRGF0YSkge1xuICAgICAgICAgIGQgPSB1dGlscy5zaGFsbG93Q29weShkLCBpbmNsdWRlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGVGaWxlKHBhdGgsIG9wdHMpKGQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmbi5hcHBseShvcHRzLmNvbnRleHQsXG4gICAgICAgIFtkYXRhIHx8IHV0aWxzLmNyZWF0ZU51bGxQcm90b09ialdoZXJlUG9zc2libGUoKSwgZXNjYXBlRm4sIGluY2x1ZGUsIHJldGhyb3ddKTtcbiAgICB9O1xuICAgIGlmIChvcHRzLmZpbGVuYW1lICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmaWxlbmFtZSA9IG9wdHMuZmlsZW5hbWU7XG4gICAgICB2YXIgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lLCBwYXRoLmV4dG5hbWUoZmlsZW5hbWUpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXR1cm5lZEZuLCAnbmFtZScsIHtcbiAgICAgICAgICB2YWx1ZTogYmFzZW5hbWUsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsvKiBpZ25vcmUgKi99XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5lZEZuO1xuICB9LFxuXG4gIGdlbmVyYXRlU291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG5cbiAgICBpZiAob3B0cy5ybVdoaXRlc3BhY2UpIHtcbiAgICAgIC8vIEhhdmUgdG8gdXNlIHR3byBzZXBhcmF0ZSByZXBsYWNlIGhlcmUgYXMgYF5gIGFuZCBgJGAgb3BlcmF0b3JzIGRvbid0XG4gICAgICAvLyB3b3JrIHdlbGwgd2l0aCBgXFxyYCBhbmQgZW1wdHkgbGluZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggdGhlIGBtYCBmbGFnLlxuICAgICAgdGhpcy50ZW1wbGF0ZVRleHQgPVxuICAgICAgICB0aGlzLnRlbXBsYXRlVGV4dC5yZXBsYWNlKC9bXFxyXFxuXSsvZywgJ1xcbicpLnJlcGxhY2UoL15cXHMrfFxccyskL2dtLCAnJyk7XG4gICAgfVxuXG4gICAgLy8gU2x1cnAgc3BhY2VzIGFuZCB0YWJzIGJlZm9yZSA8JV8gYW5kIGFmdGVyIF8lPlxuICAgIHRoaXMudGVtcGxhdGVUZXh0ID1cbiAgICAgIHRoaXMudGVtcGxhdGVUZXh0LnJlcGxhY2UoL1sgXFx0XSo8JV8vZ20sICc8JV8nKS5yZXBsYWNlKC9fJT5bIFxcdF0qL2dtLCAnXyU+Jyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hdGNoZXMgPSB0aGlzLnBhcnNlVGVtcGxhdGVUZXh0KCk7XG4gICAgdmFyIGQgPSB0aGlzLm9wdHMuZGVsaW1pdGVyO1xuICAgIHZhciBvID0gdGhpcy5vcHRzLm9wZW5EZWxpbWl0ZXI7XG4gICAgdmFyIGMgPSB0aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXI7XG5cbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgICB2YXIgY2xvc2luZztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBvcGVuaW5nIHRhZywgY2hlY2sgZm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAvLyBGSVhNRTogTWF5IGVuZCB1cCB3aXRoIHNvbWUgZmFsc2UgcG9zaXRpdmVzIGhlcmVcbiAgICAgICAgLy8gQmV0dGVyIHRvIHN0b3JlIG1vZGVzIGFzIGsvdiB3aXRoIG9wZW5EZWxpbWl0ZXIgKyBkZWxpbWl0ZXIgYXMga2V5XG4gICAgICAgIC8vIFRoZW4gdGhpcyBjYW4gc2ltcGx5IGNoZWNrIGFnYWluc3QgdGhlIG1hcFxuICAgICAgICBpZiAoIGxpbmUuaW5kZXhPZihvICsgZCkgPT09IDAgICAgICAgIC8vIElmIGl0IGlzIGEgdGFnXG4gICAgICAgICAgJiYgbGluZS5pbmRleE9mKG8gKyBkICsgZCkgIT09IDApIHsgLy8gYW5kIGlzIG5vdCBlc2NhcGVkXG4gICAgICAgICAgY2xvc2luZyA9IG1hdGNoZXNbaW5kZXggKyAyXTtcbiAgICAgICAgICBpZiAoIShjbG9zaW5nID09IGQgKyBjIHx8IGNsb3NpbmcgPT0gJy0nICsgZCArIGMgfHwgY2xvc2luZyA9PSAnXycgKyBkICsgYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgbWF0Y2hpbmcgY2xvc2UgdGFnIGZvciBcIicgKyBsaW5lICsgJ1wiLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNjYW5MaW5lKGxpbmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgcGFyc2VUZW1wbGF0ZVRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RyID0gdGhpcy50ZW1wbGF0ZVRleHQ7XG4gICAgdmFyIHBhdCA9IHRoaXMucmVnZXg7XG4gICAgdmFyIHJlc3VsdCA9IHBhdC5leGVjKHN0cik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBmaXJzdFBvcztcblxuICAgIHdoaWxlIChyZXN1bHQpIHtcbiAgICAgIGZpcnN0UG9zID0gcmVzdWx0LmluZGV4O1xuXG4gICAgICBpZiAoZmlyc3RQb3MgIT09IDApIHtcbiAgICAgICAgYXJyLnB1c2goc3RyLnN1YnN0cmluZygwLCBmaXJzdFBvcykpO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoZmlyc3RQb3MpO1xuICAgICAgfVxuXG4gICAgICBhcnIucHVzaChyZXN1bHRbMF0pO1xuICAgICAgc3RyID0gc3RyLnNsaWNlKHJlc3VsdFswXS5sZW5ndGgpO1xuICAgICAgcmVzdWx0ID0gcGF0LmV4ZWMoc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyKSB7XG4gICAgICBhcnIucHVzaChzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH0sXG5cbiAgX2FkZE91dHB1dDogZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAodGhpcy50cnVuY2F0ZSkge1xuICAgICAgLy8gT25seSByZXBsYWNlIHNpbmdsZSBsZWFkaW5nIGxpbmVicmVhayBpbiB0aGUgbGluZSBhZnRlclxuICAgICAgLy8gLSU+IHRhZyAtLSB0aGlzIGlzIHRoZSBzaW5nbGUsIHRyYWlsaW5nIGxpbmVicmVha1xuICAgICAgLy8gYWZ0ZXIgdGhlIHRhZyB0aGF0IHRoZSB0cnVuY2F0aW9uIG1vZGUgcmVwbGFjZXNcbiAgICAgIC8vIEhhbmRsZSBXaW4gLyBVbml4IC8gb2xkIE1hYyBsaW5lYnJlYWtzIC0tIGRvIHRoZSBcXHJcXG5cbiAgICAgIC8vIGNvbWJvIGZpcnN0IGluIHRoZSByZWdleC1vclxuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXig/OlxcclxcbnxcXHJ8XFxuKS8sICcnKTtcbiAgICAgIHRoaXMudHJ1bmNhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyBQcmVzZXJ2ZSBsaXRlcmFsIHNsYXNoZXNcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xuXG4gICAgLy8gQ29udmVydCBsaW5lYnJlYWtzXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFxuL2csICdcXFxcbicpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKTtcblxuICAgIC8vIEVzY2FwZSBkb3VibGUtcXVvdGVzXG4gICAgLy8gLSB0aGlzIHdpbGwgYmUgdGhlIGRlbGltaXRlciBkdXJpbmcgZXhlY3V0aW9uXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICAgIHRoaXMuc291cmNlICs9ICcgICAgOyBfX2FwcGVuZChcIicgKyBsaW5lICsgJ1wiKScgKyAnXFxuJztcbiAgfSxcblxuICBzY2FuTGluZTogZnVuY3Rpb24gKGxpbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGQgPSB0aGlzLm9wdHMuZGVsaW1pdGVyO1xuICAgIHZhciBvID0gdGhpcy5vcHRzLm9wZW5EZWxpbWl0ZXI7XG4gICAgdmFyIGMgPSB0aGlzLm9wdHMuY2xvc2VEZWxpbWl0ZXI7XG4gICAgdmFyIG5ld0xpbmVDb3VudCA9IDA7XG5cbiAgICBuZXdMaW5lQ291bnQgPSAobGluZS5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMSk7XG5cbiAgICBzd2l0Y2ggKGxpbmUpIHtcbiAgICBjYXNlIG8gKyBkOlxuICAgIGNhc2UgbyArIGQgKyAnXyc6XG4gICAgICB0aGlzLm1vZGUgPSBUZW1wbGF0ZS5tb2Rlcy5FVkFMO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvICsgZCArICc9JzpcbiAgICAgIHRoaXMubW9kZSA9IFRlbXBsYXRlLm1vZGVzLkVTQ0FQRUQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG8gKyBkICsgJy0nOlxuICAgICAgdGhpcy5tb2RlID0gVGVtcGxhdGUubW9kZXMuUkFXO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvICsgZCArICcjJzpcbiAgICAgIHRoaXMubW9kZSA9IFRlbXBsYXRlLm1vZGVzLkNPTU1FTlQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG8gKyBkICsgZDpcbiAgICAgIHRoaXMubW9kZSA9IFRlbXBsYXRlLm1vZGVzLkxJVEVSQUw7XG4gICAgICB0aGlzLnNvdXJjZSArPSAnICAgIDsgX19hcHBlbmQoXCInICsgbGluZS5yZXBsYWNlKG8gKyBkICsgZCwgbyArIGQpICsgJ1wiKScgKyAnXFxuJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZCArIGQgKyBjOlxuICAgICAgdGhpcy5tb2RlID0gVGVtcGxhdGUubW9kZXMuTElURVJBTDtcbiAgICAgIHRoaXMuc291cmNlICs9ICcgICAgOyBfX2FwcGVuZChcIicgKyBsaW5lLnJlcGxhY2UoZCArIGQgKyBjLCBkICsgYykgKyAnXCIpJyArICdcXG4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBkICsgYzpcbiAgICBjYXNlICctJyArIGQgKyBjOlxuICAgIGNhc2UgJ18nICsgZCArIGM6XG4gICAgICBpZiAodGhpcy5tb2RlID09IFRlbXBsYXRlLm1vZGVzLkxJVEVSQUwpIHtcbiAgICAgICAgdGhpcy5fYWRkT3V0cHV0KGxpbmUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgdGhpcy50cnVuY2F0ZSA9IGxpbmUuaW5kZXhPZignLScpID09PSAwIHx8IGxpbmUuaW5kZXhPZignXycpID09PSAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEluIHNjcmlwdCBtb2RlLCBkZXBlbmRzIG9uIHR5cGUgb2YgdGFnXG4gICAgICBpZiAodGhpcy5tb2RlKSB7XG4gICAgICAgIC8vIElmICcvLycgaXMgZm91bmQgd2l0aG91dCBhIGxpbmUgYnJlYWssIGFkZCBhIGxpbmUgYnJlYWsuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgIGNhc2UgVGVtcGxhdGUubW9kZXMuRVZBTDpcbiAgICAgICAgY2FzZSBUZW1wbGF0ZS5tb2Rlcy5FU0NBUEVEOlxuICAgICAgICBjYXNlIFRlbXBsYXRlLm1vZGVzLlJBVzpcbiAgICAgICAgICBpZiAobGluZS5sYXN0SW5kZXhPZignLy8nKSA+IGxpbmUubGFzdEluZGV4T2YoJ1xcbicpKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAvLyBKdXN0IGV4ZWN1dGluZyBjb2RlXG4gICAgICAgIGNhc2UgVGVtcGxhdGUubW9kZXMuRVZBTDpcbiAgICAgICAgICB0aGlzLnNvdXJjZSArPSAnICAgIDsgJyArIGxpbmUgKyAnXFxuJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBFeGVjLCBlc2MsIGFuZCBvdXRwdXRcbiAgICAgICAgY2FzZSBUZW1wbGF0ZS5tb2Rlcy5FU0NBUEVEOlxuICAgICAgICAgIHRoaXMuc291cmNlICs9ICcgICAgOyBfX2FwcGVuZChlc2NhcGVGbignICsgc3RyaXBTZW1pKGxpbmUpICsgJykpJyArICdcXG4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEV4ZWMgYW5kIG91dHB1dFxuICAgICAgICBjYXNlIFRlbXBsYXRlLm1vZGVzLlJBVzpcbiAgICAgICAgICB0aGlzLnNvdXJjZSArPSAnICAgIDsgX19hcHBlbmQoJyArIHN0cmlwU2VtaShsaW5lKSArICcpJyArICdcXG4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRlbXBsYXRlLm1vZGVzLkNPTU1FTlQ6XG4gICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIExpdGVyYWwgPCUlIG1vZGUsIGFwcGVuZCBhcyByYXcgb3V0cHV0XG4gICAgICAgIGNhc2UgVGVtcGxhdGUubW9kZXMuTElURVJBTDpcbiAgICAgICAgICB0aGlzLl9hZGRPdXRwdXQobGluZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEluIHN0cmluZyBtb2RlLCBqdXN0IGFkZCB0aGUgb3V0cHV0XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkT3V0cHV0KGxpbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxmLm9wdHMuY29tcGlsZURlYnVnICYmIG5ld0xpbmVDb3VudCkge1xuICAgICAgdGhpcy5jdXJyZW50TGluZSArPSBuZXdMaW5lQ291bnQ7XG4gICAgICB0aGlzLnNvdXJjZSArPSAnICAgIDsgX19saW5lID0gJyArIHRoaXMuY3VycmVudExpbmUgKyAnXFxuJztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXNjYXBlIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgaW4gWE1MLlxuICpcbiAqIFRoaXMgaXMgc2ltcGx5IGFuIGV4cG9ydCBvZiB7QGxpbmsgbW9kdWxlOnV0aWxzLmVzY2FwZVhNTH0uXG4gKlxuICogSWYgYG1hcmt1cGAgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGUgZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrdXAgSW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgc3RyaW5nXG4gKiBAcHVibGljXG4gKiBAZnVuY1xuICogKi9cbmV4cG9ydHMuZXNjYXBlWE1MID0gdXRpbHMuZXNjYXBlWE1MO1xuXG4vKipcbiAqIEV4cHJlc3MuanMgc3VwcG9ydC5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgbW9kdWxlOmVqcy5yZW5kZXJGaWxlfSwgaW4gb3JkZXIgdG8gc3VwcG9ydFxuICogRXhwcmVzcy5qcyBvdXQtb2YtdGhlLWJveC5cbiAqXG4gKiBAZnVuY1xuICovXG5cbmV4cG9ydHMuX19leHByZXNzID0gZXhwb3J0cy5yZW5kZXJGaWxlO1xuXG4vKipcbiAqIFZlcnNpb24gb2YgRUpTLlxuICpcbiAqIEByZWFkb25seVxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLlZFUlNJT04gPSBfVkVSU0lPTl9TVFJJTkc7XG5cbi8qKlxuICogTmFtZSBmb3IgZGV0ZWN0aW9uIG9mIEVKUy5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5uYW1lID0gX05BTUU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LmVqcyA9IGV4cG9ydHM7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/ejs/lib/ejs.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/ejs/lib/utils.js":
/*!************************************************!*\
  !*** ../backend/node_modules/ejs/lib/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n/**\n * Private utility functions\n * @module utils\n * @private\n */\n\n\n\nvar regExpChars = /[|\\\\{}()[\\]^$+*?.]/g;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); };\n\n/**\n * Escape characters reserved in regular expressions.\n *\n * If `string` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} string Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\nexports.escapeRegExpChars = function (string) {\n  // istanbul ignore if\n  if (!string) {\n    return '';\n  }\n  return String(string).replace(regExpChars, '\\\\$&');\n};\n\nvar _ENCODE_HTML_RULES = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n};\nvar _MATCH_HTML = /[&<>'\"]/g;\n\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n}\n\n/**\n * Stringified version of constants used by {@link module:utils.escapeXML}.\n *\n * It is used in the process of generating {@link ClientFunction}s.\n *\n * @readonly\n * @type {String}\n */\n\nvar escapeFuncStr =\n  'var _ENCODE_HTML_RULES = {\\n'\n+ '      \"&\": \"&amp;\"\\n'\n+ '    , \"<\": \"&lt;\"\\n'\n+ '    , \">\": \"&gt;\"\\n'\n+ '    , \\'\"\\': \"&#34;\"\\n'\n+ '    , \"\\'\": \"&#39;\"\\n'\n+ '    }\\n'\n+ '  , _MATCH_HTML = /[&<>\\'\"]/g;\\n'\n+ 'function encode_char(c) {\\n'\n+ '  return _ENCODE_HTML_RULES[c] || c;\\n'\n+ '};\\n';\n\n/**\n * Escape characters reserved in XML.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @implements {EscapeCallback}\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\n\nexports.escapeXML = function (markup) {\n  return markup == undefined\n    ? ''\n    : String(markup)\n      .replace(_MATCH_HTML, encode_char);\n};\n\nfunction escapeXMLToString() {\n  return Function.prototype.toString.call(this) + ';\\n' + escapeFuncStr;\n}\n\ntry {\n  if (typeof Object.defineProperty === 'function') {\n  // If the Function prototype is frozen, the \"toString\" property is non-writable. This means that any objects which inherit this property\n  // cannot have the property changed using an assignment. If using strict mode, attempting that will cause an error. If not using strict\n  // mode, attempting that will be silently ignored.\n  // However, we can still explicitly shadow the prototype's \"toString\" property by defining a new \"toString\" property on this object.\n    Object.defineProperty(exports.escapeXML, 'toString', { value: escapeXMLToString });\n  } else {\n    // If Object.defineProperty() doesn't exist, attempt to shadow this property using the assignment operator.\n    exports.escapeXML.toString = escapeXMLToString;\n  }\n} catch (err) {\n  console.warn('Unable to set escapeXML.toString (is the Function prototype frozen?)');\n}\n\n/**\n * Naive copy of properties from one object to another.\n * Does not recurse into non-scalar properties\n * Does not check to see if the property has a value before copying\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopy = function (to, from) {\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var p in from) {\n      if (!hasOwn(from, p)) {\n        continue;\n      }\n      if (p === '__proto__' || p === 'constructor') {\n        continue;\n      }\n      to[p] = from[p];\n    }\n  }\n  return to;\n};\n\n/**\n * Naive copy of a list of key names, from one object to another.\n * Only copies property if it is actually defined\n * Does not recurse into non-scalar properties\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @param  {Array} list List of properties to copy\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopyFromList = function (to, from, list) {\n  list = list || [];\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var i = 0; i < list.length; i++) {\n      var p = list[i];\n      if (typeof from[p] != 'undefined') {\n        if (!hasOwn(from, p)) {\n          continue;\n        }\n        if (p === '__proto__' || p === 'constructor') {\n          continue;\n        }\n        to[p] = from[p];\n      }\n    }\n  }\n  return to;\n};\n\n/**\n * Simple in-process cache implementation. Does not implement limits of any\n * sort.\n *\n * @implements {Cache}\n * @static\n * @private\n */\nexports.cache = {\n  _data: {},\n  set: function (key, val) {\n    this._data[key] = val;\n  },\n  get: function (key) {\n    return this._data[key];\n  },\n  remove: function (key) {\n    delete this._data[key];\n  },\n  reset: function () {\n    this._data = {};\n  }\n};\n\n/**\n * Transforms hyphen case variable into camel case.\n *\n * @param {String} string Hyphen case string\n * @return {String} Camel case string\n * @static\n * @private\n */\nexports.hyphenToCamel = function (str) {\n  return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });\n};\n\n/**\n * Returns a null-prototype object in runtimes that support it\n *\n * @return {Object} Object, prototype will be set to null where possible\n * @static\n * @private\n */\nexports.createNullProtoObjWherePossible = (function () {\n  if (typeof Object.create == 'function') {\n    return function () {\n      return Object.create(null);\n    };\n  }\n  if (!({__proto__: null} instanceof Object)) {\n    return function () {\n      return {__proto__: null};\n    };\n  }\n  // Not possible, just pass through\n  return function () {\n    return {};\n  };\n})();\n\nexports.hasOwnOnlyObject = function (obj) {\n  var o = exports.createNullProtoObjWherePossible();\n  for (var p in obj) {\n    if (hasOwn(obj, p)) {\n      o[p] = obj[p];\n    }\n  }\n  return o;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvZWpzL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIseUJBQXlCO0FBQ3pCO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixRQUFRO0FBQ1IsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwwQkFBMEI7QUFDckYsSUFBSTtBQUNKO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbURBQW1ELGdDQUFnQztBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvZWpzL2xpYi91dGlscy5qcz81Y2FkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBFSlMgRW1iZWRkZWQgSmF2YVNjcmlwdCB0ZW1wbGF0ZXNcbiAqIENvcHlyaWdodCAyMTEyIE1hdHRoZXcgRWVybmlzc2UgKG1kZUBmbGVlZ2l4Lm9yZylcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiovXG5cbi8qKlxuICogUHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQG1vZHVsZSB1dGlsc1xuICogQHByaXZhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZWdFeHBDaGFycyA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzT3duID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7IHJldHVybiBoYXNPd25Qcm9wZXJ0eS5hcHBseShvYmosIFtrZXldKTsgfTtcblxuLyoqXG4gKiBFc2NhcGUgY2hhcmFjdGVycyByZXNlcnZlZCBpbiByZWd1bGFyIGV4cHJlc3Npb25zLlxuICpcbiAqIElmIGBzdHJpbmdgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhlIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIElucHV0IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHN0cmluZ1xuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lc2NhcGVSZWdFeHBDaGFycyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmICghc3RyaW5nKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlZ0V4cENoYXJzLCAnXFxcXCQmJyk7XG59O1xuXG52YXIgX0VOQ09ERV9IVE1MX1JVTEVTID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyYjMzQ7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG52YXIgX01BVENIX0hUTUwgPSAvWyY8PidcIl0vZztcblxuZnVuY3Rpb24gZW5jb2RlX2NoYXIoYykge1xuICByZXR1cm4gX0VOQ09ERV9IVE1MX1JVTEVTW2NdIHx8IGM7XG59XG5cbi8qKlxuICogU3RyaW5naWZpZWQgdmVyc2lvbiBvZiBjb25zdGFudHMgdXNlZCBieSB7QGxpbmsgbW9kdWxlOnV0aWxzLmVzY2FwZVhNTH0uXG4gKlxuICogSXQgaXMgdXNlZCBpbiB0aGUgcHJvY2VzcyBvZiBnZW5lcmF0aW5nIHtAbGluayBDbGllbnRGdW5jdGlvbn1zLlxuICpcbiAqIEByZWFkb25seVxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuXG52YXIgZXNjYXBlRnVuY1N0ciA9XG4gICd2YXIgX0VOQ09ERV9IVE1MX1JVTEVTID0ge1xcbidcbisgJyAgICAgIFwiJlwiOiBcIiZhbXA7XCJcXG4nXG4rICcgICAgLCBcIjxcIjogXCImbHQ7XCJcXG4nXG4rICcgICAgLCBcIj5cIjogXCImZ3Q7XCJcXG4nXG4rICcgICAgLCBcXCdcIlxcJzogXCImIzM0O1wiXFxuJ1xuKyAnICAgICwgXCJcXCdcIjogXCImIzM5O1wiXFxuJ1xuKyAnICAgIH1cXG4nXG4rICcgICwgX01BVENIX0hUTUwgPSAvWyY8PlxcJ1wiXS9nO1xcbidcbisgJ2Z1bmN0aW9uIGVuY29kZV9jaGFyKGMpIHtcXG4nXG4rICcgIHJldHVybiBfRU5DT0RFX0hUTUxfUlVMRVNbY10gfHwgYztcXG4nXG4rICd9O1xcbic7XG5cbi8qKlxuICogRXNjYXBlIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgaW4gWE1MLlxuICpcbiAqIElmIGBtYXJrdXBgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhlIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAaW1wbGVtZW50cyB7RXNjYXBlQ2FsbGJhY2t9XG4gKiBAcGFyYW0ge1N0cmluZ30gbWFya3VwIElucHV0IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHN0cmluZ1xuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVzY2FwZVhNTCA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cCA9PSB1bmRlZmluZWRcbiAgICA/ICcnXG4gICAgOiBTdHJpbmcobWFya3VwKVxuICAgICAgLnJlcGxhY2UoX01BVENIX0hUTUwsIGVuY29kZV9jaGFyKTtcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZVhNTFRvU3RyaW5nKCkge1xuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcykgKyAnO1xcbicgKyBlc2NhcGVGdW5jU3RyO1xufVxuXG50cnkge1xuICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBJZiB0aGUgRnVuY3Rpb24gcHJvdG90eXBlIGlzIGZyb3plbiwgdGhlIFwidG9TdHJpbmdcIiBwcm9wZXJ0eSBpcyBub24td3JpdGFibGUuIFRoaXMgbWVhbnMgdGhhdCBhbnkgb2JqZWN0cyB3aGljaCBpbmhlcml0IHRoaXMgcHJvcGVydHlcbiAgLy8gY2Fubm90IGhhdmUgdGhlIHByb3BlcnR5IGNoYW5nZWQgdXNpbmcgYW4gYXNzaWdubWVudC4gSWYgdXNpbmcgc3RyaWN0IG1vZGUsIGF0dGVtcHRpbmcgdGhhdCB3aWxsIGNhdXNlIGFuIGVycm9yLiBJZiBub3QgdXNpbmcgc3RyaWN0XG4gIC8vIG1vZGUsIGF0dGVtcHRpbmcgdGhhdCB3aWxsIGJlIHNpbGVudGx5IGlnbm9yZWQuXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbiBzdGlsbCBleHBsaWNpdGx5IHNoYWRvdyB0aGUgcHJvdG90eXBlJ3MgXCJ0b1N0cmluZ1wiIHByb3BlcnR5IGJ5IGRlZmluaW5nIGEgbmV3IFwidG9TdHJpbmdcIiBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5lc2NhcGVYTUwsICd0b1N0cmluZycsIHsgdmFsdWU6IGVzY2FwZVhNTFRvU3RyaW5nIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGRvZXNuJ3QgZXhpc3QsIGF0dGVtcHQgdG8gc2hhZG93IHRoaXMgcHJvcGVydHkgdXNpbmcgdGhlIGFzc2lnbm1lbnQgb3BlcmF0b3IuXG4gICAgZXhwb3J0cy5lc2NhcGVYTUwudG9TdHJpbmcgPSBlc2NhcGVYTUxUb1N0cmluZztcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHNldCBlc2NhcGVYTUwudG9TdHJpbmcgKGlzIHRoZSBGdW5jdGlvbiBwcm90b3R5cGUgZnJvemVuPyknKTtcbn1cblxuLyoqXG4gKiBOYWl2ZSBjb3B5IG9mIHByb3BlcnRpZXMgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIuXG4gKiBEb2VzIG5vdCByZWN1cnNlIGludG8gbm9uLXNjYWxhciBwcm9wZXJ0aWVzXG4gKiBEb2VzIG5vdCBjaGVjayB0byBzZWUgaWYgdGhlIHByb3BlcnR5IGhhcyBhIHZhbHVlIGJlZm9yZSBjb3B5aW5nXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0byAgIERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSBmcm9tIFNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuc2hhbGxvd0NvcHkgPSBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgZnJvbSA9IGZyb20gfHwge307XG4gIGlmICgodG8gIT09IG51bGwpICYmICh0byAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGZvciAodmFyIHAgaW4gZnJvbSkge1xuICAgICAgaWYgKCFoYXNPd24oZnJvbSwgcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gJ19fcHJvdG9fXycgfHwgcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRvW3BdID0gZnJvbVtwXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBOYWl2ZSBjb3B5IG9mIGEgbGlzdCBvZiBrZXkgbmFtZXMsIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICogT25seSBjb3BpZXMgcHJvcGVydHkgaWYgaXQgaXMgYWN0dWFsbHkgZGVmaW5lZFxuICogRG9lcyBub3QgcmVjdXJzZSBpbnRvIG5vbi1zY2FsYXIgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdG8gICBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gZnJvbSBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtBcnJheX0gbGlzdCBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgIERlc3RpbmF0aW9uIG9iamVjdFxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zaGFsbG93Q29weUZyb21MaXN0ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBsaXN0KSB7XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICBmcm9tID0gZnJvbSB8fCB7fTtcbiAgaWYgKCh0byAhPT0gbnVsbCkgJiYgKHRvICE9PSB1bmRlZmluZWQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IGxpc3RbaV07XG4gICAgICBpZiAodHlwZW9mIGZyb21bcF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFoYXNPd24oZnJvbSwgcCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gJ19fcHJvdG9fXycgfHwgcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRvW3BdID0gZnJvbVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBTaW1wbGUgaW4tcHJvY2VzcyBjYWNoZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBub3QgaW1wbGVtZW50IGxpbWl0cyBvZiBhbnlcbiAqIHNvcnQuXG4gKlxuICogQGltcGxlbWVudHMge0NhY2hlfVxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5jYWNoZSA9IHtcbiAgX2RhdGE6IHt9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIHRoaXMuX2RhdGFba2V5XSA9IHZhbDtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFba2V5XTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFba2V5XTtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kYXRhID0ge307XG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBoeXBoZW4gY2FzZSB2YXJpYWJsZSBpbnRvIGNhbWVsIGNhc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBIeXBoZW4gY2FzZSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gQ2FtZWwgY2FzZSBzdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuaHlwaGVuVG9DYW1lbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tW2Etel0vZywgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG51bGwtcHJvdG90eXBlIG9iamVjdCBpbiBydW50aW1lcyB0aGF0IHN1cHBvcnQgaXRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCwgcHJvdG90eXBlIHdpbGwgYmUgc2V0IHRvIG51bGwgd2hlcmUgcG9zc2libGVcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY3JlYXRlTnVsbFByb3RvT2JqV2hlcmVQb3NzaWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoe19fcHJvdG9fXzogbnVsbH0gaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7X19wcm90b19fOiBudWxsfTtcbiAgICB9O1xuICB9XG4gIC8vIE5vdCBwb3NzaWJsZSwganVzdCBwYXNzIHRocm91Z2hcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLmhhc093bk9ubHlPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBvID0gZXhwb3J0cy5jcmVhdGVOdWxsUHJvdG9PYmpXaGVyZVBvc3NpYmxlKCk7XG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bihvYmosIHApKSB7XG4gICAgICBvW3BdID0gb2JqW3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/ejs/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/ejs/package.json":
/*!************************************************!*\
  !*** ../backend/node_modules/ejs/package.json ***!
  \************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"3.1.10","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","bin":{"ejs":"./bin/cli.js"},"main":"./lib/ejs.js","jsdelivr":"ejs.min.js","unpkg":"ejs.min.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{"jake":"^10.8.5"},"devDependencies":{"browserify":"^16.5.1","eslint":"^6.8.0","git-directory-deploy":"^1.5.1","jsdoc":"^4.0.2","lru-cache":"^4.0.1","mocha":"^10.2.0","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"npx jake test"}}');

/***/ })

};
;