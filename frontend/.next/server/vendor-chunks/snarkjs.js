"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snarkjs";
exports.ids = ["vendor-chunks/snarkjs"];
exports.modules = {

/***/ "(rsc)/../backend/node_modules/snarkjs/main.js":
/*!***********************************************!*\
  !*** ../backend/node_modules/snarkjs/main.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fflonk: () => (/* reexport module object */ _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   groth16: () => (/* reexport module object */ _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   plonk: () => (/* reexport module object */ _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   powersOfTau: () => (/* reexport module object */ _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   r1cs: () => (/* reexport module object */ _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   wtns: () => (/* reexport module object */ _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   zKey: () => (/* reexport module object */ _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/groth16.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16.js\");\n/* harmony import */ var _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/powersoftau.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau.js\");\n/* harmony import */ var _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/r1cs.js */ \"(rsc)/../backend/node_modules/snarkjs/src/r1cs.js\");\n/* harmony import */ var _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/wtns.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns.js\");\n/* harmony import */ var _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/zkey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey.js\");\n/* harmony import */ var _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/plonk.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk.js\");\n/* harmony import */ var _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/fflonk.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9tYWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1E7QUFDZDtBQUNBO0FBQ0E7QUFDRTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9tYWluLmpzPzE0YTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogYXMgZ3JvdGgxNiBmcm9tIFwiLi9zcmMvZ3JvdGgxNi5qc1wiO1xuZXhwb3J0ICogYXMgcG93ZXJzT2ZUYXUgZnJvbSBcIi4vc3JjL3Bvd2Vyc29mdGF1LmpzXCI7XG5leHBvcnQgKiBhcyByMWNzIGZyb20gXCIuL3NyYy9yMWNzLmpzXCI7XG5leHBvcnQgKiBhcyB3dG5zIGZyb20gXCIuL3NyYy93dG5zLmpzXCI7XG5leHBvcnQgKiBhcyB6S2V5IGZyb20gXCIuL3NyYy96a2V5LmpzXCI7XG5leHBvcnQgKiBhcyBwbG9uayBmcm9tIFwiLi9zcmMvcGxvbmsuanNcIjtcbmV4cG9ydCAqIGFzIGZmbG9uayBmcm9tIFwiLi9zcmMvZmZsb25rLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/main.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/Keccak256Transcript.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/Keccak256Transcript.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak256Transcript: () => (/* binding */ Keccak256Transcript)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-sha3 */ \"(rsc)/../backend/node_modules/js-sha3/src/sha3.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { keccak256 } = js_sha3__WEBPACK_IMPORTED_MODULE_1__;\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(buffer)));\n        return this.Fr.e(value);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvS2VjY2FrMjU2VHJhbnNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvQztBQUNQO0FBQzdCLFFBQVEsWUFBWSxFQUFFLG9DQUFNOztBQUU1QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTs7QUFFQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBTTtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzPzRmOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtTY2FsYXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBqc1NoYTMgZnJvbSBcImpzLXNoYTNcIjtcbmNvbnN0IHsga2VjY2FrMjU2IH0gPSBqc1NoYTM7XG5cbmNvbnN0IFBPTFlOT01JQUwgPSAwO1xuY29uc3QgU0NBTEFSID0gMTtcblxuZXhwb3J0IGNsYXNzIEtlY2NhazI1NlRyYW5zY3JpcHQge1xuICAgIGNvbnN0cnVjdG9yKGN1cnZlKSB7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuXG4gICAgYWRkUG9sQ29tbWl0bWVudChwb2x5bm9taWFsQ29tbWl0bWVudCkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh7dHlwZTogUE9MWU5PTUlBTCwgZGF0YTogcG9seW5vbWlhbENvbW1pdG1lbnR9KTtcbiAgICB9XG5cbiAgICBhZGRTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHt0eXBlOiBTQ0FMQVIsIGRhdGE6IHNjYWxhcn0pO1xuICAgIH1cblxuICAgIGdldENoYWxsZW5nZSgpIHtcbiAgICAgICAgaWYoMCA9PT0gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2VjY2FrMjU2VHJhbnNjcmlwdDogTm8gZGF0YSB0byBnZW5lcmF0ZSBhIHRyYW5zY3JpcHRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgblBvbHlub21pYWxzID0gMDtcbiAgICAgICAgbGV0IG5TY2FsYXJzID0gMDtcblxuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChlbGVtZW50ID0+IFBPTFlOT01JQUwgPT09IGVsZW1lbnQudHlwZSA/IG5Qb2x5bm9taWFscysrIDogblNjYWxhcnMrKyk7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5TY2FsYXJzICogdGhpcy5Gci5uOCArIG5Qb2x5bm9taWFscyAqIHRoaXMuRzEuRi5uOCAqIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFBPTFlOT01JQUwgPT09IHRoaXMuZGF0YVtpXS50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5HMS50b1JwclVuY29tcHJlc3NlZChidWZmZXIsIG9mZnNldCwgdGhpcy5kYXRhW2ldLmRhdGEpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLkcxLkYubjggKiAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLkZyLnRvUnByQkUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuZGF0YVtpXS5kYXRhKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5Gci5uODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gU2NhbGFyLmZyb21ScHJCRShuZXcgVWludDhBcnJheShrZWNjYWsyNTYuYXJyYXlCdWZmZXIoYnVmZmVyKSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5Gci5lKHZhbHVlKTtcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/Keccak256Transcript.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/bigarray.js":
/*!*******************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/bigarray.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvYmlnYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2JpZ2FycmF5LmpzPzgzM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgU1VCQVJSQVlfU0laRSA9IDB4NDAwMDA7XG5cbmNvbnN0IEJpZ0FycmF5SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICBpZiAoIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmdldEVsZW1lbnQocHJvcCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gb2JqW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOYU4ocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouc2V0RWxlbWVudChwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgX0JpZ0FycmF5IHtcbiAgICBjb25zdHJ1Y3RvciAoaW5pdFNpemUpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBpbml0U2l6ZSB8fCAwO1xuICAgICAgICB0aGlzLmFyciA9IG5ldyBBcnJheShTVUJBUlJBWV9TSVpFKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8aW5pdFNpemU7IGkrPVNVQkFSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2kvU1VCQVJSQVlfU0laRV0gPSBuZXcgQXJyYXkoTWF0aC5taW4oU1VCQVJSQVlfU0laRSwgaW5pdFNpemUgLSBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2ggKCkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQgKHRoaXMubGVuZ3RoLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2xpY2UgKGYsIHQpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KHQtZik7XG4gICAgICAgIGZvciAobGV0IGk9ZjsgaTwgdDsgaSsrKSBhcnJbaS1mXSA9IHRoaXMuZ2V0RWxlbWVudChpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgZ2V0RWxlbWVudChpZHgpIHtcbiAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgY29uc3QgaWR4MSA9IE1hdGguZmxvb3IoaWR4IC8gU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIGNvbnN0IGlkeDIgPSBpZHggJSBTVUJBUlJBWV9TSVpFO1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJbaWR4MV0gPyB0aGlzLmFycltpZHgxXVtpZHgyXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0RWxlbWVudChpZHgsIHZhbHVlKSB7XG4gICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgIGNvbnN0IGlkeDEgPSBNYXRoLmZsb29yKGlkeCAvIFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICBpZiAoIXRoaXMuYXJyW2lkeDFdKSB7XG4gICAgICAgICAgICB0aGlzLmFycltpZHgxXSA9IG5ldyBBcnJheShTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHgyID0gaWR4ICUgU1VCQVJSQVlfU0laRTtcbiAgICAgICAgdGhpcy5hcnJbaWR4MV1baWR4Ml0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGlkeCA+PSB0aGlzLmxlbmd0aCkgdGhpcy5sZW5ndGggPSBpZHgrMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGNvbnN0IG5ld0EgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8dGhpcy5hcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFycltpXVtqXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QS5wdXNoKGkqU1VCQVJSQVlfU0laRStqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QTtcbiAgICB9XG59XG5cbmNsYXNzIEJpZ0FycmF5IHtcbiAgICBjb25zdHJ1Y3RvciggaW5pdFNpemUgKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyBfQmlnQXJyYXkoaW5pdFNpemUpO1xuICAgICAgICBjb25zdCBleHRPYmogPSBuZXcgUHJveHkob2JqLCBCaWdBcnJheUhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZXh0T2JqO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmlnQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/bigarray.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/curves.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/curves.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r) {\n    let curve;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bn128r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)();\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bls12381r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)();\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q) {\n    let curve;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bn128q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)();\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bls12381q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)();\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)();\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)();\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0U7O0FBRWhFLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVyQixrQkFBa0IsZ0RBQU07QUFDeEIsZUFBZSxnREFBTTs7QUFFZDtBQUNQO0FBQ0EsUUFBUSxnREFBTTtBQUNkLHNCQUFzQix3REFBVTtBQUNoQyxNQUFNLFNBQVMsZ0RBQU07QUFDckIsc0JBQXNCLDJEQUFhO0FBQ25DLE1BQU07QUFDTixnREFBZ0QsZ0RBQU0sYUFBYTtBQUNuRTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFFBQVEsZ0RBQU07QUFDZCxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFNLGFBQWE7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDLE1BQU07QUFDTixzQkFBc0IsMkRBQWE7QUFDbkMsTUFBTTtBQUNOLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzPzE4YWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NhbGFyLCBidWlsZEJuMTI4LCBidWlsZEJsczEyMzgxfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IGJsczEyMzgxciA9IFNjYWxhci5lKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3XCIpO1xuXG5jb25zdCBibHMxMjM4MXEgPSBTY2FsYXIuZShcIjFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYlwiLCAxNik7XG5jb25zdCBibjEyOHEgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4Njk2MzExMTU3Mjk3ODIzNjYyNjg5MDM3ODk0NjQ1MjI2MjA4NTgzXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUihyKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGlmIChTY2FsYXIuZXEociwgYm4xMjhyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShyLCBibHMxMjM4MXIpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtTY2FsYXIudG9TdHJpbmcocil9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVEocSkge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoU2NhbGFyLmVxKHEsIGJuMTI4cSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KCk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHEpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21OYW1lKG5hbWUpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgY29uc3Qgbm9ybU5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIGlmIChbXCJCTjEyOFwiLCBcIkJOMjU0XCIsIFwiQUxUQk4xMjhcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoKTtcbiAgICB9IGVsc2UgaWYgKFtcIkJMUzEyMzgxXCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobikge1xuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpLm1hdGNoKC9bQS1aYS16MC05XSsvZykuam9pbihcIlwiKTtcbiAgICB9XG5cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/curves.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_setup.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_setup.js\");\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_full_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_full_prove.js\");\n/* harmony import */ var _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fflonk_verify.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_verify.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n/* harmony import */ var _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_export_calldata.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_calldata.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFEO0FBQ0E7QUFDUztBQUNQO0FBQ2tDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmsuanM/NjU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHNldHVwIH0gZnJvbSBcIi4vZmZsb25rX3NldHVwLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb3ZlIH0gZnJvbSBcIi4vZmZsb25rX3Byb3ZlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZ1bGxQcm92ZSB9IGZyb20gXCIuL2ZmbG9ua19mdWxsX3Byb3ZlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcmlmeSB9IGZyb20gXCIuL2ZmbG9ua192ZXJpZnkuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlWZXJpZmllciB9IGZyb20gXCIuL2ZmbG9ua19leHBvcnRfc29saWRpdHlfdmVyaWZpZXIuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlDYWxsRGF0YSB9IGZyb20gXCIuL2ZmbG9ua19leHBvcnRfY2FsbGRhdGEuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_constants.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_constants.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ A),\n/* harmony export */   FF_T_POL_DEG_MIN: () => (/* binding */ FF_T_POL_DEG_MIN),\n/* harmony export */   ZKEY_FF_ADDITIONS_SECTION: () => (/* binding */ ZKEY_FF_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_FF_A_MAP_SECTION: () => (/* binding */ ZKEY_FF_A_MAP_SECTION),\n/* harmony export */   ZKEY_FF_B_MAP_SECTION: () => (/* binding */ ZKEY_FF_B_MAP_SECTION),\n/* harmony export */   ZKEY_FF_C0_SECTION: () => (/* binding */ ZKEY_FF_C0_SECTION),\n/* harmony export */   ZKEY_FF_C_MAP_SECTION: () => (/* binding */ ZKEY_FF_C_MAP_SECTION),\n/* harmony export */   ZKEY_FF_HEADER_SECTION: () => (/* binding */ ZKEY_FF_HEADER_SECTION),\n/* harmony export */   ZKEY_FF_LAGRANGE_SECTION: () => (/* binding */ ZKEY_FF_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_FF_NSECTIONS: () => (/* binding */ ZKEY_FF_NSECTIONS),\n/* harmony export */   ZKEY_FF_PTAU_SECTION: () => (/* binding */ ZKEY_FF_PTAU_SECTION),\n/* harmony export */   ZKEY_FF_QC_SECTION: () => (/* binding */ ZKEY_FF_QC_SECTION),\n/* harmony export */   ZKEY_FF_QL_SECTION: () => (/* binding */ ZKEY_FF_QL_SECTION),\n/* harmony export */   ZKEY_FF_QM_SECTION: () => (/* binding */ ZKEY_FF_QM_SECTION),\n/* harmony export */   ZKEY_FF_QO_SECTION: () => (/* binding */ ZKEY_FF_QO_SECTION),\n/* harmony export */   ZKEY_FF_QR_SECTION: () => (/* binding */ ZKEY_FF_QR_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA1_SECTION: () => (/* binding */ ZKEY_FF_SIGMA1_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA2_SECTION: () => (/* binding */ ZKEY_FF_SIGMA2_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA3_SECTION: () => (/* binding */ ZKEY_FF_SIGMA3_SECTION)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nconst A = 12;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19jb25zdGFudHMuanM/OWFmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGRmxvbmsgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgRkZfVF9QT0xfREVHX01JTiA9IDM7XG5cbi8vIEZGbG9uayBBXG5leHBvcnQgY29uc3QgQSA9IDEyO1xuXG4vLyBaS0VZIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfTlNFQ1RJT05TID0gMTc7XG5cbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OID0gMjtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OID0gMztcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04gPSA0O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQl9NQVBfU0VDVElPTiA9IDU7XG5leHBvcnQgY29uc3QgWktFWV9GRl9DX01BUF9TRUNUSU9OID0gNjtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FMX1NFQ1RJT04gPSA3O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUVJfU0VDVElPTiA9IDg7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RTV9TRUNUSU9OID0gOTtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FPX1NFQ1RJT04gPSAxMDtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FDX1NFQ1RJT04gPSAxMTtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OID0gMTI7XG5leHBvcnQgY29uc3QgWktFWV9GRl9TSUdNQTJfU0VDVElPTiA9IDEzO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT04gPSAxNDtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04gPSAxNTtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1BUQVVfU0VDVElPTiA9IDE2O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQzBfU0VDVElPTiA9IDE3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_constants.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_calldata.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_export_calldata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    const proofBuff = new Uint8Array(G1.F.n8 * 2 * 4 + Fr.n8 * 16);\n\n    G1.toRprUncompressed(proofBuff, 0, G1.e(proof.polynomials.C1));\n    G1.toRprUncompressed(proofBuff, G1.F.n8 * 2, G1.e(proof.polynomials.C2));\n    G1.toRprUncompressed(proofBuff, G1.F.n8 * 4, G1.e(proof.polynomials.W1));\n    G1.toRprUncompressed(proofBuff, G1.F.n8 * 6, G1.e(proof.polynomials.W2));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8, Fr.e(proof.evaluations.ql));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8, Fr.e(proof.evaluations.qr));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 2, Fr.e(proof.evaluations.qm));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 3, Fr.e(proof.evaluations.qo));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 4, Fr.e(proof.evaluations.qc));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 5, Fr.e(proof.evaluations.s1));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 6, Fr.e(proof.evaluations.s2));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 7, Fr.e(proof.evaluations.s3));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 8, Fr.e(proof.evaluations.a));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 9, Fr.e(proof.evaluations.b));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 10, Fr.e(proof.evaluations.c));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 11, Fr.e(proof.evaluations.z));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 12, Fr.e(proof.evaluations.zw));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 13, Fr.e(proof.evaluations.t1w));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 14, Fr.e(proof.evaluations.t2w));\n    Fr.toRprBE(proofBuff, G1.F.n8 * 8 + Fr.n8 * 15, Fr.e(proof.evaluations.inv));\n\n    const proofHex = Array.from(proofBuff).map(i2hex).join(\"\");\n\n    return `0x${proofHex},[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNWOztBQUVuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUyxJQUFJLE9BQU87QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfZXhwb3J0X2NhbGxkYXRhLmpzPzc4MGYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtnZXRDdXJ2ZUZyb21OYW1lfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZnVuY3Rpb24gaTJoZXgoaSkge1xuICAgIHJldHVybiAoXCIwXCIgKyBpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xufVxuXG5mdW5jdGlvbiBwMjU2KG4pIHtcbiAgICBsZXQgbnN0ciA9IG4udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChuc3RyLmxlbmd0aCA8IDY0KSBuc3RyID0gXCIwXCIgKyBuc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua0V4cG9ydENhbGxEYXRhKF9wdWIsIF9wcm9vZikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgaW5wdXRzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9PSBcIlwiKSBpbnB1dHMgPSBpbnB1dHMgKyBcIixcIjtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzICsgcDI1NihwdWJbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByb29mQnVmZiA9IG5ldyBVaW50OEFycmF5KEcxLkYubjggKiAyICogNCArIEZyLm44ICogMTYpO1xuXG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQocHJvb2ZCdWZmLCAwLCBHMS5lKHByb29mLnBvbHlub21pYWxzLkMxKSk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQocHJvb2ZCdWZmLCBHMS5GLm44ICogMiwgRzEuZShwcm9vZi5wb2x5bm9taWFscy5DMikpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHByb29mQnVmZiwgRzEuRi5uOCAqIDQsIEcxLmUocHJvb2YucG9seW5vbWlhbHMuVzEpKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZChwcm9vZkJ1ZmYsIEcxLkYubjggKiA2LCBHMS5lKHByb29mLnBvbHlub21pYWxzLlcyKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4LCBGci5lKHByb29mLmV2YWx1YXRpb25zLnFsKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4ICsgRnIubjgsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMucXIpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDIsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMucW0pKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDMsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMucW8pKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDQsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMucWMpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDUsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMuczEpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDYsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMuczIpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDcsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMuczMpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDgsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMuYSkpO1xuICAgIEZyLnRvUnByQkUocHJvb2ZCdWZmLCBHMS5GLm44ICogOCArIEZyLm44ICogOSwgRnIuZShwcm9vZi5ldmFsdWF0aW9ucy5iKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4ICsgRnIubjggKiAxMCwgRnIuZShwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4ICsgRnIubjggKiAxMSwgRnIuZShwcm9vZi5ldmFsdWF0aW9ucy56KSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4ICsgRnIubjggKiAxMiwgRnIuZShwcm9vZi5ldmFsdWF0aW9ucy56dykpO1xuICAgIEZyLnRvUnByQkUocHJvb2ZCdWZmLCBHMS5GLm44ICogOCArIEZyLm44ICogMTMsIEZyLmUocHJvb2YuZXZhbHVhdGlvbnMudDF3KSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjggKiA4ICsgRnIubjggKiAxNCwgRnIuZShwcm9vZi5ldmFsdWF0aW9ucy50MncpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCAqIDggKyBGci5uOCAqIDE1LCBGci5lKHByb29mLmV2YWx1YXRpb25zLmludikpO1xuXG4gICAgY29uc3QgcHJvb2ZIZXggPSBBcnJheS5mcm9tKHByb29mQnVmZikubWFwKGkyaGV4KS5qb2luKFwiXCIpO1xuXG4gICAgcmV0dXJuIGAweCR7cHJvb2ZIZXh9LFske2lucHV0c31dYDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_calldata.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js":
/*!******************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(rsc)/../backend/node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nconst {unstringifyBigInts, stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName)(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdUI7QUFDVjs7QUFFbkMsT0FBTyxzQ0FBc0MsRUFBRSwrQ0FBSzs7QUFFckM7QUFDZjs7QUFFQSx3QkFBd0IsNERBQWdCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsdUNBQVU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfZXhwb3J0X3NvbGlkaXR5X3ZlcmlmaWVyLmpzPzAxNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IGVqcyBmcm9tIFwiZWpzXCI7XG5pbXBvcnQge2dldEN1cnZlRnJvbU5hbWV9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzLCBzdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyKHZrLCB0ZW1wbGF0ZXMsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIEVYUE9SVCBTT0xJRElUWSBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHZrLmN1cnZlKTtcblxuICAgIC8vIFByZWNvbXB1dGUgdzNfMiwgdzRfMiBhbmQgdzRfM1xuICAgIGxldCB3MyA9IGZyb21Wa2V5KHZrLnczKTtcbiAgICB2ay53M18yID0gdG9Wa2V5KGN1cnZlLkZyLnNxdWFyZSh3MykpO1xuXG4gICAgbGV0IHc0ID0gZnJvbVZrZXkodmsudzQpO1xuICAgIHZrLnc0XzIgPSB0b1ZrZXkoY3VydmUuRnIuc3F1YXJlKHc0KSk7XG4gICAgdmsudzRfMyA9IHRvVmtleShjdXJ2ZS5Gci5tdWwoY3VydmUuRnIuc3F1YXJlKHc0KSwgdzQpKTtcblxuICAgIGxldCB3OCA9IGZyb21Wa2V5KHZrLnc4KTtcbiAgICBsZXQgYWNjID0gY3VydmUuRnIub25lO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgYWNjID0gY3VydmUuRnIubXVsKGFjYywgdzgpO1xuICAgICAgICB2a1tcInc4X1wiICsgaV0gPSB0b1ZrZXkoYWNjKTtcbiAgICB9XG5cbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbdmsucHJvdG9jb2xdO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgRVhQT1JUIFNPTElESVRZIFZFUklGSUVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIGVqcy5yZW5kZXIodGVtcGxhdGUsIHZrKTtcblxuICAgIGZ1bmN0aW9uIGZyb21Wa2V5KHN0cikge1xuICAgICAgICBjb25zdCB2YWwgPSB1bnN0cmluZ2lmeUJpZ0ludHMoc3RyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkZyLmZyb21PYmplY3QodmFsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1ZrZXkodmFsKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IGN1cnZlLkZyLnRvT2JqZWN0KHZhbCk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlCaWdJbnRzKHN0cik7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_full_prove.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_full_prove.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFilename, wtns);\n\n    // Compute the proof\n    return await (0,_fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFilename, wtns, logger);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2Z1bGxfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0s7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxVQUFVLDhEQUFjOztBQUV4QjtBQUNBLGlCQUFpQiw0REFBVztBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19mdWxsX3Byb3ZlLmpzP2EwOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBmZmxvbmtQcm92ZSBmcm9tIFwiLi9mZmxvbmtfcHJvdmUuanNcIjtcbmltcG9ydCB3dG5zX2NhbGN1bGF0ZSBmcm9tIFwiLi93dG5zX2NhbGN1bGF0ZS5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rRnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGVuYW1lLCB6a2V5RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7dHlwZTogXCJtZW1cIn07XG5cbiAgICAvLyBDb21wdXRlIHRoZSB3aXRuZXNzXG4gICAgYXdhaXQgd3Ruc19jYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlbmFtZSwgd3Rucyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcm9vZlxuICAgIHJldHVybiBhd2FpdCBmZmxvbmtQcm92ZSh6a2V5RmlsZW5hbWUsIHd0bnMsIGxvZ2dlcik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_full_prove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_prove.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_prove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkProve)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/../backend/node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proof.js */ \"(rsc)/../backend/node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { stringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections);\n\n    if (zkey.protocolId !== _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_7__.Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION}` +\n                `, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        for (let i = 0; i < 8; i++) {\n            toInverse[\"LiS0_\" + (i + 1)] = computeLiS0(i);\n        }\n\n        for (let i = 0; i < 4; i++) {\n            toInverse[\"LiS1_\" + (i + 1)] = computeLiS1(i);\n        }\n\n        for (let i = 0; i < 6; i++) {\n            toInverse[\"LiS2_\" + (i + 1)] = computeLiS2(i);\n        }\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n\n            w = Fr.mul(w, zkey.w);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            mulAccumulator = Fr.mul(mulAccumulator, element);\n        }\n        return Fr.inv(mulAccumulator);\n\n        function computeLiS0(i) {\n            // Compute L_i^{(S0)}(y)\n            let idx = i;\n            let den = Fr.one;\n            for (let j = 0; j < 7; j++) {\n                idx = (idx + 1) % 8;\n\n                den = Fr.mul(den, Fr.sub(roots.S0.h0w8[i], roots.S0.h0w8[idx]));\n            }\n            return den;\n        }\n\n        function computeLiS1(i) {\n            // Compute L_i^{(S1)}(y)\n            let idx = i;\n            let den = Fr.one;\n            for (let j = 0; j < 3; j++) {\n                idx = (idx + 1) % 4;\n\n                den = Fr.mul(den, Fr.sub(roots.S1.h1w4[i], roots.S1.h1w4[idx]));\n            }\n            return den;\n        }\n\n        function computeLiS2(i) {\n            // Compute L_i^{(S1)}(y)\n            let idx = i;\n            let den = Fr.one;\n            for (let j = 0; j < 5; j++) {\n                idx = (idx + 1) % 6;\n\n                const root1 = i < 3 ? roots.S2.h2w3[i] : roots.S2.h3w3[i - 3];\n                const root2 = idx < 3 ? roots.S2.h2w3[idx] : roots.S2.h3w3[idx - 3];\n                den = Fr.mul(den, Fr.sub(root1, root2));\n            }\n            return den;\n        }\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDQTtBQUNXO0FBQ0M7QUFpQjFCO0FBQ2dDO0FBQzVCO0FBQ3FCO0FBQ0U7QUFDQTs7QUFFMUQsUUFBUSxtQkFBbUIsRUFBRSwrQ0FBSzs7O0FBR25CO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsdUJBQXVCLHNEQUFvQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsdUJBQXVCLHNEQUFvQjs7QUFFM0MsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBOztBQUVBLFNBQVMsZ0RBQU07QUFDZjtBQUNBOztBQUVBO0FBQ0EsNERBQTRELFdBQVcsYUFBYSxjQUFjLElBQUksZ0JBQWdCO0FBQ3RIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsZ0JBQWdCO0FBQ3hELHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxhQUFhO0FBQ3JELHdDQUF3QyxrQkFBa0I7QUFDMUQsd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQXdCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBUzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRyxhQUFhLEdBQUc7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw0Q0FBSzs7QUFFekIsaURBQWlELDJFQUF5QixDQUFDO0FBQzNFOztBQUVBLGtEQUFrRCx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDLEdBQUcsd0VBQXNCLENBQUM7QUFDN0g7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQsZ0ZBQWdGLHdFQUFzQjtBQUN0RyxnRkFBZ0Ysd0VBQXNCO0FBQ3RHLGdGQUFnRix3RUFBc0I7O0FBRXRHO0FBQ0EsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7O0FBRXRELG9GQUFvRix3RUFBc0I7QUFDMUcsb0ZBQW9GLHdFQUFzQjtBQUMxRyxvRkFBb0Ysd0VBQXNCOztBQUUxRyxpREFBaUQsc0VBQW9CLENBQUM7QUFDdEUscUJBQXFCLG1EQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHNFQUFvQjs7QUFFMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDOztBQUVBO0FBQ0EsMkJBQTJCLGdEQUFNO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsNERBQXdCLHVCQUF1QiwyRUFBeUI7O0FBRTVHO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDLHVGQUF1RixFQUFFLEdBQUcsZ0JBQWdCOztBQUU1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVM7QUFDckMsNEJBQTRCLG1EQUFTO0FBQ3JDLDRCQUE0QixtREFBUzs7QUFFckM7QUFDQSxtQ0FBbUMsNERBQXdCLHVCQUF1Qix1RUFBcUI7QUFDdkcsbUNBQW1DLDREQUF3Qix1QkFBdUIsdUVBQXFCO0FBQ3ZHLG1DQUFtQyw0REFBd0IsdUJBQXVCLHVFQUFxQjs7QUFFdkc7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpRUFBVTtBQUM1QztBQUNBLGtDQUFrQyxpRUFBVTtBQUM1QztBQUNBLGtDQUFrQyxpRUFBVTs7QUFFNUM7QUFDQTtBQUNBLGtDQUFrQyxtRUFBVztBQUM3QztBQUNBLGtDQUFrQyxtRUFBVztBQUM3QztBQUNBLGtDQUFrQyxtRUFBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxvRUFBa0IsQ0FBQyxJQUFJLG9FQUFrQixDQUFDO0FBQ3RHLHFCQUFxQixvRUFBa0IsQ0FBQyxJQUFJLG9FQUFrQixDQUFDLElBQUksb0VBQWtCLENBQUM7QUFDdEY7QUFDQSxpQ0FBaUMsbUVBQVcsS0FBSyxtREFBUztBQUMxRCxpQ0FBaUMsbUVBQVcsS0FBSyxtREFBUztBQUMxRCxpQ0FBaUMsbUVBQVcsS0FBSyxtREFBUztBQUMxRCxpQ0FBaUMsbUVBQVcsS0FBSyxtREFBUztBQUMxRCxpQ0FBaUMsbUVBQVcsS0FBSyxtREFBUzs7QUFFMUQ7QUFDQSx3RkFBd0Ysb0VBQWtCO0FBQzFHLHdGQUF3RixvRUFBa0I7QUFDMUcsd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCO0FBQzFHLHdGQUF3RixvRUFBa0I7O0FBRTFHO0FBQ0EsOENBQThDLDREQUF3Qix1QkFBdUIsMEVBQXdCO0FBQ3JILHdDQUF3QyxtRUFBVzs7QUFFbkQ7QUFDQSw2QkFBNkIsbURBQVM7O0FBRXRDO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxrR0FBa0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQVU7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRkFBbUYseUJBQXlCLHdCQUF3Qix3QkFBd0I7QUFDNUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixvRUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQW1COztBQUVsRDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QixtREFBUztBQUN0Qyw2QkFBNkIsbURBQVM7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCwrRkFBK0YsRUFBRSxHQUFHLGdCQUFnQjtBQUNwSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGlFQUFVOztBQUU1QztBQUNBO0FBQ0Esa0NBQWtDLG1FQUFXOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsbURBQVM7QUFDdEMsOEJBQThCLG1EQUFTOztBQUV2QztBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxnR0FBZ0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFekg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQVU7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxpRUFBVTs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QixtREFBUztBQUN0Qyw4QkFBOEIsbURBQVM7O0FBRXZDO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JELGdHQUFnRyxFQUFFLEdBQUcsb0JBQW9COztBQUV6SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFVOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxpRUFBVTs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixvRUFBVztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3RUFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTOztBQUVyRDtBQUNBLGdGQUFnRixvRUFBa0I7QUFDbEcsZ0ZBQWdGLG9FQUFrQjtBQUNsRyxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7QUFDbEcsZ0ZBQWdGLG9FQUFrQjs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3RUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCxvRkFBb0Ysb0VBQWtCOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkdBQTZHLEdBQUc7QUFDaEg7QUFDQTtBQUNBLDZCQUE2QixpRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkdBQTZHLEdBQUc7QUFDaEg7QUFDQTtBQUNBLDZCQUE2QixpRUFBVTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkdBQTZHLEdBQUc7QUFDaEg7QUFDQTtBQUNBLDZCQUE2QixpRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpRUFBVTtBQUN0QztBQUNBOztBQUVBLHFCQUFxQixpRUFBVTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHdFQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixpRUFBVTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsdUJBQXVCO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsaUVBQVU7QUFDdEM7QUFDQTs7QUFFQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTs7QUFFQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsaUVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNFQUFzRSxHQUFHLFVBQVUsR0FBRyxhQUFhLEdBQUc7QUFDdEcsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzPzAxY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCB7IEJpZ0J1ZmZlciwgU2NhbGFyLCB1dGlscyB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IEZGTE9OS19QUk9UT0NPTF9JRCB9IGZyb20gXCIuL3prZXlfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICAgIFpLRVlfRkZfQV9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OLFxuICAgIFpLRVlfRkZfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0MwX1NFQ1RJT04sXG4gICAgWktFWV9GRl9DX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTixcbiAgICBaS0VZX0ZGX1BUQVVfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FDX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RTF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUU1fU0VDVElPTixcbiAgICBaS0VZX0ZGX1FPX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RUl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUExX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BM19TRUNUSU9OLFxufSBmcm9tIFwiLi9mZmxvbmtfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBLZWNjYWsyNTZUcmFuc2NyaXB0IH0gZnJvbSBcIi4vS2VjY2FrMjU2VHJhbnNjcmlwdC5qc1wiO1xuaW1wb3J0IHsgUHJvb2YgfSBmcm9tIFwiLi9wcm9vZi5qc1wiO1xuaW1wb3J0IHsgUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvcG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0IHsgRXZhbHVhdGlvbnMgfSBmcm9tIFwiLi9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzXCI7XG5pbXBvcnQgeyBDUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvY3BvbHlub21pYWwuanNcIjtcblxuY29uc3QgeyBzdHJpbmdpZnlCaWdJbnRzIH0gPSB1dGlscztcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtQcm92ZSh6a2V5RmlsZU5hbWUsIHdpdG5lc3NGaWxlTmFtZSwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgUFJPVkVSIFNUQVJURURcIik7XG5cbiAgICAvLyBSZWFkIHdpdG5lc3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFd0bnMsXG4gICAgICAgIHNlY3Rpb25zOiB3dG5zU2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHdpdG5lc3NGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDEgPDwgMjUsIDEgPDwgMjMpO1xuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHd0bnNTZWN0aW9ucyk7XG5cbiAgICAvL1JlYWQgemtleSBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgemtleSBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkWktleSxcbiAgICAgICAgc2VjdGlvbnM6IHprZXlTZWN0aW9uc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMiwgMSA8PCAyNSwgMSA8PCAyMyk7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgemtleVNlY3Rpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sSWQgIT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGZmbG9ua1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIVNjYWxhci5lcSh6a2V5LnIsIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPT0gemtleS5uVmFycyAtIHprZXkubkFkZGl0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2l0bmVzcyBsZW5ndGguIENpcmN1aXQ6ICR7emtleS5uVmFyc30sIHdpdG5lc3M6ICR7d3Rucy5uV2l0bmVzc30sICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzRnIgPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44ICogMjtcbiAgICBjb25zdCBzRG9tYWluID0gemtleS5kb21haW5TaXplICogc0ZyO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgUFJPVkUgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHt6a2V5LnBvd2VyfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBEb21haW4gc2l6ZTogICAke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFyczogICAgICAgICAgJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3prZXkublB1YmxpY31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ29uc3RyYWludHM6ICAgJHt6a2V5Lm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQWRkaXRpb25zOiAgICAgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICAvL1JlYWQgd2l0bmVzcyBkYXRhXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlIGRhdGFcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCB3dG5zU2VjdGlvbnMsIDIpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgLy8gRmlyc3QgZWxlbWVudCBpbiBwbG9uayBpcyBub3QgdXNlZCBhbmQgY2FuIGJlIGFueSB2YWx1ZS4gKEJ1dCBhbHdheXMgdGhlIHNhbWUpLlxuICAgIC8vIFdlIHNldCBpdCB0byB6ZXJvIHRvIGdvIGZhc3RlciBpbiB0aGUgZXhwb25lbnRpYXRpb25zLlxuICAgIGJ1ZmZXaXRuZXNzLnNldChGci56ZXJvLCAwKTtcbiAgICBjb25zdCBidWZmSW50ZXJuYWxXaXRuZXNzID0gbmV3IEJpZ0J1ZmZlcih6a2V5Lm5BZGRpdGlvbnMgKiBzRnIpO1xuXG4gICAgbGV0IGJ1ZmZlcnMgPSB7fTtcbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcblxuICAgIC8vIFRvIGRpdmlkZSBwcmltZSBmaWVsZHMgdGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gZm9yIGNvbXB1dGluZyBtb2R1bGFyIGludmVyc2VzIGlzIG5lZWRlZC5cbiAgICAvLyBOT1RFOiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIGNvbXB1dGUgMS9kZW5vbWluYXRvciBhbmQgdGhlbiBtdWx0aXBseSBpdCBieSB0aGUgbnVtZXJhdG9yLlxuICAgIC8vIFRoZSBFeHRlbmRlZCBFdWNsaWRlYW4gQWxnb3JpdGhtIGlzIGV4cGVuc2l2ZSBpbiB0ZXJtcyBvZiBjb21wdXRhdGlvbi5cbiAgICAvLyBGb3IgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIGRvIG1hbnkgbW9kdWxhciBpbnZlcnNlcywgdGhlcmUncyBhIHNpbXBsZSBtYXRoZW1hdGljYWwgdHJpY2tcbiAgICAvLyB0aGF0IGFsbG93cyB1cyB0byBjb21wdXRlIG1hbnkgaW52ZXJzZXMsIGNhbGxlZCBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvbi5cbiAgICAvLyBNb3JlIGluZm86IGh0dHBzOi8vdml0YWxpay5jYS9nZW5lcmFsLzIwMTgvMDcvMjEvc3RhcmtzX3BhcnRfMy5odG1sXG4gICAgLy8gTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb24gcmVkdWNlcyB0aGUgbiBpbnZlcnNlIGNvbXB1dGF0aW9ucyB0byBhIHNpbmdsZSBvbmVcbiAgICAvLyBUbyBzYXZlIHRoaXMgKHNpbmdsZSkgaW52ZXJzZSBjb21wdXRhdGlvbiBvbi1jaGFpbiwgd2lsbCBjb21wdXRlIGl0IGluIHByb3ZpbmcgdGltZSBhbmQgc2VuZCBpdCB0byB0aGUgdmVyaWZpZXIuXG4gICAgLy8gVGhlIHZlcmlmaWVyIHdpbGwgaGF2ZSB0byBjaGVjazpcbiAgICAvLyAxKSB0aGUgZGVub21pbmF0b3IgaXMgY29ycmVjdCBtdWx0aXBseWluZyBieSBoaW1zZWxmIG5vbi1pbnZlcnRlZCAtPiBhICogMS9hID09IDFcbiAgICAvLyAyKSBjb21wdXRlIHRoZSByZXN0IG9mIHRoZSBkZW5vbWluYXRvcnMgdXNpbmcgdGhlIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uXG4gICAgLy8gVGhlIGludmVyc2lvbnMgYXJlOlxuICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgOCBhbmQgOSBvZiB0aGUgdmVyaWZpZXIgdG8gbXVsdGlwbHkgYnkgMS9aX0goeGkpXG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCAxMCBhbmQgMTEgb2YgdGhlIHZlcmlmaWVyXG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gdGhlIHZlcmlmaWVyIHdoZW4gY29tcHV0aW5nIExfaV57UzF9KFgpIGFuZCBMX2lee1MyfShYKVxuICAgIC8vICAgwrcgTF9pIGk9MSB0byBudW0gcHVibGljIGlucHV0cywgbmVlZGVkIGluIHN0ZXAgNiBhbmQgNyBvZiB0aGUgdmVyaWZpZXIgdG8gY29tcHV0ZSBMXzEoeGkpIGFuZCBQSSh4aSlcbiAgICBsZXQgdG9JbnZlcnNlID0ge307XG5cbiAgICBsZXQgY2hhbGxlbmdlcyA9IHt9O1xuICAgIGxldCByb290cyA9IHt9O1xuXG4gICAgbGV0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9GRl9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgIGF3YWl0IGNhbGN1bGF0ZUFkZGl0aW9ucygpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9ucyAke1pLRVlfRkZfU0lHTUExX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTJfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BM19TRUNUSU9OfS4gU2lnbWExLCBTaWdtYTIgJiBTaWdtYSAzYCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBwb2x5bm9taWFscyBcIik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWExID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEyID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTFfU0VDVElPTl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTIuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEyX1NFQ1RJT05dWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEzLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BM19TRUNUSU9OXVswXS5wKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IFJlYWRpbmcgU2lnbWEgZXZhbHVhdGlvbnNcIik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWExID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlNpZ21hMS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUExX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlNpZ21hMi5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEyX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlNpZ21hMy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEzX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgIGNvbnN0IFBUYXUgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIDE2ICogc0cxKTtcbiAgICAvLyBkb21haW5TaXplICogOSArIDE4ID0gU1JTIGxlbmd0aCBpbiB0aGUgemtleSBzYXZlZCBpbiBzZXR1cCBwcm9jZXNzLlxuICAgIC8vIGl0IGNvcnJlc3BvbmRzIHRvIHRoZSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgLy8gbm90aWNlIHRoYXQgdGhlIHJlc2VydmVkIGJ1ZmZlcnMgc2l6ZSBpcyB6a2V5LmRvbWFpblNpemUgKiAxNiAqIHNHMSBiZWNhdXNlIGEgcG93ZXIgb2YgdHdvIGJ1ZmZlciBzaXplIGlzIG5lZWRlZFxuICAgIC8vIHRoZSByZW1haW5pbmcgYnVmZmVyIG5vdCBmaWxsZWQgZnJvbSBTUlMgYXJlIHNldCB0byAwXG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihQVGF1LCAwLCAoemtleS5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSwgemtleVNlY3Rpb25zW1pLRVlfRkZfUFRBVV9TRUNUSU9OXVswXS5wKTtcblxuICAgIC8vIFNUQVJUIEZGTE9OSyBQUk9WRVIgUFJPVE9DT0xcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgMS4gQ29tcHV0ZSBDMShYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJcIik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDFcIik7XG4gICAgYXdhaXQgcm91bmQxKCk7XG5cbiAgICBkZWxldGUgcG9seW5vbWlhbHMuVDA7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFMO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RUjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUU07XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFPO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RQztcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgMi4gQ29tcHV0ZSBDMihYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDJcIik7XG4gICAgYXdhaXQgcm91bmQyKCk7XG5cbiAgICBkZWxldGUgYnVmZmVycy5BO1xuICAgIGRlbGV0ZSBidWZmZXJzLkI7XG4gICAgZGVsZXRlIGJ1ZmZlcnMuQztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuQztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWExO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTI7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMubGFncmFuZ2UxO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5aO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAzLiBDb21wdXRlIG9wZW5pbmcgZXZhbHVhdGlvbnNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgM1wiKTtcbiAgICBhd2FpdCByb3VuZDMoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5BO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5CO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuVDI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWEyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFMO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RUjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUU07XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFDO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTztcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgNC4gQ29tcHV0ZSBXKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgNFwiKTtcbiAgICBhd2FpdCByb3VuZDQoKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgNS4gQ29tcHV0ZSBXJyhYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDVcIik7XG4gICAgYXdhaXQgcm91bmQ1KCk7XG5cbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzA7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUjE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlIyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5GO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5MO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aVDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuWlRTMjtcbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImludlwiLCBnZXRNb250Z29tZXJ5QmF0Y2hlZEludmVyc2UoKSk7XG5cbiAgICAvLyBQcmVwYXJlIHByb29mXG4gICAgbGV0IF9wcm9vZiA9IHByb29mLnRvT2JqZWN0UHJvb2YoKTtcbiAgICBfcHJvb2YucHJvdG9jb2wgPSBcImZmbG9ua1wiO1xuICAgIF9wcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG5cbiAgICAvLyBQcmVwYXJlIHB1YmxpYyBpbnB1dHNcbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgIGNvbnN0IHB1YiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKHB1YikpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFBST1ZFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb29mOiBzdHJpbmdpZnlCaWdJbnRzKF9wcm9vZiksXG4gICAgICAgIHB1YmxpY1NpZ25hbHM6IHN0cmluZ2lmeUJpZ0ludHMocHVibGljU2lnbmFscylcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQWRkaXRpb25zKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgYWRkaXRpb25zXCIpO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OKTtcblxuICAgICAgICAvLyBzaXplczogd2lyZUlkX3ggPSA0IGJ5dGVzICgzMiBiaXRzKSwgZmFjdG9yX3ggPSBmaWVsZCBzaXplIGJpdHNcbiAgICAgICAgLy8gQWRkaXRpb24gZm9ybTogd2lyZUlkX2Egd2lyZUlkX2IgZmFjdG9yX2EgZmFjdG9yX2IgKHNpemUgaXMgNCArIDQgKyBzRnIgKyBzRnIpXG4gICAgICAgIGNvbnN0IHNTdW0gPSA4ICsgc0ZyICogMjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkFkZGl0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgYWRkaXRpb24gJHtpfS8ke3prZXkubkFkZGl0aW9uc31gKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBhZGRpdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogc1N1bTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMSA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQyID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IxID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc0ZyO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMiA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd2l0bmVzcyB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczEgPSBnZXRXaXRuZXNzKHNpZ25hbElkMSk7XG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMiA9IGdldFdpdG5lc3Moc2lnbmFsSWQyKTtcblxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBGci5hZGQoRnIubXVsKGZhY3RvcjEsIHdpdG5lc3MxKSwgRnIubXVsKGZhY3RvcjIsIHdpdG5lc3MyKSk7XG5cbiAgICAgICAgICAgIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2V0KHJlc3VsdCwgc0ZyICogaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDMyKGIsIG8pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGIuc2xpY2UobywgbyArIDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3MoaWR4KSB7XG4gICAgICAgIGxldCBkaWZmID0gemtleS5uVmFycyAtIHprZXkubkFkZGl0aW9ucztcbiAgICAgICAgaWYgKGlkeCA8IGRpZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmV2l0bmVzcy5zbGljZShpZHggKiBzRnIsIGlkeCAqIHNGciArIHNGcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgemtleS5uVmFycykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGlkeCAtIGRpZmYpICogc0ZyO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZyLnplcm87XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQxKCkge1xuICAgICAgICAvLyBTVEVQIDEuMSAtIEdlbmVyYXRlIHJhbmRvbSBibGluZGluZyBzY2FsYXJzIChiXzEsIC4uLiwgYjkpIOKIiCBGXG4gICAgICAgIGNoYWxsZW5nZXMuYiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMuYltpXSA9IEZyLnJhbmRvbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCAxLjIgLSBDb21wdXRlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgd2lyZSBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVdpcmVQb2x5bm9taWFscygpO1xuXG4gICAgICAgIC8vIFNURVAgMS4zIC0gQ29tcHV0ZSB0aGUgcXVvdGllbnQgcG9seW5vbWlhbCBUMChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFQwIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVUMCgpO1xuXG4gICAgICAgIC8vIFNURVAgMS40IC0gQ29tcHV0ZSB0aGUgRkZULXN0eWxlIGNvbWJpbmF0aW9uIHBvbHlub21pYWwgQzEoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlQzEoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3Qgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtDMV1fMSlcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMSBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMxID0gYXdhaXQgcG9seW5vbWlhbHMuQzEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMxXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQzFcIiwgY29tbWl0QzEpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIGRhdGEgZnJvbSB6a2V5IGZpbGVcIik7XG4gICAgICAgICAgICAvLyBCdWlsZCBBLCBCIGFuZCBDIGV2YWx1YXRpb25zIGJ1ZmZlciBmcm9tIHprZXkgYW5kIHdpdG5lc3MgZmlsZXNcbiAgICAgICAgICAgIGJ1ZmZlcnMuQSA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBidWZmZXJzLkIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgYnVmZmVycy5DID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAgICAgLy8gUmVhZCB6a2V5IHNlY3Rpb25zIGFuZCBmaWxsIHRoZSBidWZmZXJzXG4gICAgICAgICAgICBjb25zdCBhTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9BX01BUF9TRUNUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGJNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04pO1xuICAgICAgICAgICAgY29uc3QgY01hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQ19NQVBfU0VDVElPTik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgYWxsIHdpdG5lc3MgZnJvbSBzaWduYWwgaWRzIGFuZCBzZXQgdGhlbSB0byBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQSB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRBID0gcmVhZFVJbnQzMihhTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkEuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRBKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBCIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEIgPSByZWFkVUludDMyKGJNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEIpLCBpX3NGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEMgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQyA9IHJlYWRVSW50MzIoY01hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5DLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQyksIGlfc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmxpbmQgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFscyBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoY2hhbGxlbmdlcy5iWzFdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5BLnNldChjaGFsbGVuZ2VzLmJbMl0sIHNEb21haW4gLSAzMik7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGNoYWxsZW5nZXMuYlszXSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoY2hhbGxlbmdlcy5iWzRdLCBzRG9tYWluIC0gMzIpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChjaGFsbGVuZ2VzLmJbNV0sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkMuc2V0KGNoYWxsZW5nZXMuYls2XSwgc0RvbWFpbiAtIDMyKTtcblxuICAgICAgICAgICAgYnVmZmVycy5BID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5BKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQiA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQik7XG4gICAgICAgICAgICBidWZmZXJzLkMgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkMpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKSBmcm9tIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEEgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkEgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEIgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkIgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkMgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBBIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkEgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5BLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBCIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkIgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5CLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLkMgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlc1xuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5DLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQwKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYMK3wrfCtyBSZWFkaW5nIHNlY3Rpb25zICR7WktFWV9GRl9RTF9TRUNUSU9OfSwgJHtaS0VZX0ZGX1FSX1NFQ1RJT059YCArXG4gICAgICAgICAgICAgICAgYCwgJHtaS0VZX0ZGX1FNX1NFQ1RJT059LCAke1pLRVlfRkZfUU9fU0VDVElPTn0sICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUSBzZWxlY3RvcnNgKTtcbiAgICAgICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgZXZhbHVhdGlvbnNcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFMID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFSID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFNID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFPID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlFDID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUUwuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FMX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUVIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FSX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU0uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FNX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU8uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FPX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUUMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FDX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBMYWdyYW5nZSBwb2x5bm9taWFscyAmIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgICAgICBjb25zdCBsYWdyYW5nZVBvbHlub21pYWxzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMubGFncmFuZ2UxID0gbmV3IEV2YWx1YXRpb25zKGxhZ3JhbmdlUG9seW5vbWlhbHMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgYnVmZmVycyBUMFxuICAgICAgICAgICAgYnVmZmVycy5UMCA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAgZXZhbHVhdGlvbnNcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICAgIFQwIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgcmVsYXRlZCBldmFsdWF0aW9ucyB0byBjb21wdXRlIGN1cnJlbnQgVDAgZXZhbHVhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcWwgPSBldmFsdWF0aW9ucy5RTC5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyID0gZXZhbHVhdGlvbnMuUVIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbSA9IGV2YWx1YXRpb25zLlFNLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcW8gPSBldmFsdWF0aW9ucy5RTy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFjID0gZXZhbHVhdGlvbnMuUUMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgY3VycmVudCBwdWJsaWMgaW5wdXRcbiAgICAgICAgICAgICAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgemtleS5uUHVibGljOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGogKiA1ICogemtleS5kb21haW5TaXplKSArIHprZXkuZG9tYWluU2l6ZSArIGk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbFBvbCA9IGV2YWx1YXRpb25zLmxhZ3JhbmdlMS5nZXRFdmFsdWF0aW9uKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFWYWwgPSBidWZmZXJzLkEuc2xpY2UoaiAqIHNGciwgKGogKyAxKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bChsUG9sLCBhVmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UMChYKSA9IFtxX0woWCnCt2EoWCkgKyBxX1IoWCnCt2IoWCkgKyBxX00oWCnCt2EoWCnCt2IoWCkgKyBxX08oWCnCt2MoWCkgKyBxX0MoWCkgKyBQSShYKV0gwrcgMS9aX0goWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQwKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAxIC0+IHFfTChYKcK3YShYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUxID0gRnIubXVsKGEsIHFsKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMiAtPiBxX1IoWCnCt2IoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMiA9IEZyLm11bChiLCBxcik7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDMgLT4gcV9NKFgpwrdhKFgpwrdiKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTMgPSBGci5tdWwoRnIubXVsKGEsIGIpLCBxbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDQgLT4gcV9PKFgpwrdjKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTQgPSBGci5tdWwoYywgcW8pO1xuXG4gICAgICAgICAgICAgICAgLy8gdDAgPSBleHByZXNzaW9ucyAxICsgZXhwcmVzc2lvbiAyICsgZXhwcmVzc2lvbiAzICsgZXhwcmVzc2lvbiA0ICsgcWMgKyBwaVxuICAgICAgICAgICAgICAgIGNvbnN0IHQwID0gRnIuYWRkKGUxLCBGci5hZGQoZTIsIEZyLmFkZChlMywgRnIuYWRkKGU0LCBGci5hZGQocWMsIHBpKSkpKSk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQwLnNldCh0MCwgaSAqIHNGcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiYnVmZmVyIFQwOiBcIiArIGJ1ZmZlcnMuVDAuYnl0ZUxlbmd0aCAvIHNGcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMChYKSBmcm9tIGJ1ZmZlcnMuVDBcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDAgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQwLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJUMCBsZW5ndGg6IFwiICsgcG9seW5vbWlhbHMuVDAubGVuZ3RoKCkpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJUMCBkZWdyZWU6IFwiICsgcG9seW5vbWlhbHMuVDAuZGVncmVlKCkpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDAgYnkgWl9IKFgpXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAgLyBaSFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQwLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMC5kZWdyZWUoKSA+PSAyICogemtleS5kb21haW5TaXplIC0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVDAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkIChkZWdyZWUgaXMgJHtwb2x5bm9taWFscy5UMC5kZWdyZWUoKX0gYW5kIG11c3QgYmUgbGVzcyB0aGFuICR7MiAqIHprZXkuZG9tYWluU2l6ZSArIDJ9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQwO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUMxKCkge1xuICAgICAgICAgICAgbGV0IEMxID0gbmV3IENQb2x5bm9taWFsKDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgwLCBwb2x5bm9taWFscy5BKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMSwgcG9seW5vbWlhbHMuQik7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDIsIHBvbHlub21pYWxzLkMpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgzLCBwb2x5bm9taWFscy5UMCk7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkMxID0gQzEuZ2V0UG9seW5vbWlhbCgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5DMS5kZWdyZWUoKSA+PSA4ICogemtleS5kb21haW5TaXplIC0gOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMigpIHtcbiAgICAgICAgLy8gU1RFUCAyLjEgLSBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhIGFuZCBnYW1tYSDiiIggRlxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlcyBiZXRhIGFuZCBnYW1tYVwiKTtcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcblxuICAgICAgICAvLyBBZGQgQzAgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuQzApO1xuXG4gICAgICAgIC8vIEFkZCBBIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGJ1ZmZlcnMuQS5zbGljZShpICogc0ZyLCBpICogc0ZyICsgc0ZyKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgQzEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDMVwiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGdhbW1hXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICAgICAgY2hhbGxlbmdlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSkpO1xuXG4gICAgICAgIC8vIFNURVAgMi4yIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBwb2x5bm9taWFsIHooWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjMgLSBDb21wdXRlIHF1b3RpZW50IHBvbHlub21pYWwgVDEoWCkgYW5kIFQyKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDEgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQxKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQyKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjQgLSBDb21wdXRlIHRoZSBGRlQtc3R5bGUgY29tYmluYXRpb24gcG9seW5vbWlhbCBDMihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVDMigpO1xuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtDMl1fMSlcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMiBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMyID0gYXdhaXQgcG9seW5vbWlhbHMuQzIubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMyXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQzJcIiwgY29tbWl0QzIpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGxldCBudW1BcnIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgZmlyc3QgdmFsdWVzIHRvIDFcbiAgICAgICAgICAgIG51bUFyci5zZXQoRnIub25lLCAwKTtcbiAgICAgICAgICAgIGRlbkFyci5zZXQoRnIub25lLCAwKTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBaIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgICAgICAgICAvLyBaKFgpIDo9IG51bUFyciAvIGRlbkFyclxuICAgICAgICAgICAgICAgIC8vIG51bUFyciA6PSAoYSArIGJldGHCt8+JICsgZ2FtbWEpKGIgKyBiZXRhwrfPicK3azEgKyBnYW1tYSkoYyArIGJldGHCt8+JwrdrMiArIGdhbW1hKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJldGF3ID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgdyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMSA9IGJ1ZmZlcnMuQS5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTEgPSBGci5hZGQobnVtMSwgYmV0YXcpO1xuICAgICAgICAgICAgICAgIG51bTEgPSBGci5hZGQobnVtMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMiA9IGJ1ZmZlcnMuQi5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTIgPSBGci5hZGQobnVtMiwgRnIubXVsKHprZXkuazEsIGJldGF3KSk7XG4gICAgICAgICAgICAgICAgbnVtMiA9IEZyLmFkZChudW0yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0zID0gYnVmZmVycy5DLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMyA9IEZyLmFkZChudW0zLCBGci5tdWwoemtleS5rMiwgYmV0YXcpKTtcbiAgICAgICAgICAgICAgICBudW0zID0gRnIuYWRkKG51bTMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IEZyLm11bChudW0xLCBGci5tdWwobnVtMiwgbnVtMykpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGVuQXJyIDo9IChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKVxuICAgICAgICAgICAgICAgIGxldCBkZW4xID0gYnVmZmVycy5BLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMSA9IEZyLmFkZChkZW4xLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4xID0gRnIuYWRkKGRlbjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbjIgPSBidWZmZXJzLkIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4yID0gRnIuYWRkKGRlbjIsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMi5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjIgPSBGci5hZGQoZGVuMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuMyA9IGJ1ZmZlcnMuQy5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjMgPSBGci5hZGQoZGVuMywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMyA9IEZyLmFkZChkZW4zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4gPSBGci5tdWwoZGVuMSwgRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgbnVtIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBudW1BcnJcbiAgICAgICAgICAgICAgICBudW0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIG51bSk7XG4gICAgICAgICAgICAgICAgbnVtQXJyLnNldChudW0sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IGRlbiB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gZGVuQXJyXG4gICAgICAgICAgICAgICAgZGVuID0gRnIubXVsKGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBkZW4pO1xuICAgICAgICAgICAgICAgIGRlbkFyci5zZXQoZGVuLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBvbWVnYVxuICAgICAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGRlbkFyciB0byBjb21wdXRlIGluIHRoZSBuZXh0IGNvbW1hbmQgdGhlXG4gICAgICAgICAgICAvLyBkaXZpc2lvbiBudW1BcnIvZGVuQXJyIGJ5IG11bHRpcGx5aW5nIG51bSDCtyAxL2RlbkFyclxuICAgICAgICAgICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IERvIGl0IGluIGFzc2VtYmx5IGFuZCBpbiBwYXJhbGxlbFxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgbnVtQXJyIMK3IGRlbkFyciB3aGVyZSBkZW5BcnIgd2FzIGludmVydGVkIGluIHRoZSBwcmV2aW91cyBjb21tYW5kXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcikpO1xuICAgICAgICAgICAgICAgIG51bUFyci5zZXQoeiwgaV9zRnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRnJvbSBub3cgb24gdGhlIHZhbHVlcyBzYXZlZCBvbiBudW1BcnIgd2lsbCBiZSBaKFgpIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVycy5aID0gbnVtQXJyO1xuXG4gICAgICAgICAgICBpZiAoIUZyLmVxKG51bUFyci5zbGljZSgwLCBzRnIpLCBGci5vbmUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29weSBjb25zdHJhaW50cyBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB6KFgpIGZyb20gYnVmZmVycy5aXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuWiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuWiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgeihYKSBwb2x5bm9taWFsXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5aID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuWiwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEJsaW5kIHooWCkgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlouYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYls5XSwgY2hhbGxlbmdlcy5iWzhdLCBjaGFsbGVuZ2VzLmJbN11dKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuWi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlo7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDEoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEgZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVDEgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiAyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDF6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogMik7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMSBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSAqIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYTIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYSkpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVDEoWCkgOj0gKHooWCkgLSAxKSDCtyBMXzEoWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQxKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgbGFncmFuZ2UxID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24oemtleS5kb21haW5TaXplICsgaSAqIDIpO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IEZyLm11bChGci5zdWIoeiwgRnIub25lKSwgbGFncmFuZ2UxKTtcbiAgICAgICAgICAgICAgICBsZXQgdDF6ID0gRnIubXVsKHpwLCBsYWdyYW5nZTEpO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMS5zZXQodDEsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDF6LnNldCh0MXosIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgb21lZ2EgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlciArIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxKFgpIGZyb20gYnVmZmVycy5UMVxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDEsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDEgYnkgWl9IKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5kaXZCeVplcm9maWVyKHprZXkuZG9tYWluU2l6ZSwgRnIub25lKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxeihYKSBmcm9tIGJ1ZmZlcnMuVDF6XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDF6IGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMXogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQxeiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5hZGQocG9seW5vbWlhbHMuVDF6KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuVDEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDE7XG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMXo7XG4gICAgICAgICAgICBkZWxldGUgcG9seW5vbWlhbHMuVDF6O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQyKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG4gICAgICAgICAgICBidWZmZXJzLlQyeiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICAgICAgbGV0IG9tZWdhID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKiA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgVDIgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhMiA9IEZyLnNxdWFyZShvbWVnYSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2FXID0gRnIubXVsKG9tZWdhLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYVcyID0gRnIuc3F1YXJlKG9tZWdhVyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBldmFsdWF0aW9ucy5CLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGV2YWx1YXRpb25zLkMuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpXID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKCh6a2V5LmRvbWFpblNpemUgKiA0ICsgNCArIGkpICUgKHprZXkuZG9tYWluU2l6ZSAqIDQpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYTIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYSkpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpXcCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgb21lZ2FXMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhVykpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWEyID0gZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWEzID0gZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUMihYKSA6PSBbIChhKFgpICsgYmV0YcK3WCArIGdhbW1hKShiKFgpICsgYmV0YcK3azHCt1ggKyBnYW1tYSkoYyhYKSArIGJldGHCt2sywrdYICsgZ2FtbWEpeihYKVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAtKGEoWCkgKyBiZXRhwrdzaWdtYTEoWCkgKyBnYW1tYSkoYihYKSArIGJldGHCt3NpZ21hMihYKSArIGdhbW1hKShjKFgpICsgYmV0YcK3c2lnbWEzKFgpICsgZ2FtbWEpeihYz4kpXSDCtyAxL1pfSChYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDIoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMSAtPiAoYShYKSArIGJldGHCt1ggKyBnYW1tYSkoYihYKSArIGJldGHCt2sxwrdYICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdrMsK3WCArIGdhbW1hKXooWClcbiAgICAgICAgICAgICAgICBjb25zdCBiZXRhWCA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIG9tZWdhKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMTEgPSBGci5hZGQoYSwgYmV0YVgpO1xuICAgICAgICAgICAgICAgIGUxMSA9IEZyLmFkZChlMTEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMiA9IEZyLmFkZChiLCBGci5tdWwoYmV0YVgsIHprZXkuazEpKTtcbiAgICAgICAgICAgICAgICBlMTIgPSBGci5hZGQoZTEyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMTMgPSBGci5hZGQoYywgRnIubXVsKGJldGFYLCB6a2V5LmsyKSk7XG4gICAgICAgICAgICAgICAgZTEzID0gRnIuYWRkKGUxMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMTEsIGUxMiksIGUxMyksIHopO1xuICAgICAgICAgICAgICAgIGxldCBlMXogPSBGci5tdWwoRnIubXVsKEZyLm11bChlMTEsIGUxMiksIGUxMyksIHpwKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBbZTEsIGUxel0gPSBNdWxaLm11bDQoZTExLCBlMTIsIGUxMywgeiwgYXAsIGJwLCBjcCwgenAsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDIgLT4gKGEoWCkgKyBiZXRhwrdzaWdtYTEoWCkgKyBnYW1tYSkoYihYKSArIGJldGHCt3NpZ21hMihYKSArIGdhbW1hKShjKFgpICsgYmV0YcK3c2lnbWEzKFgpICsgZ2FtbWEpeihYz4kpXG4gICAgICAgICAgICAgICAgbGV0IGUyMSA9IEZyLmFkZChhLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTEpKTtcbiAgICAgICAgICAgICAgICBlMjEgPSBGci5hZGQoZTIxLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMjIgPSBGci5hZGQoYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWEyKSk7XG4gICAgICAgICAgICAgICAgZTIyID0gRnIuYWRkKGUyMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIzID0gRnIuYWRkKGMsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMykpO1xuICAgICAgICAgICAgICAgIGUyMyA9IEZyLmFkZChlMjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyID0gRnIubXVsKEZyLm11bChGci5tdWwoZTIxLCBlMjIpLCBlMjMpLCB6Vyk7XG4gICAgICAgICAgICAgICAgbGV0IGUyeiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUyMSwgZTIyKSwgZTIzKSwgeldwKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBbZTIsIGUyel0gPSBNdWxaLm11bDQoZTIxLCBlMjIsIGUyMywgelcsIGFwLCBicCwgY3AsIHpXcCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgICAgIGxldCB0MiA9IEZyLnN1YihlMSwgZTIpO1xuICAgICAgICAgICAgICAgIGxldCB0MnogPSBGci5zdWIoZTF6LCBlMnopO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMi5zZXQodDIsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDJ6LnNldCh0MnosIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgb21lZ2EgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlciArIDJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQyKFgpIGZyb20gYnVmZmVycy5UMlxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDIsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDIgYnkgWl9IKFgpXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgLyBaSFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDJ6KFgpIGZyb20gYnVmZmVycy5UMnpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMnogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDJ6LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2x5bm9taWFsIFQyeiB0byBUMiB0byBnZXQgdGhlIGZpbmFsIHBvbHlub21pYWwgVDJcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyLmFkZChwb2x5bm9taWFscy5UMnopO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMi5kZWdyZWUoKSA+PSAzICogemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVDIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMjtcbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQyejtcbiAgICAgICAgICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMno7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlQzIoKSB7XG4gICAgICAgICAgICBsZXQgQzIgPSBuZXcgQ1BvbHlub21pYWwoMywgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLlopO1xuICAgICAgICAgICAgQzIuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5UMSk7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDIsIHBvbHlub21pYWxzLlQyKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIgPSBDMi5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMyLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHhpXCIpO1xuICAgICAgICAvLyBTVEVQIDMuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgeGkg4oiIIFNcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQzJcIikpO1xuXG4gICAgICAgIC8vIE9idGFpbiBhIHhpX3NlZWRlciBmcm9tIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIC8vIFRvIGZvcmNlIGgxXjQgPSB4aSwgaDJeMyA9IHhpIGFuZCBoXzNeMiA9IHhpz4lcbiAgICAgICAgLy8gd2UgY29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4xMiwgaDEgPSB4aV9zZWVkZXJeMywgaDIgPSB4aV9zZWVkZXJeNCBhbmQgaDMgPSB4aV9zZWVkZXJeNlxuICAgICAgICBjaGFsbGVuZ2VzLnhpU2VlZCA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGNvbnN0IHhpU2VlZDIgPSBGci5zcXVhcmUoY2hhbGxlbmdlcy54aVNlZWQpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgb21lZ2E4LCBvbWVnYTQgYW5kIG9tZWdhM1xuICAgICAgICByb290cy53OCA9IFtdO1xuICAgICAgICByb290cy53OFswXSA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLnc4W2ldID0gRnIubXVsKHJvb3RzLnc4W2kgLSAxXSwgemtleS53OCk7XG4gICAgICAgIH1cblxuICAgICAgICByb290cy53NCA9IFtdO1xuICAgICAgICByb290cy53NFswXSA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLnc0W2ldID0gRnIubXVsKHJvb3RzLnc0W2kgLSAxXSwgemtleS53NCk7XG4gICAgICAgIH1cblxuICAgICAgICByb290cy53MyA9IFtdO1xuICAgICAgICByb290cy53M1swXSA9IEZyLm9uZTtcbiAgICAgICAgcm9vdHMudzNbMV0gPSB6a2V5LnczO1xuICAgICAgICByb290cy53M1syXSA9IEZyLnNxdWFyZSh6a2V5LnczKTtcblxuICAgICAgICAvLyBDb21wdXRlIGgwID0geGlTZWVkZXJeM1xuICAgICAgICByb290cy5TMCA9IHt9O1xuICAgICAgICByb290cy5TMC5oMHc4ID0gW107XG4gICAgICAgIHJvb3RzLlMwLmgwdzhbMF0gPSBGci5tdWwoeGlTZWVkMiwgY2hhbGxlbmdlcy54aVNlZWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFtpXSA9IEZyLm11bChyb290cy5TMC5oMHc4WzBdLCByb290cy53OFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGgxID0geGlfc2VlZGVyXjZcbiAgICAgICAgcm9vdHMuUzEgPSB7fTtcbiAgICAgICAgcm9vdHMuUzEuaDF3NCA9IFtdO1xuICAgICAgICByb290cy5TMS5oMXc0WzBdID0gRnIuc3F1YXJlKHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMuUzEuaDF3NFtpXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCByb290cy53NFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGgyID0geGlfc2VlZGVyXjhcbiAgICAgICAgcm9vdHMuUzIgPSB7fTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3MyA9IFtdO1xuICAgICAgICByb290cy5TMi5oMnczWzBdID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHhpU2VlZDIpO1xuICAgICAgICByb290cy5TMi5oMnczWzFdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLnczWzFdKTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3M1syXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCByb290cy53M1syXSk7XG5cbiAgICAgICAgcm9vdHMuUzIuaDN3MyA9IFtdO1xuICAgICAgICAvLyBNdWx0aXBseSBoMyBieSB0aGlyZC1yb290LW9tZWdhIHRvIG9idGFpbiBoXzNeMyA9IHhpz4lcbiAgICAgICAgLy8gU28sIGgzID0geGlfc2VlZGVyXjggz4leezEvM31cbiAgICAgICAgcm9vdHMuUzIuaDN3M1swXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB6a2V5LndyKTtcbiAgICAgICAgcm9vdHMuUzIuaDN3M1sxXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCByb290cy53M1sxXSk7XG4gICAgICAgIHJvb3RzLlMyLmgzdzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgcm9vdHMudzNbMl0pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgeGkgPSB4aV9zZWVkZXJeMjRcbiAgICAgICAgY2hhbGxlbmdlcy54aSA9IEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1swXSksIHJvb3RzLlMyLmgydzNbMF0pO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueGk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSkpO1xuXG4gICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgcG9seW5vbWlhbHNcbiAgICAgICAgcG9seW5vbWlhbHMuUUwgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUVIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU0gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU8gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUUMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFMLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FMX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFSLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FSX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFNLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FNX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFPLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FPX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFDLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FDX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgICAgIC8vIFNURVAgMy4yIC0gQ29tcHV0ZSBvcGVuaW5nIGV2YWx1YXRpb25zIGFuZCBhZGQgdGhlbSB0byB0aGUgcHJvb2YgKHRoaXJkIG91dHB1dCBvZiB0aGUgcHJvdmVyKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxbFwiLCBwb2x5bm9taWFscy5RTC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxclwiLCBwb2x5bm9taWFscy5RUi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxbVwiLCBwb2x5bm9taWFscy5RTS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxb1wiLCBwb2x5bm9taWFscy5RTy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxY1wiLCBwb2x5bm9taWFscy5RQy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzMVwiLCBwb2x5bm9taWFscy5TaWdtYTEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczJcIiwgcG9seW5vbWlhbHMuU2lnbWEyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMzXCIsIHBvbHlub21pYWxzLlNpZ21hMy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJhXCIsIHBvbHlub21pYWxzLkEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiYlwiLCBwb2x5bm9taWFscy5CLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImNcIiwgcG9seW5vbWlhbHMuQy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ6XCIsIHBvbHlub21pYWxzLlouZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueGl3ID0gRnIubXVsKGNoYWxsZW5nZXMueGksIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiendcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwidDF3XCIsIHBvbHlub21pYWxzLlQxLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ0MndcIiwgcG9seW5vbWlhbHMuVDIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDQoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIGFscGhhXCIpO1xuICAgICAgICAvLyBTVEVQIDQuMSAtIENvbXB1dGUgY2hhbGxlbmdlIGFscGhhIOKIiCBGXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMueGlTZWVkKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFsXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFtXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFvXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFjXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMzXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiYlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJjXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInpcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiendcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwidDF3XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInQyd1wiKSk7XG4gICAgICAgIGNoYWxsZW5nZXMuYWxwaGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgICAgICAvLyBTVEVQIDQuMiAtIENvbXB1dGUgRihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyBDMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5DMCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDgpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5DMC5jb2VmLCAwLCBzRG9tYWluICogOCwgemtleVNlY3Rpb25zW1pLRVlfRkZfQzBfU0VDVElPTl1bMF0ucCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjAoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjEoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjIoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEYgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUYoKTtcblxuICAgICAgICAvLyBUaGUgZm91cnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbVzFdXzEpLCB3aGVyZSBXMTo9KGYvWl90KSh4KVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcxIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0VzEgPSBhd2FpdCBwb2x5bm9taWFscy5GLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXMVwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlcxXCIsIGNvbW1pdFcxKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUjAoKSB7XG4gICAgICAgICAgICAvLyBDT01QVVRFIFIwXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgUjAoWCkgZnJvbSA4IGV2YWx1YXRpb25zIHVzaW5nIGxhZ3JhbmdlIGludGVycG9sYXRpb24uIFIwKFgpIOKIiCBGX3s8OH1bWF1cbiAgICAgICAgICAgIC8vIFdlIGRlY2lkZSB0byB1c2UgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbnMgYmVjYXVzZSB0aGUgUjAgZGVncmVlIGlzIHZlcnkgc21hbGwgKGRlZyhSMCk9PT03KSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIGNvbXB1dGUgaXQgdXNpbmcgY3VycmVudCBpZmZ0IGltcGxlbWVudGF0aW9uIGJlY2F1c2UgdGhlIG9tZWdhIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlIwID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzRdLCByb290cy5TMC5oMHc4WzVdLCByb290cy5TMC5oMHc4WzZdLCByb290cy5TMC5oMHc4WzddXSxcbiAgICAgICAgICAgICAgICBbcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFswXSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzJdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFszXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNF0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzVdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs2XSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbN10pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIwKFgpIDwgOFxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIwLmRlZ3JlZSgpID4gNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIwIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMSgpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjFcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiBSMShYKSBmcm9tIDQgZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gUjEoWCkg4oiIIEZfezw0fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMSBkZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIxKT09PTMpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjEgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM11dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzBdKSwgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMl0pLCBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzNdKV0sIGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMShYKSA8IDRcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5SMS5kZWdyZWUoKSA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSMSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUjIoKSB7XG4gICAgICAgICAgICAvLyBDT01QVVRFIFIyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgcjIoWCkgZnJvbSA2IGV2YWx1YXRpb25zIHVzaW5nIGxhZ3JhbmdlIGludGVycG9sYXRpb24uIHIyKFgpIOKIiCBGX3s8Nn1bWF1cbiAgICAgICAgICAgIC8vIFdlIGRlY2lkZSB0byB1c2UgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbnMgYmVjYXVzZSB0aGUgUjIuZGVncmVlIGlzIHZlcnkgc21hbGwgKGRlZyhSMik9PT01KSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIGNvbXB1dGUgaXQgdXNpbmcgY3VycmVudCBpZmZ0IGltcGxlbWVudGF0aW9uIGJlY2F1c2UgdGhlIG9tZWdhIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlIyID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSxcbiAgICAgICAgICAgICAgICBbcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1swXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzJdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1swXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMV0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzJdKV0sIGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMihYKSA8IDZcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5SMi5kZWdyZWUoKSA+IDUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlRigpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBGIHBvbHlub21pYWxcIik7XG5cbiAgICAgICAgICAgIC8vIENPTVBVVEUgRihYKVxuICAgICAgICAgICAgcG9seW5vbWlhbHMuRiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzAsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5zdWIocG9seW5vbWlhbHMuUjApO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5kaXZCeVplcm9maWVyKDgsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgICAgICAgICBsZXQgZjIgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMxLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGYyLnN1Yihwb2x5bm9taWFscy5SMSk7XG4gICAgICAgICAgICBmMi5tdWxTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgICAgICBmMi5kaXZCeVplcm9maWVyKDQsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgICAgICAgICBsZXQgZjMgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMyLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGYzLnN1Yihwb2x5bm9taWFscy5SMik7XG4gICAgICAgICAgICBmMy5tdWxTY2FsYXIoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcbiAgICAgICAgICAgIGYzLmRpdkJ5WmVyb2ZpZXIoMywgY2hhbGxlbmdlcy54aSk7XG4gICAgICAgICAgICBmMy5kaXZCeVplcm9maWVyKDMsIGNoYWxsZW5nZXMueGl3KTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5hZGQoZjIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5hZGQoZjMpO1xuXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuRi5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplIC0gNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkYgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ1KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSB5XCIpO1xuXG4gICAgICAgIC8vIFNURVAgNS4xIC0gQ29tcHV0ZSByYW5kb20gZXZhbHVhdGlvbiBwb2ludCB5IOKIiCBGXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlcxXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy55KSk7XG5cbiAgICAgICAgLy8gU1RFUCA1LjIgLSBDb21wdXRlIEwoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBMIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVMKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaVFMyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaVFMyKCk7XG5cbiAgICAgICAgbGV0IFpUUzJZID0gcG9seW5vbWlhbHMuWlRTMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICBaVFMyWSA9IEZyLmludihaVFMyWSk7XG4gICAgICAgIHBvbHlub21pYWxzLkwubXVsU2NhbGFyKFpUUzJZKTtcblxuICAgICAgICBjb25zdCBwb2xEaXZpZGVuZCA9IFBvbHlub21pYWwuZnJvbUNvZWZmaWNpZW50c0FycmF5KFtGci5uZWcoY2hhbGxlbmdlcy55KSwgRnIub25lXSwgY3VydmUpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcnID0gTCAvIFpUUzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29uc3QgcG9sUmVtYWluZGVyID0gcG9seW5vbWlhbHMuTC5kaXZCeShwb2xEaXZpZGVuZCk7XG5cbiAgICAgICAgLy9DaGVjayBwb2xSZW1pbmRlciBkZWdyZWUgaXMgZXF1YWwgdG8gemVyb1xuICAgICAgICBpZiAocG9sUmVtYWluZGVyLmRlZ3JlZSgpID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWdyZWUgb2YgTChYKS8oWlRTMih5KShYLXkpKSByZW1haW5kZXIgaXMgJHtwb2xSZW1haW5kZXIuZGVncmVlKCl9IGFuZCBzaG91bGQgYmUgMGApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkwuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZ3JlZSBvZiBMKFgpLyhaVFMyKHkpKFgteSkpIGlzIG5vdCBjb3JyZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZpZnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbVzJdXzEpLCB3aGVyZSBXMjo9KGYvWl90KSh4KVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcnIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0VzIgPSBhd2FpdCBwb2x5bm9taWFscy5MLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXMlwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlcyXCIsIGNvbW1pdFcyKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlTCgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBMIHBvbHlub21pYWxcIik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMFkgPSBwb2x5bm9taWFscy5SMC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICAgICAgY29uc3QgZXZhbFIxWSA9IHBvbHlub21pYWxzLlIxLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBjb25zdCBldmFsUjJZID0gcG9seW5vbWlhbHMuUjIuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcblxuICAgICAgICAgICAgbGV0IG11bEwwID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwwID0gRnIubXVsKG11bEwwLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtdWxMMSA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMSA9IEZyLm11bChtdWxMMSwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXVsTDIgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczWzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDIgPSBGci5tdWwobXVsTDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDIgPSBGci5tdWwobXVsTDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgzdzNbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHByZUwwID0gRnIubXVsKG11bEwxLCBtdWxMMik7XG4gICAgICAgICAgICBsZXQgcHJlTDEgPSBGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgRnIubXVsKG11bEwwLCBtdWxMMikpO1xuICAgICAgICAgICAgbGV0IHByZUwyID0gRnIubXVsKEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSwgRnIubXVsKG11bEwwLCBtdWxMMSkpO1xuXG4gICAgICAgICAgICB0b0ludmVyc2VbXCJkZW5IMVwiXSA9IG11bEwxO1xuICAgICAgICAgICAgdG9JbnZlcnNlW1wiZGVuSDJcIl0gPSBtdWxMMjtcblxuICAgICAgICAgICAgLy8gQ09NUFVURSBMKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5MID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLnN1YlNjYWxhcihldmFsUjBZKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwubXVsU2NhbGFyKHByZUwwKTtcblxuICAgICAgICAgICAgbGV0IGwyID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBsMi5zdWJTY2FsYXIoZXZhbFIxWSk7XG4gICAgICAgICAgICBsMi5tdWxTY2FsYXIocHJlTDEpO1xuXG4gICAgICAgICAgICBsZXQgbDMgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMyLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGwzLnN1YlNjYWxhcihldmFsUjJZKTtcbiAgICAgICAgICAgIGwzLm11bFNjYWxhcihwcmVMMik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuYWRkKGwyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuYWRkKGwzKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaVCBwb2x5bm9taWFsXCIpO1xuICAgICAgICAgICAgYXdhaXQgY29tcHV0ZVpUKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV2YWxaVFkgPSBwb2x5bm9taWFscy5aVC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5tdWxTY2FsYXIoZXZhbFpUWSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLnN1Yihwb2x5bm9taWFscy5GKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuTC5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLkw7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWlQoKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aVCA9IFBvbHlub21pYWwuemVyb2ZpZXJQb2x5bm9taWFsKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFswXSwgcm9vdHMuUzAuaDB3OFsxXSwgcm9vdHMuUzAuaDB3OFsyXSwgcm9vdHMuUzAuaDB3OFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFs0XSwgcm9vdHMuUzAuaDB3OFs1XSwgcm9vdHMuUzAuaDB3OFs2XSwgcm9vdHMuUzAuaDB3OFs3XSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMuUzIuaDJ3M1sxXSwgcm9vdHMuUzIuaDJ3M1syXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDN3M1swXSwgcm9vdHMuUzIuaDN3M1sxXSwgcm9vdHMuUzIuaDN3M1syXV0sIGN1cnZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaVFMyKCkge1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuWlRTMiA9IFBvbHlub21pYWwuemVyb2ZpZXJQb2x5bm9taWFsKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSwgY3VydmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TW9udGdvbWVyeUJhdGNoZWRJbnZlcnNlKCkge1xuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDggYW5kIDkgb2YgdGhlIHZlcmlmaWVyIHRvIG11bHRpcGx5IGJ5IDEvWl9IKHhpKVxuICAgICAgICBsZXQgeGlOID0gY2hhbGxlbmdlcy54aTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LnBvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIHhpTiA9IEZyLnNxdWFyZSh4aU4pO1xuICAgICAgICB9XG4gICAgICAgIHRvSW52ZXJzZVtcInpoXCJdID0gRnIuc3ViKHhpTiwgRnIub25lKTtcblxuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAgICAgLy8gICAgIHRvSW52ZXJzZS5kZW5IMSAmIHRvSW52ZXJzZS5kZW5IMiAgLT4gQ29tcHV0ZWQgaW4gcm91bmQ1LCBjb21wdXRlTCgpXG5cbiAgICAgICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gdGhlIHZlcmlmaWVyIHdoZW4gY29tcHV0aW5nIExfaV57UzB9KFgpLCBMX2lee1MxfShYKSBhbmQgTF9pXntTMn0oWClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpUzBfXCIgKyAoaSArIDEpXSA9IGNvbXB1dGVMaVMwKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpUzFfXCIgKyAoaSArIDEpXSA9IGNvbXB1dGVMaVMxKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpUzJfXCIgKyAoaSArIDEpXSA9IGNvbXB1dGVMaVMyKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpX1wiICsgKGkgKyAxKV0gPSBGci5tdWwoRnIuZSh6a2V5LmRvbWFpblNpemUpLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIHprZXkudyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXVsQWNjdW11bGF0b3IgPSBGci5vbmU7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBPYmplY3QudmFsdWVzKHRvSW52ZXJzZSkpIHtcbiAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnIuaW52KG11bEFjY3VtdWxhdG9yKTtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMChpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIExfaV57KFMwKX0oeSlcbiAgICAgICAgICAgIGxldCBpZHggPSBpO1xuICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgODtcblxuICAgICAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW4sIEZyLnN1Yihyb290cy5TMC5oMHc4W2ldLCByb290cy5TMC5oMHc4W2lkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZW47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMShpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIExfaV57KFMxKX0oeSlcbiAgICAgICAgICAgIGxldCBpZHggPSBpO1xuICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgNDtcblxuICAgICAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW4sIEZyLnN1Yihyb290cy5TMS5oMXc0W2ldLCByb290cy5TMS5oMXc0W2lkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZW47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMihpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIExfaV57KFMxKX0oeSlcbiAgICAgICAgICAgIGxldCBpZHggPSBpO1xuICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgNjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3QxID0gaSA8IDMgPyByb290cy5TMi5oMnczW2ldIDogcm9vdHMuUzIuaDN3M1tpIC0gM107XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdDIgPSBpZHggPCAzID8gcm9vdHMuUzIuaDJ3M1tpZHhdIDogcm9vdHMuUzIuaDN3M1tpZHggLSAzXTtcbiAgICAgICAgICAgICAgICBkZW4gPSBGci5tdWwoZGVuLCBGci5zdWIocm9vdDEsIHJvb3QyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVuO1xuICAgICAgICB9XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_prove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_setup.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_setup.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/../backend/node_modules/snarkjs/src/bigarray.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plonk_equation.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_equation.js\");\n/* harmony import */ var _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./r1cs_constraint_processor.js */ \"(rsc)/../backend/node_modules/snarkjs/src/r1cs_constraint_processor.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 whe need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.FF_T_POL_DEG_MIN, (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push((0,_plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint)(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__.r1csConstraintProcessor(Fr, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkAdditionConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyFilename, \"zkey\", 1, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.FFLONK_PROTOCOL_ID);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION : 1 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION : _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__.CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.div(orderRsub1, ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3NldHVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDWTtBQUNpRTtBQUNsRjtBQUNnQjtBQUNWO0FBb0JOO0FBQzZDO0FBSy9DO0FBQzBDO0FBQ2pCO0FBQ0Y7QUFDSTtBQUNBOzs7QUFHekM7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0MsUUFBUSxnRUFBVztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTyxRQUFRLGlFQUFvQjs7QUFFOUM7QUFDQTtBQUNBLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsdUJBQXVCLG9EQUFVLHdCQUF3Qiw4Q0FBOEM7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsb0RBQVE7QUFDekMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQWdCLEVBQUUsOENBQUk7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxrQkFBa0I7QUFDMUQsd0NBQXdDLG9CQUFvQjtBQUM1RCx3Q0FBd0MsZUFBZTtBQUN2RCx3Q0FBd0MsaUJBQWlCO0FBQ3pELHdDQUF3Qyx3QkFBd0I7QUFDaEUsd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUMsa0NBQWtDLCtFQUEyQjtBQUM3RDs7QUFFQTtBQUNBLGtDQUFrQyxrRkFBdUIsS0FBSywyRUFBMkIsRUFBRSwyRUFBMkIsRUFBRSxpRkFBaUM7O0FBRXpKLDRCQUE0Qiw0REFBd0I7QUFDcEQ7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsK0RBQStELEVBQUUsR0FBRyxrQkFBa0I7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFhLDBCQUEwQixtRUFBaUI7O0FBRXJGLHVEQUF1RCxtRUFBbUIsQ0FBQztBQUMzRTs7QUFFQSx1REFBdUQsMkVBQXlCLENBQUM7QUFDakY7QUFDQTs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx3REFBd0Qsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDO0FBQ25JO0FBQ0E7O0FBRUEsdURBQXVELDBFQUF3QixDQUFDO0FBQ2hGO0FBQ0E7O0FBRUEsdURBQXVELHNFQUFvQixDQUFDO0FBQzVFO0FBQ0E7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFO0FBQ0E7O0FBRUEsdURBQXVELHdFQUFzQixDQUFDO0FBQzlFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsbUVBQW1CO0FBQzNELGdDQUFnQyxrRUFBa0I7QUFDbEQsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMkVBQXlCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDJCQUEyQjtBQUNuRCxxR0FBcUcsRUFBRSxHQUFHLHNCQUFzQjs7QUFFaEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQix3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0EscURBQXFELEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzNGOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUNuRjtBQUNBOztBQUVBLGtDQUFrQyxrRUFBVTtBQUM1QyxrQ0FBa0Msb0VBQVc7O0FBRTdDO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixtREFBUztBQUNuQyw2QkFBNkIsb0RBQVE7QUFDckMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJELEVBQUUsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUUsR0FBRyxlQUFlO0FBQzVIOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0Isd0NBQXdDLHdFQUFzQixhQUFhLHdFQUFzQixHQUFHLHdFQUFzQjs7QUFFMUg7QUFDQSxzQ0FBc0Msa0VBQVU7QUFDaEQsc0NBQXNDLG9FQUFXO0FBQ2pELGtCQUFrQixzRUFBaUI7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQixvRUFBZTs7QUFFakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMEVBQXdCOztBQUVoRTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDJCQUEyQixtREFBUztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsc0VBQW9COztBQUU1RDtBQUNBLG1CQUFtQixtREFBUztBQUM1Qjs7QUFFQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxzRUFBaUIsU0FBUyxvRUFBa0I7QUFDMUQ7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUIsU0FBUyx3RUFBc0I7O0FBRTlEO0FBQ0EsaUNBQWlDLGdEQUFNO0FBQ3ZDO0FBQ0EsY0FBYyxnRUFBVzs7QUFFekI7QUFDQSxpQ0FBaUMsZ0RBQU07QUFDdkM7QUFDQSxjQUFjLGdFQUFXOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxtREFBbUQsa0VBQVU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU0saUJBQWlCLGdEQUFNOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19zZXR1cC5qcz9lMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZFIxY3NGZH0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtjcmVhdGVCaW5GaWxlLCBlbmRXcml0ZVNlY3Rpb24sIHJlYWRCaW5GaWxlLCBzdGFydFdyaXRlU2VjdGlvbiwgd3JpdGVCaWdJbnQsfSBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHtsb2cyfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQge0JpZ0J1ZmZlciwgU2NhbGFyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmlnQXJyYXkgZnJvbSBcIi4vYmlnYXJyYXkuanNcIjtcbmltcG9ydCB7XG4gICAgWktFWV9GRl9IRUFERVJfU0VDVElPTixcbiAgICBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OLFxuICAgIFpLRVlfRkZfQV9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9DX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUUxfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FSX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RTV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUU9fU0VDVElPTixcbiAgICBaS0VZX0ZGX1FDX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTFfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUEzX1NFQ1RJT04sXG4gICAgWktFWV9GRl9MQUdSQU5HRV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUFRBVV9TRUNUSU9OLFxuICAgIEZGX1RfUE9MX0RFR19NSU4sXG4gICAgWktFWV9GRl9OU0VDVElPTlMsXG4gICAgWktFWV9GRl9DMF9TRUNUSU9OLFxufSBmcm9tIFwiLi9mZmxvbmtfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge0ZGTE9OS19QUk9UT0NPTF9JRCwgSEVBREVSX1pLRVlfU0VDVElPTn0gZnJvbSBcIi4vemtleV9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7XG4gICAgZ2V0RkZsb25rQWRkaXRpb25Db25zdHJhaW50LFxuICAgIGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludCxcbiAgICBnZXRGRmxvbmtNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnRcbn0gZnJvbSBcIi4vcGxvbmtfZXF1YXRpb24uanNcIjtcbmltcG9ydCB7cjFjc0NvbnN0cmFpbnRQcm9jZXNzb3J9IGZyb20gXCIuL3IxY3NfY29uc3RyYWludF9wcm9jZXNzb3IuanNcIjtcbmltcG9ydCB7UG9seW5vbWlhbH0gZnJvbSBcIi4vcG9seW5vbWlhbC9wb2x5bm9taWFsLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7RXZhbHVhdGlvbnN9IGZyb20gXCIuL3BvbHlub21pYWwvZXZhbHVhdGlvbnMuanNcIjtcbmltcG9ydCB7Q1BvbHlub21pYWx9IGZyb20gXCIuL3BvbHlub21pYWwvY3BvbHlub21pYWwuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtTZXR1cChyMWNzRmlsZW5hbWUsIHB0YXVGaWxlbmFtZSwgemtleUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBTRVRVUCBTVEFSVEVEXCIpO1xuXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJlYWQgUFRhdSBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgUFRhdSBmaWxlXCIpO1xuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogcFRhdVNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGlmICghcFRhdVNlY3Rpb25zWzEyXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlcnMgb2YgVGF1IGlzIG5vdCB3ZWxsIHByZXBhcmVkLiBTZWN0aW9uIDEyIG1pc3NpbmcuXCIpO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJ2ZSBkZWZpbmVkIGluIFBUYXVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gR2V0dGluZyBjdXJ2ZSBmcm9tIFBUYXUgc2V0dGluZ3NcIik7XG4gICAgY29uc3Qge2N1cnZlfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgcFRhdVNlY3Rpb25zKTtcblxuICAgIC8vIFJlYWQgcjFjcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgcjFjcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHIxY3NGaWxlbmFtZSwgXCJyMWNzXCIsIDEsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7bG9hZENvbnN0cmFpbnRzOiBmYWxzZSwgbG9hZEN1c3RvbUdhdGVzOiB0cnVlfSk7XG5cbiAgICAvLyBQb3RlbnRpYWwgZXJyb3IgY2hlY2tzXG4gICAgaWYgKHIxY3MucHJpbWUgIT09IGN1cnZlLnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicjFjcyBjdXJ2ZSBkb2VzIG5vdCBtYXRjaCBwb3dlcnMgb2YgdGF1IGNlcmVtb255IGN1cnZlXCIpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemF0aW9uc1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzRnIgPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44ICogMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44ICogMjtcblxuICAgIGxldCBwb2x5bm9taWFscyA9IHt9O1xuICAgIGxldCBldmFsdWF0aW9ucyA9IHt9O1xuICAgIGxldCBQVGF1O1xuXG4gICAgbGV0IHNldHRpbmdzID0ge1xuICAgICAgICBuVmFyczogcjFjcy5uVmFycyxcbiAgICAgICAgblB1YmxpYzogcjFjcy5uT3V0cHV0cyArIHIxY3MublB1YklucHV0c1xuICAgIH07XG5cbiAgICBjb25zdCBwbG9ua0NvbnN0cmFpbnRzID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgbGV0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5KCk7XG5cbiAgICAvLyBQcm9jZXNzIGNvbnN0cmFpbnRzIGluc2lkZSByMWNzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFByb2Nlc3NpbmcgRkZsb25rIGNvbnN0cmFpbnRzXCIpO1xuICAgIGF3YWl0IGNvbXB1dGVGRkNvbnN0cmFpbnRzKGN1cnZlLkZyLCByMWNzLCBsb2dnZXIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBBcyB0aGUgdCBwb2x5bm9taWFsIGlzIG4rNSB3aGUgbmVlZCBhdCBsZWFzdCBhIHBvd2VyIG9mIDRcbiAgICAvL1RPRE8gY2hlY2shISEhXG4gICAgLy8gTk9URSA6IHBsb25rQ29uc3RyYWludHMgKyAyID0gI2NvbnN0cmFpbnRzICsgYmxpbmRpbmcgY29lZmZpY2llbnRzIGZvciBlYWNoIHdpcmUgcG9seW5vbWlhbFxuICAgIHNldHRpbmdzLmNpclBvd2VyID0gTWF0aC5tYXgoRkZfVF9QT0xfREVHX01JTiwgbG9nMigocGxvbmtDb25zdHJhaW50cy5sZW5ndGggKyAyKSAtIDEpICsgMSk7XG4gICAgc2V0dGluZ3MuZG9tYWluU2l6ZSA9IDIgKiogc2V0dGluZ3MuY2lyUG93ZXI7XG5cbiAgICBpZiAocFRhdVNlY3Rpb25zWzJdWzBdLnNpemUgPCAoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3QgYmlnIGVub3VnaCBmb3IgdGhpcyBjaXJjdWl0IHNpemUuIFNlY3Rpb24gMiB0b28gc21hbGwuXCIpO1xuICAgIH1cbiAgICBpZiAocFRhdVNlY3Rpb25zWzNdWzBdLnNpemUgPCBzRzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3Qgd2VsbCBwcmVwYXJlZC4gU2VjdGlvbiAzIHRvbyBzbWFsbC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgU0VUVVAgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHtzZXR0aW5ncy5jaXJQb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHtzZXR0aW5ncy5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3NldHRpbmdzLm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3NldHRpbmdzLm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEFkZGl0aW9uczogICAgICR7cGxvbmtBZGRpdGlvbnMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBrMSBhbmQgazIgdG8gYmUgdXNlZCBpbiB0aGUgcGVybXV0YXRpb24gY2hlY2tzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyBrMSBhbmQgazJcIik7XG4gICAgY29uc3QgW2sxLCBrMl0gPSBjb21wdXRlSzFLMigpO1xuXG4gICAgLy8gQ29tcHV0ZSBvbWVnYSAzICh3MykgYW5kIG9tZWdhIDQgKHc0KSB0byBiZSB1c2VkIGluIHRoZSBwcm92ZXIgYW5kIHRoZSB2ZXJpZmllclxuICAgIC8vIHczXjMgPSAxIGFuZCAgdzReNCA9IDFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHczXCIpO1xuICAgIGNvbnN0IHczID0gY29tcHV0ZVczKCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3NFwiKTtcbiAgICBjb25zdCB3NCA9IGNvbXB1dGVXNCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzhcIik7XG4gICAgY29uc3QgdzggPSBjb21wdXRlVzgoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHdyXCIpO1xuICAgIGNvbnN0IHdyID0gZ2V0T21lZ2FDdWJpY1Jvb3Qoc2V0dGluZ3MuY2lyUG93ZXIsIGN1cnZlLkZyKTtcblxuICAgIC8vIFdyaXRlIG91dHB1dCB6a2V5IGZpbGVcbiAgICBhd2FpdCB3cml0ZVprZXlGaWxlKCk7XG5cbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlRkZDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG4gICAgICAgIC8vIEFkZCBwdWJsaWMgaW5wdXRzIGFuZCBvdXRwdXRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KGkgKyAxLCBGcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFsbCBjb25zdHJhaW50cyBmcm9tIHIxY3MgZmlsZVxuICAgICAgICBjb25zdCByMWNzUHJvY2Vzc29yID0gbmV3IHIxY3NDb25zdHJhaW50UHJvY2Vzc29yKEZyLCBnZXRGRmxvbmtDb25zdGFudENvbnN0cmFpbnQsIGdldEZGbG9ua0FkZGl0aW9uQ29uc3RyYWludCwgZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50LCBsb2dnZXIpO1xuXG4gICAgICAgIGNvbnN0IGJSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcbiAgICAgICAgbGV0IGJSMWNzUG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByMWNzLm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgcHJvY2Vzc2luZyByMWNzIGNvbnN0cmFpbnRzICR7aX0vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtjb25zdHJhaW50cywgYWRkaXRpb25zXSA9IHIxY3NQcm9jZXNzb3IucHJvY2Vzc1IxY3NDb25zdHJhaW50KHNldHRpbmdzLCAuLi5yZWFkQ29uc3RyYWludCgpKTtcblxuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKC4uLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHBsb25rQWRkaXRpb25zLnB1c2goLi4uYWRkaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRDb25zdHJhaW50KCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IFtdO1xuICAgICAgICAgICAgY1swXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1sxXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1syXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVUwzMiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArIDQpO1xuICAgICAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgbklkeCA9IGJ1ZmZVTDMyVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCArIHIxY3MubjgpICogbklkeCk7XG4gICAgICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbklkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSByMWNzLkYuZnJvbVJwckxFKGJ1ZmYsIGkgKiAoNCArIHIxY3MubjgpICsgNCk7XG4gICAgICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUZpbGUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBXcml0aW5nIHRoZSB6a2V5IGZpbGVcIik7XG4gICAgICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleUZpbGVuYW1lLCBcInprZXlcIiwgMSwgWktFWV9GRl9OU0VDVElPTlMsIDEgPDwgMjIsIDEgPDwgMjQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7SEVBREVSX1pLRVlfU0VDVElPTn0uIFprZXkgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlWmtleUhlYWRlcihmZFpLZXkpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUFkZGl0aW9ucyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BX01BUF9TRUNUSU9OfS4gQSBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9BX01BUF9TRUNUSU9OLCAwLCBcIkEgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9CX01BUF9TRUNUSU9OfS4gQiBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9CX01BUF9TRUNUSU9OLCAxLCBcIkIgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DX01BUF9TRUNUSU9OfS4gQyBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9DX01BUF9TRUNUSU9OLCAyLCBcIkMgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTF9TRUNUSU9OfS4gUUxgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTF9TRUNUSU9OLCAzLCBcIlFMXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RUl9TRUNUSU9OfS4gUVJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RUl9TRUNUSU9OLCA0LCBcIlFSXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTV9TRUNUSU9OfS4gUU1gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTV9TRUNUSU9OLCA1LCBcIlFNXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RT19TRUNUSU9OfS4gUU9gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RT19TRUNUSU9OLCA2LCBcIlFPXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUUNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RQ19TRUNUSU9OLCA3LCBcIlFDXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9ucyAke1pLRVlfRkZfU0lHTUExX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTJfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BM19TRUNUSU9OfS4gU2lnbWExLCBTaWdtYTIgJiBTaWdtYSAzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlU2lnbWEoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfTEFHUkFOR0VfU0VDVElPTn0uIExhZ3JhbmdlIFBvbHlub21pYWxzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUHRhdShmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DMF9TRUNUSU9OfS4gQzBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVDMChmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9IRUFERVJfU0VDVElPTn0uIEZGbG9uayBIZWFkZXJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlIGZpbmlzaGVkXCIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUhlYWRlcihmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBIRUFERVJfWktFWV9TRUNUSU9OKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoRkZMT05LX1BST1RPQ09MX0lEKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVBZGRpdGlvbnMoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gV3JpdHRlbiB2YWx1ZXMgYXJlIDIgKiAzMiBiaXQgaW50ZWdlcnMgKDIgKiA0IGJ5dGVzKSArIDIgZmllbGQgc2l6ZSB2YWx1ZXMgKCAyICogc0ZyIGJ5dGVzKVxuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCArIDIgKiBzRnIpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIEFkZGl0aW9uczogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYWRkaXRpb24gPSBwbG9ua0FkZGl0aW9uc1tpXTtcblxuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKDAsIGFkZGl0aW9uWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMig0LCBhZGRpdGlvblsxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgOCk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgOCArIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVdpdG5lc3NNYXAoZmRaS2V5LCBzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgd2l0bmVzcyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChmZFpLZXksIHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBRIGZyb20gcSBldmFsdWF0aW9uc1xuICAgICAgICBsZXQgUSA9IG5ldyBCaWdCdWZmZXIoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBRLnNldChwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdLCBpICogc0ZyKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhRLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnNbbmFtZV0gPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFsc1tuYW1lXSwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gV3JpdGUgUSBjb2VmZmljaWVudHMgYW5kIGV2YWx1YXRpb25zXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFsc1tuYW1lXS5jb2VmKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKGZkWktleSkge1xuICAgICAgICAvLyBDb21wdXRlIHNpZ21hXG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IEJpZ0J1ZmZlcihzRnIgKiBzZXR0aW5ncy5kb21haW5TaXplICogMyk7XG4gICAgICAgIGNvbnN0IGxhc3RTZWVuID0gbmV3IEJpZ0FycmF5KHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb3MgPSBuZXcgQmlnQXJyYXkoc2V0dGluZ3MublZhcnMpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVswXSwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzFdLCBzZXR0aW5ncy5kb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzJdLCBzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgc2V0dGluZ3MuZG9tYWluU2l6ZSAtIDIpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KHcsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChGci5tdWwodywgazEpLCAoc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsyKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSkgKiBzRnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbc2V0dGluZ3MuY2lyUG93ZXJdKTtcblxuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTE6ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MublZhcnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBvc1tpXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0U2VlbltpXSwgZmlyc3RQb3NbaV0gKiBzRnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIG5vdCB1c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIHNpZ21hIHBoYXNlMjogJHtpfS8ke3NldHRpbmdzLm5WYXJzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICAvLyBXcml0ZSBzaWdtYSBjb2VmZmljaWVudHMgYW5kIGV2YWx1YXRpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSWQgPSAwID09PSBpID8gWktFWV9GRl9TSUdNQTFfU0VDVElPTiA6IDEgPT09IGkgPyBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OIDogWktFWV9GRl9TSUdNQTNfU0VDVElPTjtcblxuICAgICAgICAgICAgbGV0IG5hbWUgPSBcIlNcIiArIChpICsgMSk7XG4gICAgICAgICAgICBwb2x5bm9taWFsc1tuYW1lXSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKHNpZ21hLnNsaWNlKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIgKiBpLCBzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogKGkgKyAxKSksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnNbbmFtZV0gPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFsc1tuYW1lXSwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25JZCk7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHNbbmFtZV0uY29lZik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnNbbmFtZV0uZXZhbCk7XG4gICAgICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2lnbWEoc2lnbmFsSWQsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0U2VlbltzaWduYWxJZF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc1tzaWduYWxJZF0gPSBpZHg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0U2VlbltzaWduYWxJZF0sIGlkeCAqIHNGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgIGlmIChpZHggPCBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IDIgKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0U2VlbltzaWduYWxJZF0gPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVMYWdyYW5nZVBvbHlub21pYWxzKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTik7XG5cbiAgICAgICAgY29uc3QgbCA9IE1hdGgubWF4KHNldHRpbmdzLm5QdWJsaWMsIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIpO1xuICAgICAgICAgICAgYnVmZi5zZXQoRnIub25lLCBpICogc0ZyKTtcblxuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChmZFpLZXksIGJ1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUHRhdShmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX1BUQVVfU0VDVElPTik7XG5cbiAgICAgICAgLy8gZG9tYWluU2l6ZSAqIDkgKyAxOCA9IG1heGltdW0gU1JTIGxlbmd0aCBuZWVkZWQsIHNwZWNpZmljYWxseSB0byBjb21taXQgQzJcbiAgICAgICAgUFRhdSA9IG5ldyBCaWdCdWZmZXIoKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxKTtcbiAgICAgICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihQVGF1LCAwLCAoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEsIHBUYXVTZWN0aW9uc1syXVswXS5wKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoUFRhdSk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQzAoZmRaS2V5KSB7XG4gICAgICAgIC8vIEMwKFgpIDo9IFFMKFheOCkgKyBYIMK3IFFSKFheOCkgKyBYXjIgwrcgUU8oWF44KSArIFheMyDCtyBRTShYXjgpICsgWF40IMK3IFFDKFheOClcbiAgICAgICAgLy8gICAgICAgICAgICArIFheNSDCtyBTSUdNQTEoWF44KSArIFheNiDCtyBTSUdNQTIoWF44KSArIFheNyDCtyBTSUdNQTMoWF44KVxuICAgICAgICBsZXQgQzAgPSBuZXcgQ1BvbHlub21pYWwoOCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuUUwpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlFSKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgyLCBwb2x5bm9taWFscy5RTyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMywgcG9seW5vbWlhbHMuUU0pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDQsIHBvbHlub21pYWxzLlFDKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg1LCBwb2x5bm9taWFscy5TMSk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNiwgcG9seW5vbWlhbHMuUzIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDcsIHBvbHlub21pYWxzLlMzKTtcblxuICAgICAgICBwb2x5bm9taWFscy5DMCA9IEMwLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkMwLmRlZ3JlZSgpID49IDggKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfQzBfU0VDVElPTik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFscy5DMC5jb2VmKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9IRUFERVJfU0VDVElPTik7XG5cbiAgICAgICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICAgICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsgMSkgKiA4O1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHEpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcblxuICAgICAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgICAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vcigoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKyAxKSAqIDg7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuXG4gICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiByMWNzIHZhcnNcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MublZhcnMpO1xuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyBwdWJsaWMgdmFycyA9IG91dHB1dHMgKyBwdWJsaWMgaW5wdXRzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5QdWJsaWMpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5kb21haW5TaXplKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtBZGRpdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50cy5sZW5ndGgpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMik7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHczKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHc0KTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHc4KTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHdyKTtcblxuICAgICAgICBsZXQgYlhfMjtcbiAgICAgICAgYlhfMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgcFRhdVNlY3Rpb25zWzNdWzBdLnAgKyBzRzIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYlhfMik7XG5cbiAgICAgICAgbGV0IGNvbW1pdEMwID0gYXdhaXQgcG9seW5vbWlhbHMuQzAubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMwXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoY29tbWl0QzApO1xuXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUDQoZmRaS2V5LCBidWZmKSB7XG4gICAgICAgIGNvbnN0IFtjb2VmZmljaWVudHMsIGV2YWx1YXRpb25zNF0gPSBhd2FpdCBQb2x5bm9taWFsLnRvNFQoYnVmZiwgc2V0dGluZ3MuZG9tYWluU2l6ZSwgW10sIEZyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvZWZmaWNpZW50cyk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShldmFsdWF0aW9uczQpO1xuXG4gICAgICAgIHJldHVybiBbY29lZmZpY2llbnRzLCBldmFsdWF0aW9uczRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVLMUsyKCkge1xuICAgICAgICBsZXQgazEgPSBGci50d287XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsxLCBbXSwgc2V0dGluZ3MuY2lyUG93ZXIpKSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIGxldCBrMiA9IEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazIsIFtrMV0sIHNldHRpbmdzLmNpclBvd2VyKSkgRnIuYWRkKGsyLCBGci5vbmUpO1xuICAgICAgICByZXR1cm4gW2sxLCBrMl07XG5cbiAgICAgICAgZnVuY3Rpb24gaXNJbmNsdWRlZChrLCBrQXJyLCBwb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpblNpemUgPSAyICoqIHBvdztcbiAgICAgICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga0Fyci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgRnIubXVsKGtBcnJbal0sIHcpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1twb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXMygpIHtcbiAgICAgICAgbGV0IGdlbmVyYXRvciA9IEZyLmUoMzE2MjQpO1xuXG4gICAgICAgIC8vIEV4cG9uZW50IGlzIG9yZGVyKHIgLSAxKSAvIDNcbiAgICAgICAgbGV0IG9yZGVyUnN1YjEgPSAzNjQ4MDQwNDc4NjM5ODc5MjAzNzA3NzM0MjkwODc2MjEyNTE0NzU4MDYwNzMzNDAyNjcyMzkwNjE2MzY3MzY0NDI5MzAxNDE1OTM2bjtcbiAgICAgICAgbGV0IGV4cG9uZW50ID0gU2NhbGFyLmRpdihvcmRlclJzdWIxLCBTY2FsYXIuZSgzKSk7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChnZW5lcmF0b3IsIGV4cG9uZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzQoKSB7XG4gICAgICAgIHJldHVybiBGci53WzJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXOCgpIHtcbiAgICAgICAgcmV0dXJuIEZyLndbM107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T21lZ2FDdWJpY1Jvb3QocG93ZXIsIEZyKSB7XG4gICAgICAgIC8vIEhhcmRjb3JkZWQgM3RoLXJvb3Qgb2YgRnIud1syOF1cbiAgICAgICAgY29uc3QgZmlyc3RSb290ID0gRnIuZSg0Njc3OTkxNjU4ODYwNjk2MTAwMzYwNDY4NjY3OTkyNjQwMjY0ODEzNDQyOTkwNzkwMTE3NjIwMjY3NzQ1MzM3NzQzNDU5ODgwODBuKTtcblxuICAgICAgICByZXR1cm4gRnIuZXhwKGZpcnN0Um9vdCwgMiAqKiAoMjggLSBwb3dlcikpO1xuICAgIH1cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_setup.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/fflonk_verify.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/fflonk_verify.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proof.js */ \"(rsc)/../backend/node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/../backend/node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new _proof_js__WEBPACK_IMPORTED_MODULE_2__.Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        logger.error(\"Proof is not well constructed\");\n        return false;\n    }\n\n    // TODO\n    // STEP 2 - Validate that all evaluations  F\n\n    // TODO\n    // STEP 3 - Validate that w_i  F for i  [l]\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__.Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing C0(h_0_8^i) values\");\n\n    let c0Values = [];\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        c0Values[i] = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0Values[i] = Fr.add(c0Values[i], Fr.mul(proof.evaluations.s3, coefValues[7]));\n    }\n\n    // Interpolate a polynomial with the points computed previously\n    const R0 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_4__.Polynomial.lagrangePolynomialInterpolation(\n        [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n            roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n        c0Values, curve);\n\n    // Check the degree of r1(X) < 4\n    if (R0.degree() > 7) {\n        throw new Error(\"R0 Polynomial is not well calculated\");\n    }\n\n    // Evaluate the polynomial in challenges.y\n    if (logger) logger.info(\" Computing evaluation r0(y)\");\n    return R0.evaluate(challenges.y);\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let c1Values = [];\n    for (let i = 0; i < 4; i++) {\n        c1Values[i] = proof.evaluations.a;\n        c1Values[i] = Fr.add(c1Values[i], Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1Values[i] = Fr.add(c1Values[i], Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1Values[i] = Fr.add(c1Values[i], Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n    }\n\n    // Interpolate a polynomial with the points computed previously\n    const R1 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_4__.Polynomial.lagrangePolynomialInterpolation(\n        [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n        c1Values, curve);\n\n    // Check the degree of r1(X) < 4\n    if (R1.degree() > 3) {\n        throw new Error(\"R1 Polynomial is not well calculated\");\n    }\n\n    // Evaluate the polynomial in challenges.y\n    if (logger) logger.info(\" Computing evaluation r1(y)\");\n    return R1.evaluate(challenges.y);\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let c2Values = [];\n    for (let i = 0; i < 3; i++) {\n        c2Values[i] = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2Values[i] = Fr.add(c2Values[i], Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        c2Values[i + 3] = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2Values[i + 3] = Fr.add(c2Values[i + 3], Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n    }\n\n    // Interpolate a polynomial with the points computed previously\n    if (logger) logger.info(\" Computing r2(xi)\");\n    const R2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_4__.Polynomial.lagrangePolynomialInterpolation(\n        [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n            roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n        c2Values, curve);\n\n    // Check the degree of r2(X) < 6\n    if (R2.degree() > 5) {\n        throw new Error(\"R2 Polynomial is not well calculated\");\n    }\n\n    // Evaluate the polynomial in challenges.y\n    if (logger) logger.info(\" Computing evaluation r2(y)\");\n    return R2.evaluate(challenges.y);\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVzQztBQUNVO0FBQ2I7QUFDNEI7QUFDUDs7QUFFeEQsUUFBUSxxQkFBcUIsRUFBRSwrQ0FBSzs7QUFFckI7QUFDZjs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DOztBQUVBOztBQUVBLHNCQUFzQiw0Q0FBSztBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsU0FBUztBQUNqRCx3Q0FBd0MsY0FBYztBQUN0RCx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQSwyQ0FBMkMsR0FBRztBQUM5QztBQUNBOztBQUVBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQW1COztBQUU5QztBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtREFBUztBQUNoQyxxQkFBcUIsbURBQVM7O0FBRTlCO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxJQUFJOztBQUV0QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUVBQVU7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLElBQUk7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCLDBCQUEwQixJQUFJO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxpRUFBVTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLElBQUksOEJBQThCLElBQUksS0FBSyxJQUFJO0FBQ2pGLGFBQWEsUUFBUSx1Q0FBdUM7QUFDNUQsMEJBQTBCLElBQUk7QUFDOUIsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUVBQVU7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcz9hMmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7IEJpZ0J1ZmZlciwgdXRpbHMgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyBQcm9vZiB9IGZyb20gXCIuL3Byb29mLmpzXCI7XG5pbXBvcnQgeyBLZWNjYWsyNTZUcmFuc2NyaXB0IH0gZnJvbSBcIi4vS2VjY2FrMjU2VHJhbnNjcmlwdC5qc1wiO1xuaW1wb3J0IHsgUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvcG9seW5vbWlhbC5qc1wiO1xuXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50cyB9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua1ZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFZFUklGSUVSIFNUQVJURURcIik7XG5cbiAgICBfdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBfcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgY3VydmVzLmdldEN1cnZlRnJvbU5hbWUoX3ZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IHZrID0gZnJvbU9iamVjdFZrKGN1cnZlLCBfdmtfdmVyaWZpZXIpO1xuXG4gICAgLy8gVE9ETyA/Pz8gQ29tcHV0ZSB3cl4zIGFuZCBjaGVjayBpZiBpdCBtYXRjaGVzIHdpdGggd1xuXG4gICAgY29uc3QgcHJvb2YgPSBuZXcgUHJvb2YoY3VydmUsIGxvZ2dlcik7XG4gICAgcHJvb2YuZnJvbU9iamVjdFByb29mKF9wcm9vZik7XG5cbiAgICBjb25zdCBwdWJsaWNTaWduYWxzID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWJsaWNTaWduYWxzKTtcblxuICAgIGlmIChwdWJsaWNTaWduYWxzLmxlbmd0aCAhPT0gdmsublB1YmxpYykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJOdW1iZXIgb2YgcHVibGljIHNpZ25hbHMgZG9lcyBub3QgbWF0Y2ggd2l0aCB2a1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIEZGTE9OSyBWRVJJRlkgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHt2ay5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHsyICoqIHZrLnBvd2VyfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3ZrLm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDEgLSBWYWxpZGF0ZSB0aGF0IGFsbCBwb2x5bm9taWFsIGNvbW1pdG1lbnRzIOKIiCBHXzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgY29tbWl0bWVudHMgYmVsb25nIHRvIEcxXCIpO1xuICAgIGlmICghY29tbWl0bWVudHNCZWxvbmdUb0cxKGN1cnZlLCBwcm9vZiwgdmspKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlByb29mIGlzIG5vdCB3ZWxsIGNvbnN0cnVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIC8vIFNURVAgMiAtIFZhbGlkYXRlIHRoYXQgYWxsIGV2YWx1YXRpb25zIOKIiCBGXG5cbiAgICAvLyBUT0RPXG4gICAgLy8gU1RFUCAzIC0gVmFsaWRhdGUgdGhhdCB3X2kg4oiIIEYgZm9yIGkg4oiIIFtsXVxuXG4gICAgLy8gU1RFUCA0IC0gQ29tcHV0ZSB0aGUgY2hhbGxlbmdlczogYmV0YSwgZ2FtbWEsIHhpLCBhbHBoYSBhbmQgeSDiiIggRlxuICAgIC8vIGFzIGluIHByb3ZlciBkZXNjcmlwdGlvbiwgZnJvbSB0aGUgY29tbW9uIHByZXByb2Nlc3NlZCBpbnB1dHMsIHB1YmxpYyBpbnB1dHMgYW5kIGVsZW1lbnRzIG9mIM+AX1NOQVJLXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzXCIpO1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlcywgcm9vdHMgfSA9IGNvbXB1dGVDaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgdmssIHB1YmxpY1NpZ25hbHMsIGxvZ2dlcik7XG5cbiAgICAvLyBTVEVQIDUgLSBDb21wdXRlIHRoZSB6ZXJvIHBvbHlub21pYWwgZXZhbHVhdGlvbiBaX0goeGkpID0geGlebiAtIDFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFplcm8gcG9seW5vbWlhbCBldmFsdWF0aW9uIFpfSCh4aSlcIik7XG4gICAgY2hhbGxlbmdlcy56aCA9IEZyLnN1YihjaGFsbGVuZ2VzLnhpTiwgRnIub25lKTtcbiAgICBjaGFsbGVuZ2VzLmludnpoID0gRnIuaW52KGNoYWxsZW5nZXMuemgpO1xuXG4gICAgLy8gU1RFUCA2IC0gQ29tcHV0ZSB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbCBldmFsdWF0aW9uIExfMSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIExhZ3JhbmdlIGV2YWx1YXRpb25zXCIpO1xuICAgIGNvbnN0IGxhZ3JhbmdlRXZhbHMgPSBhd2FpdCBjb21wdXRlTGFncmFuZ2VFdmFsdWF0aW9ucyhjdXJ2ZSwgY2hhbGxlbmdlcywgdmspO1xuXG4gICAgLy8gU1RFUCA3IC0gQ29tcHV0ZSBwdWJsaWMgaW5wdXQgZXZhbHVhdGlvbiBQSSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIHBvbHlub21pYWwgaWRlbnRpdGllcyBQSShYKVwiKTtcbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBsYWdyYW5nZUV2YWxzKTtcblxuICAgIC8vIFNURVAgOCAtIENvbXB1dGUgcG9seW5vbWlhbCByMCDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMCh5KVwiKTtcbiAgICBjb25zdCByMCA9IGNvbXB1dGVSMChwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMSDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMSh5KVwiKTtcbiAgICBjb25zdCByMSA9IGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMiDiiIggRl97PDZ9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMih5KVwiKTtcbiAgICBjb25zdCByMiA9IGNvbXB1dGVSMihwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGxhZ3JhbmdlRXZhbHNbMV0sIHZrLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRlwiKTtcbiAgICBjb25zdCBGID0gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBFXCIpO1xuICAgIGNvbnN0IEUgPSBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgSlwiKTtcbiAgICBjb25zdCBKID0gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBWYWxpZGF0ZSBhbGwgZXZhbHVhdGlvbnMgd2l0aCBhIHBhaXJpbmdcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiUFJPT0YgVkVSSUZJRUQgU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJJbnZhbGlkIFByb29mXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gcmVzO1xuXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuazEgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMudyA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsudyk7XG4gICAgLy8gcmVzLndXID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Vyk7XG4gICAgcmVzLnczID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Myk7XG4gICAgcmVzLnc0ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53NCk7XG4gICAgcmVzLnc4ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53OCk7XG4gICAgcmVzLndyID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53cik7XG4gICAgcmVzLlhfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmsuWF8yKTtcbiAgICByZXMuQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrLkMwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21taXRtZW50c0JlbG9uZ1RvRzEoY3VydmUsIHByb29mLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQodmsuQzApO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHZrLCBwdWJsaWNTaWduYWxzLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IHt9O1xuICAgIGNvbnN0IHJvb3RzID0ge307XG4gICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcblxuICAgIC8vIEFkZCBDMCB0byB0aGUgdHJhbnNjcmlwdFxuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5DMCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLnBvbHlub21pYWxzLkMxKTtcbiAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcblxuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgY2hhbGxlbmdlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLnBvbHlub21pYWxzLkMyKTtcbiAgICBjb25zdCB4aVNlZWQgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIGNvbnN0IHhpU2VlZDIgPSBGci5zcXVhcmUoeGlTZWVkKTtcblxuICAgIGxldCB3OCA9IFtdO1xuICAgIHc4WzFdID0gdmsudzg7XG4gICAgdzhbMl0gPSBGci5zcXVhcmUodmsudzgpO1xuICAgIHc4WzNdID0gRnIubXVsKHc4WzJdLCB2ay53OCk7XG4gICAgdzhbNF0gPSBGci5tdWwodzhbM10sIHZrLnc4KTtcbiAgICB3OFs1XSA9IEZyLm11bCh3OFs0XSwgdmsudzgpO1xuICAgIHc4WzZdID0gRnIubXVsKHc4WzVdLCB2ay53OCk7XG4gICAgdzhbN10gPSBGci5tdWwodzhbNl0sIHZrLnc4KTtcbiAgICBsZXQgdzQgPSBbXTtcbiAgICB3NFsxXSA9IHZrLnc0O1xuICAgIHc0WzJdID0gRnIuc3F1YXJlKHZrLnc0KTtcbiAgICB3NFszXSA9IEZyLm11bCh3NFsyXSwgdmsudzQpO1xuICAgIGxldCB3MyA9IFtdO1xuICAgIHczWzFdID0gdmsudzM7XG4gICAgdzNbMl0gPSBGci5zcXVhcmUodmsudzMpO1xuXG4gICAgLy8gY29uc3QgdzRfMiA9IEZyLnNxdWFyZSh2ay53NCk7XG4gICAgLy8gY29uc3QgdzRfMyA9IEZyLm11bCh3NF8yLCB2ay53NCk7XG4gICAgLy8gY29uc3QgdzNfMiA9IEZyLnNxdWFyZSh2ay53Myk7XG5cbiAgICAvLyBDb21wdXRlIGgwID0geGlTZWVkZXJeM1xuICAgIHJvb3RzLlMwID0ge307XG4gICAgcm9vdHMuUzAuaDB3OCA9IFtdO1xuICAgIHJvb3RzLlMwLmgwdzhbMF0gPSBGci5tdWwoeGlTZWVkMiwgeGlTZWVkKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICByb290cy5TMC5oMHc4W2ldID0gRnIubXVsKHJvb3RzLlMwLmgwdzhbMF0sIHc4W2ldKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGgxID0geGlfc2VlZGVyXjZcbiAgICByb290cy5TMSA9IHt9O1xuICAgIHJvb3RzLlMxLmgxdzQgPSBbXTtcbiAgICByb290cy5TMS5oMXc0WzBdID0gRnIuc3F1YXJlKHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHJvb3RzLlMxLmgxdzRbaV0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgdzRbaV0pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaDIgPSB4aV9zZWVkZXJeOFxuICAgIHJvb3RzLlMyID0ge307XG4gICAgcm9vdHMuUzIuaDJ3MyA9IFtdO1xuICAgIHJvb3RzLlMyLmgydzNbMF0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgeGlTZWVkMik7XG4gICAgcm9vdHMuUzIuaDJ3M1sxXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB3M1sxXSk7XG4gICAgcm9vdHMuUzIuaDJ3M1syXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB3M1syXSk7XG5cbiAgICByb290cy5TMi5oM3czID0gW107XG4gICAgLy8gTXVsdGlwbHkgaDMgYnkgdGhpcmQtcm9vdC1vbWVnYSB0byBvYnRhaW4gaF8zXjMgPSB4ac+JXG4gICAgLy8gU28sIGgzID0geGlfc2VlZGVyXjggz4leezEvM31cbiAgICByb290cy5TMi5oM3czWzBdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHZrLndyKTtcbiAgICByb290cy5TMi5oM3czWzFdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHczWzFdKTtcbiAgICByb290cy5TMi5oM3czWzJdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHczWzJdKTtcblxuICAgIC8vIENvbXB1dGUgeGkgPSB4aV9zZWVkZXJeMTJcbiAgICBjaGFsbGVuZ2VzLnhpID0gRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczWzBdKSwgcm9vdHMuUzIuaDJ3M1swXSk7XG5cbiAgICBjaGFsbGVuZ2VzLnhpTiA9IGNoYWxsZW5nZXMueGk7XG4gICAgdmsuZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ay5wb3dlcjsgaSsrKSB7XG4gICAgICAgIGNoYWxsZW5nZXMueGlOID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGlOKTtcbiAgICAgICAgdmsuZG9tYWluU2l6ZSAqPSAyO1xuICAgIH1cblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcih4aVNlZWQpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFsKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xcik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFvKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMueik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuencpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnQxdyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMudDJ3KTtcbiAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuVzEpO1xuICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiAgICBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogICAgIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy55KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY2hhbGxlbmdlczogY2hhbGxlbmdlcywgcm9vdHM6IHJvb3RzIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgdmsublB1YmxpYyk7XG4gICAgY29uc3QgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKHNpemUgKiBGci5uOCk7XG5cbiAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgbnVtQXJyLnNldChGci5tdWwodywgY2hhbGxlbmdlcy56aCksIGlfc0ZyKTtcbiAgICAgICAgZGVuQXJyLnNldChGci5tdWwoRnIuZSh2ay5kb21haW5TaXplKSwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSwgaV9zRnIpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIHZrLncpO1xuICAgIH1cblxuICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgbGV0IEwgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgTFtpICsgMV0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSk7XG4gICAgfVxuICAgIHJldHVybiBMO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bCh3LCBsYWdyYW5nZUV2YWxzW2kgKyAxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMChwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIC8vIHIwKHkpID0g4oiRXzFeOCBDXzAoaF8wIM+JXzhee2ktMX0pIExfaSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG5cbiAgICAvLyBDb21wdXRlIHRoZSA4IEMwIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMChoXzDPiV84XmkpIHZhbHVlc1wiKTtcblxuICAgIGxldCBjMFZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGxldCBjb2VmVmFsdWVzID0gW107XG4gICAgICAgIGNvZWZWYWx1ZXNbMV0gPSByb290cy5TMC5oMHc4W2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgY29lZlZhbHVlc1tqXSA9IEZyLm11bChjb2VmVmFsdWVzW2ogLSAxXSwgcm9vdHMuUzAuaDB3OFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjMFZhbHVlc1tpXSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5xbCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFyLCBjb2VmVmFsdWVzWzFdKSk7XG4gICAgICAgIGMwVmFsdWVzW2ldID0gRnIuYWRkKGMwVmFsdWVzW2ldLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW8sIGNvZWZWYWx1ZXNbMl0pKTtcbiAgICAgICAgYzBWYWx1ZXNbaV0gPSBGci5hZGQoYzBWYWx1ZXNbaV0sIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbSwgY29lZlZhbHVlc1szXSkpO1xuICAgICAgICBjMFZhbHVlc1tpXSA9IEZyLmFkZChjMFZhbHVlc1tpXSwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFjLCBjb2VmVmFsdWVzWzRdKSk7XG4gICAgICAgIGMwVmFsdWVzW2ldID0gRnIuYWRkKGMwVmFsdWVzW2ldLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczEsIGNvZWZWYWx1ZXNbNV0pKTtcbiAgICAgICAgYzBWYWx1ZXNbaV0gPSBGci5hZGQoYzBWYWx1ZXNbaV0sIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMiwgY29lZlZhbHVlc1s2XSkpO1xuICAgICAgICBjMFZhbHVlc1tpXSA9IEZyLmFkZChjMFZhbHVlc1tpXSwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMzLCBjb2VmVmFsdWVzWzddKSk7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJwb2xhdGUgYSBwb2x5bm9taWFsIHdpdGggdGhlIHBvaW50cyBjb21wdXRlZCBwcmV2aW91c2x5XG4gICAgY29uc3QgUjAgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgIFtyb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFs0XSwgcm9vdHMuUzAuaDB3OFs1XSwgcm9vdHMuUzAuaDB3OFs2XSwgcm9vdHMuUzAuaDB3OFs3XV0sXG4gICAgICAgIGMwVmFsdWVzLCBjdXJ2ZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIxKFgpIDwgNFxuICAgIGlmIChSMC5kZWdyZWUoKSA+IDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIHRoZSBwb2x5bm9taWFsIGluIGNoYWxsZW5nZXMueVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBldmFsdWF0aW9uIHIwKHkpXCIpO1xuICAgIHJldHVybiBSMC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjEocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBwaSwgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICAvLyByMSh5KSA9IOKIkV8xXjQgQ18xKGhfMSDPiV80XntpLTF9KSBMX2koeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuICAgIC8vIFoxID0ge0MxKGhfMX0sIEMxKGhfMSDPiV80KSwgQzEoaF8xIM+JXzReMiksIEMxKGhfMSDPiV80XjMpfVxuICAgIC8vIHdoZXJlIENfMShoXzEgz4lfNF57aS0xfSkgPSBldmFsLmEgKyBoXzEgz4lfNF5pIGV2YWwuYiArIChoXzEgz4lfNF5pKV4yIGV2YWwuYyArIChoXzEgz4lfNF5pKV4zIFQwKHhpKSxcbiAgICAvLyB3aGVyZSBUMCh4aSkgPSBbIHFMwrdhICsgcVLCt2IgKyBxTcK3YcK3YiArIHFPwrdjICsgcUMgKyBQSSh4aSkgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDAoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwKHhpKVwiKTtcbiAgICBsZXQgdDAgPSBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucWwsIHByb29mLmV2YWx1YXRpb25zLmEpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucXIsIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFtLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuYSwgcHJvb2YuZXZhbHVhdGlvbnMuYikpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFvLCBwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgdDAgPSBGci5hZGQodDAsIHByb29mLmV2YWx1YXRpb25zLnFjKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgcGkpO1xuICAgIHQwID0gRnIubXVsKHQwLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIDQgQzEgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMxKGhfMc+JXzReaSkgdmFsdWVzXCIpO1xuXG4gICAgbGV0IGMxVmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgYzFWYWx1ZXNbaV0gPSBwcm9vZi5ldmFsdWF0aW9ucy5hO1xuICAgICAgICBjMVZhbHVlc1tpXSA9IEZyLmFkZChjMVZhbHVlc1tpXSwgRnIubXVsKHJvb3RzLlMxLmgxdzRbaV0sIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICAgICAgY29uc3QgaDF3NFNxdWFyZWQgPSBGci5zcXVhcmUocm9vdHMuUzEuaDF3NFtpXSk7XG4gICAgICAgIGMxVmFsdWVzW2ldID0gRnIuYWRkKGMxVmFsdWVzW2ldLCBGci5tdWwoaDF3NFNxdWFyZWQsIHByb29mLmV2YWx1YXRpb25zLmMpKTtcbiAgICAgICAgYzFWYWx1ZXNbaV0gPSBGci5hZGQoYzFWYWx1ZXNbaV0sIEZyLm11bChGci5tdWwoaDF3NFNxdWFyZWQsIHJvb3RzLlMxLmgxdzRbaV0pLCB0MCkpO1xuICAgIH1cblxuICAgIC8vIEludGVycG9sYXRlIGEgcG9seW5vbWlhbCB3aXRoIHRoZSBwb2ludHMgY29tcHV0ZWQgcHJldmlvdXNseVxuICAgIGNvbnN0IFIxID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICBbcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXV0sXG4gICAgICAgIGMxVmFsdWVzLCBjdXJ2ZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIxKFgpIDwgNFxuICAgIGlmIChSMS5kZWdyZWUoKSA+IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIHRoZSBwb2x5bm9taWFsIGluIGNoYWxsZW5nZXMueVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBldmFsdWF0aW9uIHIxKHkpXCIpO1xuICAgIHJldHVybiBSMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjIocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBsYWdyYW5nZTEsIHZrLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIC8vIHIyKHkpID0g4oiRXzFeMyBDXzIoaF8yIM+JXzNee2ktMX0pIExfaSh5KSArIOKIkV8xXjMgQ18yKGhfMyDPiV8zXntpLTF9KSBMX3tpKzN9KHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcbiAgICAvLyBaMiA9IHtbQzIoaF8yfSwgQzIoaF8yIM+JXzMpLCBDMihoXzIgz4lfM14yKV0sIFtDMihoXzN9LCBDMihoXzMgz4lfMyksIEMyKGhfMyDPiV8zXjIpXX1cbiAgICAvLyB3aGVyZSBDXzIoaF8yIM+JXzNee2ktMX0pID0gZXZhbC56ICsgaF8yIM+JXzJeaSBUMSh4aSkgKyAoaF8yIM+JXzNeaSleMiBUMih4aSksXG4gICAgLy8gd2hlcmUgQ18yKGhfMyDPiV8zXntpLTF9KSA9IGV2YWwueiArIGhfMyDPiV8yXmkgVDEoeGkpICsgKGhfMyDPiV8zXmkpXjIgVDIoeGkpLFxuICAgIC8vIHdoZXJlIFQxKHhpKSA9IFsgTF8xKHhpKSh6LTEpXSAvIFpfSCh4aSlcbiAgICAvLyBhbmQgVDIoeGkpID0gWyAgKGEgKyBiZXRhwrd4aSArIGdhbW1hKShiICsgYmV0YcK3eGnCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrd4acK3azIgKyBnYW1tYSl6XG4gICAgLy8gICAgICAgICAgICAgICAtIChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKXrPiSAgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxKHhpKVwiKTtcbiAgICBsZXQgdDEgPSBGci5zdWIocHJvb2YuZXZhbHVhdGlvbnMueiwgRnIub25lKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgbGFncmFuZ2UxKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIFQyKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMih4aSlcIik7XG4gICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG4gICAgY29uc3QgdDIxMSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5hLCBGci5hZGQoYmV0YXhpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5iLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazEpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMyA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5jLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazIpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxID0gRnIubXVsKHQyMTEsIEZyLm11bCh0MjEyLCBGci5tdWwodDIxMywgcHJvb2YuZXZhbHVhdGlvbnMueikpKTtcblxuICAgIGNvbnN0IHQyMjEgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYSwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMxKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYiwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMyKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjMgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYywgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMzKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMiA9IEZyLm11bCh0MjIxLCBGci5tdWwodDIyMiwgRnIubXVsKHQyMjMsIHByb29mLmV2YWx1YXRpb25zLnp3KSkpO1xuXG4gICAgbGV0IHQyID0gRnIuc3ViKHQyMSwgdDIyKTtcbiAgICB0MiA9IEZyLm11bCh0MiwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSA2IEMyIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMihoXzLPiV8zXmkpIHZhbHVlc1wiKTtcbiAgICBsZXQgYzJWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBjMlZhbHVlc1tpXSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56LCBGci5tdWwocm9vdHMuUzIuaDJ3M1tpXSwgdDEpKTtcbiAgICAgICAgYzJWYWx1ZXNbaV0gPSBGci5hZGQoYzJWYWx1ZXNbaV0sIEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1tpXSksIHQyKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMyKGhfM8+JXzNeaSkgdmFsdWVzXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGMyVmFsdWVzW2kgKyAzXSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56dywgRnIubXVsKHJvb3RzLlMyLmgzdzNbaV0sIHByb29mLmV2YWx1YXRpb25zLnQxdykpO1xuICAgICAgICBjMlZhbHVlc1tpICsgM10gPSBGci5hZGQoYzJWYWx1ZXNbaSArIDNdLCBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgzdzNbaV0pLCBwcm9vZi5ldmFsdWF0aW9ucy50MncpKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcnBvbGF0ZSBhIHBvbHlub21pYWwgd2l0aCB0aGUgcG9pbnRzIGNvbXB1dGVkIHByZXZpb3VzbHlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgcjIoeGkpXCIpO1xuICAgIGNvbnN0IFIyID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICBbcm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMuUzIuaDJ3M1sxXSwgcm9vdHMuUzIuaDJ3M1syXSxcbiAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLFxuICAgICAgICBjMlZhbHVlcywgY3VydmUpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMihYKSA8IDZcbiAgICBpZiAoUjIuZGVncmVlKCkgPiA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBFdmFsdWF0ZSB0aGUgcG9seW5vbWlhbCBpbiBjaGFsbGVuZ2VzLnlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgZXZhbHVhdGlvbiByMih5KVwiKTtcbiAgICByZXR1cm4gUjIuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgbXVsSDAgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBtdWxIMCA9IEZyLm11bChtdWxIMCwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFtpXSkpO1xuICAgIH1cblxuICAgIGNoYWxsZW5nZXMudGVtcCA9IG11bEgwO1xuXG4gICAgbGV0IG11bEgxID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgbXVsSDEgPSBGci5tdWwobXVsSDEsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbaV0pKTtcbiAgICB9XG5cbiAgICBsZXQgbXVsSDIgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDM7IGkrKykge1xuICAgICAgICBtdWxIMiA9IEZyLm11bChtdWxIMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1tpXSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBtdWxIMiA9IEZyLm11bChtdWxIMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDN3M1tpXSkpO1xuICAgIH1cblxuICAgIGNoYWxsZW5nZXMucXVvdGllbnQxID0gRnIubXVsKGNoYWxsZW5nZXMuYWxwaGEsIEZyLmRpdihtdWxIMCwgbXVsSDEpKTtcbiAgICBjaGFsbGVuZ2VzLnF1b3RpZW50MiA9IEZyLm11bChGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSksIEZyLmRpdihtdWxIMCwgbXVsSDIpKTtcblxuICAgIGxldCBGMiA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuQzEsIGNoYWxsZW5nZXMucXVvdGllbnQxKTtcbiAgICBsZXQgRjMgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLkMyLCBjaGFsbGVuZ2VzLnF1b3RpZW50Mik7XG5cbiAgICByZXR1cm4gRzEuYWRkKHZrLkMwLCBHMS5hZGQoRjIsIEYzKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIHIwLCByMSwgcjIpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgRTIgPSBGci5tdWwocjEsIGNoYWxsZW5nZXMucXVvdGllbnQxKTtcbiAgICBsZXQgRTMgPSBGci5tdWwocjIsIGNoYWxsZW5nZXMucXVvdGllbnQyKTtcblxuICAgIHJldHVybiBHMS50aW1lc0ZyKEcxLm9uZSwgRnIuYWRkKHIwLCBGci5hZGQoRTIsIEUzKSkpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgcmV0dXJuIEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuVzEsIGNoYWxsZW5nZXMudGVtcCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIEYsIEUsIEopIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgbGV0IEExID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5XMiwgY2hhbGxlbmdlcy55KTtcbiAgICBBMSA9IEcxLmFkZChHMS5zdWIoRzEuc3ViKEYsIEUpLCBKKSwgQTEpO1xuICAgIGNvbnN0IEEyID0gY3VydmUuRzIub25lO1xuXG4gICAgY29uc3QgQjEgPSBwcm9vZi5wb2x5bm9taWFscy5XMjtcbiAgICBjb25zdCBCMiA9IHZrLlhfMjtcblxuICAgIHJldHVybiBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoRzEubmVnKEExKSwgQTIsIEIxLCBCMik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/fflonk_verify.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/groth16.js":
/*!******************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/groth16.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_fullprove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16_fullprove.js\");\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./groth16_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./groth16_verify.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16_verify.js\");\n/* harmony import */ var _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./groth16_exportsoliditycalldata.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTREO0FBQ1I7QUFDRTtBQUNnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTYuanM/MWJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgZnVsbFByb3ZlfSBmcm9tIFwiLi9ncm90aDE2X2Z1bGxwcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHByb3ZlfSBmcm9tIFwiLi9ncm90aDE2X3Byb3ZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdmVyaWZ5fSBmcm9tIFwiLi9ncm90aDE2X3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydFNvbGlkaXR5Q2FsbERhdGF9IGZyb20gXCIuL2dyb3RoMTZfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/groth16.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js":
/*!*****************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16ExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUN3QztBQUN4QyxRQUFRLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CLElBQUksb0JBQW9CO0FBQ3RELGFBQWEsdUJBQXVCLElBQUksdUJBQXVCLEtBQUssdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RILFlBQVksb0JBQW9CLElBQUksb0JBQW9CO0FBQ3hELFlBQVksT0FBTzs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcz8yMDc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBwMjU2KG4pIHtcbiAgICBsZXQgbnN0ciA9IG4udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChuc3RyLmxlbmd0aCA8IDY0KSBuc3RyID0gXCIwXCIrbnN0cjtcbiAgICBuc3RyID0gYFwiMHgke25zdHJ9XCJgO1xuICAgIHJldHVybiBuc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBncm90aDE2RXhwb3J0U29saWRpdHlDYWxsRGF0YShfcHJvb2YsIF9wdWIpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHViKTtcblxuICAgIGxldCBpbnB1dHMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTxwdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBcIlwiKSBpbnB1dHMgPSBpbnB1dHMgKyBcIixcIjtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzICsgcDI1NihwdWJbaV0pO1xuICAgIH1cblxuICAgIGxldCBTO1xuICAgIFM9YFske3AyNTYocHJvb2YucGlfYVswXSl9LCAke3AyNTYocHJvb2YucGlfYVsxXSl9XSxgICtcbiAgICAgICAgYFtbJHtwMjU2KHByb29mLnBpX2JbMF1bMV0pfSwgJHtwMjU2KHByb29mLnBpX2JbMF1bMF0pfV0sWyR7cDI1Nihwcm9vZi5waV9iWzFdWzFdKX0sICR7cDI1Nihwcm9vZi5waV9iWzFdWzBdKX1dXSxgICtcbiAgICAgICAgYFske3AyNTYocHJvb2YucGlfY1swXSl9LCAke3AyNTYocHJvb2YucGlfY1sxXSl9XSxgICtcbiAgICAgICAgYFske2lucHV0c31dYDtcblxuICAgIHJldHVybiBTO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/groth16_fullprove.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/groth16_fullprove.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16FullProve)\n/* harmony export */ });\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns);\n    return await (0,_groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9mdWxscHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0U7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQWM7QUFDeEIsaUJBQWlCLDZEQUFhO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9mdWxscHJvdmUuanM/YjgxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgZ3JvdGgxNl9wcm92ZSBmcm9tIFwiLi9ncm90aDE2X3Byb3ZlLmpzXCI7XG5pbXBvcnQgd3Ruc19jYWxjdWxhdGUgZnJvbSBcIi4vd3Ruc19jYWxjdWxhdGUuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge1xuICAgICAgICB0eXBlOiBcIm1lbVwiXG4gICAgfTtcbiAgICBhd2FpdCB3dG5zX2NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMpO1xuICAgIHJldHVybiBhd2FpdCBncm90aDE2X3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/groth16_fullprove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/groth16_prove.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/groth16_prove.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_4__.log2)(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buldABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer) {\n        outBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNBO0FBQ1c7QUFDdkI7QUFDdUI7QUFDeEQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0UsdUJBQXVCLHNEQUFvQjs7QUFFM0MsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYztBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsOENBQUk7O0FBRXRCO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDtBQUNBLDZCQUE2Qiw0REFBd0I7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw4QkFBOEIsNERBQXdCO0FBQ3REOztBQUVBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw2QkFBNkIsNERBQXdCO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbURBQVM7QUFDbEMseUJBQXlCLG1EQUFTO0FBQ2xDLHlCQUF5QixtREFBUzs7QUFFbEM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixnRUFBZ0UsRUFBRSxHQUFHLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLCtEQUErRCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHdDQUF3QyxFQUFFLElBQUksRUFBRSxHQUFHLFdBQVc7QUFDOUQ7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsMEVBQTBFO0FBQ2pHLHVCQUF1QixnRkFBZ0Y7QUFDdkcsdUJBQXVCLHlDQUF5QztBQUNoRSx1QkFBdUIseUNBQXlDO0FBQ2hFLHVCQUF1Qix5Q0FBeUM7QUFDaEUsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQiwyQ0FBMkM7QUFDNUQsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLHdCQUF3QjtBQUN6QyxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakIsY0FBYztBQUNkLHVCQUF1QiwrQ0FBK0M7QUFDdEUsdUJBQXVCLCtDQUErQztBQUN0RSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUUsdUJBQXVCLG1EQUFtRDtBQUMxRSwwQkFBMEIsS0FBSztBQUMvQiwyQkFBMkIsdUNBQXVDO0FBQ2xFLDhCQUE4QixXQUFXO0FBQ3pDLCtCQUErQix1REFBdUQ7QUFDdEYsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixxQ0FBcUM7QUFDOUQseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBLDJCQUEyQixxREFBcUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQiw2Q0FBNkMsRUFBRSxHQUFHLFVBQVU7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLHNDQUFzQztBQUN6RCxtQkFBbUIsc0NBQXNDO0FBQ3pELG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWE7QUFDYixVQUFVO0FBQ1YsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLG1EQUFTO0FBQzlCLHNCQUFzQixtREFBUztBQUMvQixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X3Byb3ZlLmpzP2YzNjgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7IGxvZzIgfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIsIHV0aWxzLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7c3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlByb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCB7ZmQ6IGZkV3Rucywgc2VjdGlvbnM6IHNlY3Rpb25zV3Ruc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUod2l0bmVzc0ZpbGVOYW1lLCBcInd0bnNcIiwgMiwgMTw8MjUsIDE8PDIzKTtcblxuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHNlY3Rpb25zV3Rucyk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHNlY3Rpb25zWktleX0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMiwgMTw8MjUsIDE8PDIzKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZFpLZXksIHNlY3Rpb25zWktleSk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgaWYgKCFTY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgY29uc3QgcG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIFd0bnNcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCBzZWN0aW9uc1d0bnMsIDIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQ29lZmZzXCIpO1xuICAgIGNvbnN0IGJ1ZmZDb2VmZnMgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDQpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQnVpbGRpbmcgQUJDXCIpO1xuICAgIGNvbnN0IFtidWZmQV9ULCBidWZmQl9ULCBidWZmQ19UXSA9IGF3YWl0IGJ1aWxkQUJDMShjdXJ2ZSwgemtleSwgYnVmZldpdG5lc3MsIGJ1ZmZDb2VmZnMsIGxvZ2dlcik7XG5cbiAgICBjb25zdCBpbmMgPSBwb3dlciA9PSBGci5zID8gY3VydmUuRnIuc2hpZnQgOiBjdXJ2ZS5Gci53W3Bvd2VyKzFdO1xuXG4gICAgY29uc3QgYnVmZkEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZBX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0FcIik7XG4gICAgY29uc3QgYnVmZkFvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZBLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkFvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQVwiKTtcblxuICAgIGNvbnN0IGJ1ZmZCID0gYXdhaXQgRnIuaWZmdChidWZmQl9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9CXCIpO1xuICAgIGNvbnN0IGJ1ZmZCb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQiwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQm9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZCb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0JcIik7XG5cbiAgICBjb25zdCBidWZmQyA9IGF3YWl0IEZyLmlmZnQoYnVmZkNfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQ1wiKTtcbiAgICBjb25zdCBidWZmQ29kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkMsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkNvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQ29kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9DXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiSm9pbiBBQkNcIik7XG4gICAgY29uc3QgYnVmZlBvZGRfVCA9IGF3YWl0IGpvaW5BQkMoY3VydmUsIHprZXksIGJ1ZmZBb2RkX1QsIGJ1ZmZCb2RkX1QsIGJ1ZmZDb2RkX1QsIGxvZ2dlcik7XG5cbiAgICBsZXQgcHJvb2YgPSB7fTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQSBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgcHJvb2YucGlfYSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0EsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IxID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA2KTtcbiAgICBsZXQgcGliMSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0IxLCBidWZmV2l0bmVzcywgbG9nZ2VyLCBcIm11bHRpZXhwIEIxXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBCMiBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQjIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDcpO1xuICAgIHByb29mLnBpX2IgPSBhd2FpdCBjdXJ2ZS5HMi5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNCMiwgYnVmZldpdG5lc3MsIGxvZ2dlciwgXCJtdWx0aWV4cCBCMlwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQyBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgcHJvb2YucGlfYyA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0MsIGJ1ZmZXaXRuZXNzLnNsaWNlKCh6a2V5Lm5QdWJsaWMrMSkqY3VydmUuRnIubjgpLCBsb2dnZXIsIFwibXVsdGlleHAgQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgSCBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzSCA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOSk7XG4gICAgY29uc3QgcmVzSCA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0gsIGJ1ZmZQb2RkX1QsIGxvZ2dlciwgXCJtdWx0aWV4cCBIXCIpO1xuXG4gICAgY29uc3QgciA9IGN1cnZlLkZyLnJhbmRvbSgpO1xuICAgIGNvbnN0IHMgPSBjdXJ2ZS5Gci5yYW5kb20oKTtcblxuICAgIHByb29mLnBpX2EgID0gRzEuYWRkKCBwcm9vZi5waV9hLCB6a2V5LnZrX2FscGhhXzEgKTtcbiAgICBwcm9vZi5waV9hICA9IEcxLmFkZCggcHJvb2YucGlfYSwgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCByICkpO1xuXG4gICAgcHJvb2YucGlfYiAgPSBHMi5hZGQoIHByb29mLnBpX2IsIHprZXkudmtfYmV0YV8yICk7XG4gICAgcHJvb2YucGlfYiAgPSBHMi5hZGQoIHByb29mLnBpX2IsIEcyLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMiwgcyApKTtcblxuICAgIHBpYjEgPSBHMS5hZGQoIHBpYjEsIHprZXkudmtfYmV0YV8xICk7XG4gICAgcGliMSA9IEcxLmFkZCggcGliMSwgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCBzICkpO1xuXG4gICAgcHJvb2YucGlfYyA9IEcxLmFkZChwcm9vZi5waV9jLCByZXNIKTtcblxuXG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHByb29mLnBpX2EsIHMgKSk7XG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHBpYjEsIHIgKSk7XG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgRnIubmVnKEZyLm11bChyLHMpICkpKTtcblxuXG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MTsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSBidWZmV2l0bmVzcy5zbGljZShpKkZyLm44LCBpKkZyLm44K0ZyLm44KTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUoYikpO1xuICAgIH1cblxuICAgIHByb29mLnBpX2EgPSBHMS50b09iamVjdChHMS50b0FmZmluZShwcm9vZi5waV9hKSk7XG4gICAgcHJvb2YucGlfYiA9IEcyLnRvT2JqZWN0KEcyLnRvQWZmaW5lKHByb29mLnBpX2IpKTtcbiAgICBwcm9vZi5waV9jID0gRzEudG9PYmplY3QoRzEudG9BZmZpbmUocHJvb2YucGlfYykpO1xuXG4gICAgcHJvb2YucHJvdG9jb2wgPSBcImdyb3RoMTZcIjtcbiAgICBwcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIHByb29mID0gc3RyaW5naWZ5QmlnSW50cyhwcm9vZik7XG4gICAgcHVibGljU2lnbmFscyA9IHN0cmluZ2lmeUJpZ0ludHMocHVibGljU2lnbmFscyk7XG5cbiAgICByZXR1cm4ge3Byb29mLCBwdWJsaWNTaWduYWxzfTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBidWlsZEFCQzEoY3VydmUsIHprZXksIHdpdG5lc3MsIGNvZWZmcywgbG9nZ2VyKSB7XG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzQ29lZiA9IDQqMyArIHprZXkubjhyO1xuICAgIGNvbnN0IG5Db2VmID0gKGNvZWZmcy5ieXRlTGVuZ3RoLTQpIC8gc0NvZWY7XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44KTtcblxuICAgIGNvbnN0IG91dEJ1ZiA9IFsgb3V0QnVmZkEsIG91dEJ1ZmZCIF07XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db2VmOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBBQjogJHtpfS8ke25Db2VmfWApO1xuICAgICAgICBjb25zdCBidWZmQ29lZiA9IGNvZWZmcy5zbGljZSg0K2kqc0NvZWYsIDQraSpzQ29lZitzQ29lZik7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmViA9IG5ldyBEYXRhVmlldyhidWZmQ29lZi5idWZmZXIpO1xuICAgICAgICBjb25zdCBtPSBidWZmQ29lZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBjb25zdCBjPSBidWZmQ29lZlYuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBjb25zdCBzPSBidWZmQ29lZlYuZ2V0VWludDMyKDgsIHRydWUpO1xuICAgICAgICBjb25zdCBjb2VmID0gYnVmZkNvZWYuc2xpY2UoMTIsIDEyK244KTtcbiAgICAgICAgb3V0QnVmW21dLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLmFkZChcbiAgICAgICAgICAgICAgICBvdXRCdWZbbV0uc2xpY2UoYypuOCwgYypuOCtuOCksXG4gICAgICAgICAgICAgICAgY3VydmUuRnIubXVsKGNvZWYsIHdpdG5lc3Muc2xpY2UocypuOCwgcypuOCtuOCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYypuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgUUFQIEM6ICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgIG91dEJ1ZmZDLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLm11bChcbiAgICAgICAgICAgICAgICBvdXRCdWZmQS5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICAgICBvdXRCdWZmQi5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpKm44XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRCdWZmQSwgb3V0QnVmZkIsIG91dEJ1ZmZDXTtcblxufVxuXG4vKlxuYXN5bmMgZnVuY3Rpb24gYnVsZEFCQyhjdXJ2ZSwgemtleSwgd2l0bmVzcywgY29lZmZzLCBsb2dnZXIpIHtcbiAgICBjb25zdCBjb25jdXJyZW5jeSA9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgIGNvbnN0IHNDb2VmID0gNCozICsgemtleS5uOHI7XG5cbiAgICBsZXQgZ2V0VWludDMyO1xuXG4gICAgaWYgKGNvZWZmcyBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICBjb25zdCBjb2VmZnNEViA9IFtdO1xuICAgICAgICBjb25zdCBQQUdFX0xFTiA9IGNvZWZmcy5idWZmZXJzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBjb2VmZnMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29lZmZzRFYucHVzaChuZXcgRGF0YVZpZXcoY29lZmZzLmJ1ZmZlcnNbaV0uYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VWludDMyID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvZWZmc0RWW01hdGguZmxvb3IocG9zL1BBR0VfTEVOKV0uZ2V0VWludDMyKHBvcyAlIFBBR0VfTEVOLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2VmZnNEViA9IG5ldyBEYXRhVmlldyhjb2VmZnMuYnVmZmVyLCBjb2VmZnMuYnl0ZU9mZnNldCwgY29lZmZzLmJ5dGVMZW5ndGgpO1xuICAgICAgICBnZXRVaW50MzIgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gY29lZmZzRFYuZ2V0VWludDMyKHBvcywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHNQZXJDaHVuayA9IE1hdGguZmxvb3IoemtleS5kb21haW5TaXplL2NvbmN1cnJlbmN5KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgY29uc3QgY3V0UG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgY3V0UG9pbnRzLnB1c2goIGdldEN1dFBvaW50KCBNYXRoLmZsb29yKGkqZWxlbWVudHNQZXJDaHVuaykgKSk7XG4gICAgfVxuICAgIGN1dFBvaW50cy5wdXNoKGNvZWZmcy5ieXRlTGVuZ3RoKTtcblxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDIqKjI2O1xuICAgIGZvciAobGV0IHM9MCA7IHM8emtleS5uVmFycyA7IHMrPSBjaHVua1NpemUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBRQVAgJHtzfTogJHtzfS8ke3prZXkublZhcnN9YCk7XG4gICAgICAgIGNvbnN0IG5zPSBNYXRoLm1pbih6a2V5Lm5WYXJzLXMsIGNodW5rU2l6ZSApO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IGVsZW1lbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSB6a2V5LmRvbWFpblNpemUgLSBpKmVsZW1lbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBjb2VmZnMuc2xpY2UoY3V0UG9pbnRzW2ldLCBjdXRQb2ludHNbaSsxXSl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogd2l0bmVzcy5zbGljZShzKmN1cnZlLkZyLm44LCAocytucykqY3VydmUuRnIubjgpfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAzLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogNCwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJxYXBfYnVpbGRBQkNcIiwgcGFyYW1zOltcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiAoY3V0UG9pbnRzW2krMV0gLSBjdXRQb2ludHNbaV0pL3NDb2VmfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICB7dmFyOiA0fSxcbiAgICAgICAgICAgICAgICB7dmFsOiBpKmVsZW1lbnRzUGVyQ2h1bmt9LFxuICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgIHt2YWw6IHN9LFxuICAgICAgICAgICAgICAgIHt2YWw6IG5zfVxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAyLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMywgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAyLCB2YXI6IDQsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgY29uc3Qgbkdyb3VwcyA9IHJlc3VsdC5sZW5ndGggLyBjb25jdXJyZW5jeTtcbiAgICBpZiAobkdyb3Vwcz4xKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzMiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzaz1bXTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMCwgbGVuOiByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RofSk7XG4gICAgICAgICAgICBmb3IgKGxldCBtPTA7IG08MzsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMCwgYnVmZjogcmVzdWx0W2ldW21dfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcz0xOyBzPG5Hcm91cHM7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAxLCBidWZmOiByZXN1bHRbcypjb25jdXJyZW5jeSArIGldW21dfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9iYXRjaEFkZFwiLCBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHJlc3VsdFtpXVttXS5sZW5ndGgvY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH1cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiBtLCB2YXI6IDAsIGxlbjogcmVzdWx0W2ldW21dLmxlbmd0aH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMyLnB1c2goY3VydmUudG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzMik7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0QnVmZkEgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBjb25zdCBvdXRCdWZmQiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZDID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgbGV0IHA9MDtcbiAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dEJ1ZmZBLnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICBvdXRCdWZmQi5zZXQocmVzdWx0W2ldWzFdLCBwKTtcbiAgICAgICAgb3V0QnVmZkMuc2V0KHJlc3VsdFtpXVsyXSwgcCk7XG4gICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRCdWZmQSwgb3V0QnVmZkIsIG91dEJ1ZmZDXTtcblxuICAgIGZ1bmN0aW9uIGdldEN1dFBvaW50KHYpIHtcbiAgICAgICAgbGV0IG0gPSAwO1xuICAgICAgICBsZXQgbiA9IGdldFVpbnQzMigwKTtcbiAgICAgICAgd2hpbGUgKG0gPCBuKSB7XG4gICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoKG4gKyBtKSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgdmEgPSBnZXRVaW50MzIoNCArIGsqc0NvZWYgKyA0KTtcbiAgICAgICAgICAgIGlmICh2YSA+IHYpIHtcbiAgICAgICAgICAgICAgICBuID0gayAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhIDwgdikge1xuICAgICAgICAgICAgICAgIG0gPSBrICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDQgKyBtKnNDb2VmO1xuICAgIH1cbn1cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGpvaW5BQkMoY3VydmUsIHprZXksIGEsIGIsIGMsIGxvZ2dlcikge1xuICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMSA8PCAyMjtcblxuICAgIGNvbnN0IG44ID0gY3VydmUuRnIubjg7XG4gICAgY29uc3QgbkVsZW1lbnRzID0gTWF0aC5mbG9vcihhLmJ5dGVMZW5ndGggLyBjdXJ2ZS5Gci5uOCk7XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5FbGVtZW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEpvaW5BQkM6ICR7aX0vJHtuRWxlbWVudHN9YCk7XG4gICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5FbGVtZW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcblxuICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgY29uc3QgYUNodW5rID0gYS5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG4gICAgICAgIGNvbnN0IGJDaHVuayA9IGIuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuICAgICAgICBjb25zdCBjQ2h1bmsgPSBjLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcblxuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGFDaHVua30pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGJDaHVua30pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGNDaHVua30pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogbipuOH0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJxYXBfam9pbkFCQ1wiLCBwYXJhbXM6W1xuICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJmcm1fYmF0Y2hGcm9tTW9udGdvbWVyeVwiLCBwYXJhbXM6W1xuICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgIHt2YXI6IDN9XG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAzLCBsZW46IG4qbjh9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgbGV0IG91dEJ1ZmY7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgb3V0QnVmZiA9IG5ldyBCaWdCdWZmZXIoYS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRCdWZmID0gbmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcD0wO1xuICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0QnVmZi5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgcCArPSByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0QnVmZjtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/groth16_prove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/groth16_verify.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/groth16_verify.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Verify)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl92ZXJpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzQztBQUNBO0FBQ0U7QUFDeEMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X3ZlcmlmeS5qcz84ZDI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qIEltcGxlbWVudGF0aW9uIG9mIHRoaXMgcGFwZXI6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTYvMjYwLnBkZiAqL1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgIHV0aWxzIH0gICBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBncm90aDE2VmVyaWZ5KF92a192ZXJpZmllciwgX3B1YmxpY1NpZ25hbHMsIF9wcm9vZiwgbG9nZ2VyKSB7XG4vKlxuICAgIGxldCBjcHViID0gdmtfdmVyaWZpZXIuSUNbMF07XG4gICAgZm9yIChsZXQgcz0gMDsgczwgdmtfdmVyaWZpZXIublB1YmxpYzsgcysrKSB7XG4gICAgICAgIGNwdWIgID0gRzEuYWRkKCBjcHViLCBHMS50aW1lc1NjYWxhciggdmtfdmVyaWZpZXIuSUNbcysxXSwgcHVibGljU2lnbmFsc1tzXSkpO1xuICAgIH1cbiovXG5cbiAgICBjb25zdCB2a192ZXJpZmllciA9IHVuc3RyaW5naWZ5QmlnSW50cyhfdmtfdmVyaWZpZXIpO1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IElDMCA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIuSUNbMF0pO1xuICAgIGNvbnN0IElDID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyICogcHVibGljU2lnbmFscy5sZW5ndGgpO1xuICAgIGNvbnN0IHcgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCAqIHB1YmxpY1NpZ25hbHMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZQID0gY3VydmUuRzEuZnJvbU9iamVjdCh2a192ZXJpZmllci5JQ1tpKzFdKTtcbiAgICAgICAgSUMuc2V0KGJ1ZmZQLCBpKmN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIFNjYWxhci50b1JwckxFKHcsIGN1cnZlLkZyLm44KmksIHB1YmxpY1NpZ25hbHNbaV0sIGN1cnZlLkZyLm44KTtcbiAgICB9XG5cbiAgICBsZXQgY3B1YiA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKElDLCB3KTtcbiAgICBjcHViID0gY3VydmUuRzEuYWRkKGNwdWIsIElDMCk7XG5cbiAgICBjb25zdCBwaV9hID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9hKTtcbiAgICBjb25zdCBwaV9iID0gY3VydmUuRzIuZnJvbU9iamVjdChwcm9vZi5waV9iKTtcbiAgICBjb25zdCBwaV9jID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9jKTtcblxuICAgIGNvbnN0IHZrX2dhbW1hXzIgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLnZrX2dhbW1hXzIpO1xuICAgIGNvbnN0IHZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLnZrX2RlbHRhXzIpO1xuICAgIGNvbnN0IHZrX2FscGhhXzEgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLnZrX2FscGhhXzEpO1xuICAgIGNvbnN0IHZrX2JldGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYmV0YV8yKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnBhaXJpbmdFcShcbiAgICAgICAgY3VydmUuRzEubmVnKHBpX2EpICwgcGlfYixcbiAgICAgICAgY3B1YiAsIHZrX2dhbW1hXzIsXG4gICAgICAgIHBpX2MgLCB2a19kZWx0YV8yLFxuXG4gICAgICAgIHZrX2FscGhhXzEsIHZrX2JldGFfMlxuICAgICk7XG5cbiAgICBpZiAoISByZXMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBwcm9vZlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiT0shXCIpO1xuICAgIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/groth16_verify.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/keypair.js":
/*!******************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/keypair.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeltaKey: () => (/* binding */ createDeltaKey),\n/* harmony export */   createPTauKey: () => (/* binding */ createPTauKey),\n/* harmony export */   getG2sp: () => (/* binding */ getG2sp),\n/* harmony export */   hashToG2: () => (/* binding */ hashToG2)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nfunction createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMva2V5cGFpci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVtQzs7QUFFRzs7QUFFL0I7QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQSxvQkFBb0IsZ0RBQU07O0FBRTFCOztBQUVBO0FBQ0E7O0FBRU87O0FBRVAsY0FBYyx5Q0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMva2V5cGFpci5qcz82ZDBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBibGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcblxuaW1wb3J0IHsgQ2hhQ2hhIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvRzIoY3VydmUsIGhhc2gpIHtcbiAgICBjb25zdCBoYXNoViA9IG5ldyBEYXRhVmlldyhoYXNoLmJ1ZmZlciwgaGFzaC5ieXRlT2Zmc2V0LCBoYXNoLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHNlZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgIHNlZWRbaV0gPSBoYXNoVi5nZXRVaW50MzIoaSo0KTtcbiAgICB9XG5cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgY29uc3QgZzJfc3AgPSBjdXJ2ZS5HMi5mcm9tUm5nKHJuZyk7XG5cbiAgICByZXR1cm4gZzJfc3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHMnNwKGN1cnZlLCBwZXJzaW5hbGl6YXRpb24sIGNoYWxsZW5nZSwgZzFzLCBnMXN4KSB7XG5cbiAgICBjb25zdCBoID0gYmxha2UyYig2NCk7XG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShbcGVyc2luYWxpemF0aW9uXSk7XG4gICAgaC51cGRhdGUoYjEpO1xuICAgIGgudXBkYXRlKGNoYWxsZW5nZSk7XG4gICAgY29uc3QgYjMgPSBjdXJ2ZS5HMS50b1VuY29tcHJlc3NlZChnMXMpO1xuICAgIGgudXBkYXRlKCBiMyk7XG4gICAgY29uc3QgYjQgPSBjdXJ2ZS5HMS50b1VuY29tcHJlc3NlZChnMXN4KTtcbiAgICBoLnVwZGF0ZSggYjQpO1xuICAgIGNvbnN0IGhhc2ggPWguZGlnZXN0KCk7XG5cbiAgICByZXR1cm4gaGFzaFRvRzIoY3VydmUsIGhhc2gpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQdWJLZXkoaywgY3VydmUsIHBlcnNvbmFsaXphdGlvbiwgY2hhbGxlbmdlSGFzaCwgcm5nICkge1xuICAgIGsuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgay5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoay5nMV9zLCBrLnBydktleSkpO1xuICAgIGsuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShnZXRHMnNwKGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIGsuZzFfcywgay5nMV9zeCkpO1xuICAgIGsuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihrLmcyX3NwLCBrLnBydktleSkpO1xuICAgIHJldHVybiBrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUFRhdUtleShjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgcm5nKSB7XG4gICAgY29uc3Qga2V5ID0ge1xuICAgICAgICB0YXU6IHt9LFxuICAgICAgICBhbHBoYToge30sXG4gICAgICAgIGJldGE6IHt9XG4gICAgfTtcbiAgICBrZXkudGF1LnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBrZXkuYWxwaGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGtleS5iZXRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjYWxjdWxhdGVQdWJLZXkoa2V5LnRhdSwgY3VydmUsIDAsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS5hbHBoYSwgY3VydmUsIDEsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS5iZXRhLCBjdXJ2ZSwgMiwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcbiAgICByZXR1cm4ga2V5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVsdGFLZXkoY3VydmUsIHRyYW5zY3JpcHQsIHJuZykge1xuICAgIGNvbnN0IGRlbHRhID0ge307XG4gICAgZGVsdGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNTY2FsYXIoZGVsdGEuZzFfcywgZGVsdGEucHJ2S2V5KSk7XG4gICAgZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgdHJhbnNjcmlwdCk7XG4gICAgZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNTY2FsYXIoZGVsdGEuZzJfc3AsIGRlbHRhLnBydktleSkpO1xuICAgIHJldHVybiBkZWx0YTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/keypair.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/loadsyms.js":
/*!*******************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/loadsyms.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadSymbols)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbG9hZHN5bXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxQzs7QUFFdEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbG9hZHN5bXMuanM/YTlhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbG9hZFN5bWJvbHMoc3ltRmlsZU5hbWUpIHtcbiAgICBjb25zdCBzeW0gPSB7XG4gICAgICAgIGxhYmVsSWR4Mk5hbWU6IFsgXCJvbmVcIiBdLFxuICAgICAgICB2YXJJZHgyTmFtZTogWyBcIm9uZVwiIF0sXG4gICAgICAgIGNvbXBvbmVudElkeDJOYW1lOiBbXVxuICAgIH07XG4gICAgY29uc3QgZmQgPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3Rpbmcoc3ltRmlsZU5hbWUpO1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGZkLnRvdGFsU2l6ZSk7XG4gICAgY29uc3Qgc3ltc1N0ciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShidWZmKTtcbiAgICBjb25zdCBsaW5lcyA9IHN5bXNTdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChsZXQgaT0wOyBpPGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGxpbmVzW2ldLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGFyci5sZW5ndGghPTQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoc3ltLnZhcklkeDJOYW1lW2FyclsxXV0pIHtcbiAgICAgICAgICAgIHN5bS52YXJJZHgyTmFtZVthcnJbMV1dICs9IFwifFwiICsgYXJyWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ltLnZhcklkeDJOYW1lW2FyclsxXV0gPSBhcnJbM107XG4gICAgICAgIH1cbiAgICAgICAgc3ltLmxhYmVsSWR4Mk5hbWVbYXJyWzBdXSA9IGFyclszXTtcbiAgICAgICAgaWYgKCFzeW0uY29tcG9uZW50SWR4Mk5hbWVbYXJyWzJdXSkge1xuICAgICAgICAgICAgc3ltLmNvbXBvbmVudElkeDJOYW1lW2FyclsyXV0gPSBleHRyYWN0Q29tcG9uZW50KGFyclszXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHN5bTtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RDb21wb25lbnQobmFtZSkge1xuICAgICAgICBjb25zdCBhcnIgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgYXJyLnBvcCgpOyAvLyBSZW1vdmUgdGhlIGxhc3IgZWxlbWVudFxuICAgICAgICByZXR1cm4gYXJyLmpvaW4oXCIuXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/loadsyms.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/misc.js":
/*!***************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/misc.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askEntropy: () => (/* binding */ askEntropy),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   byteArray2hex: () => (/* binding */ byteArray2hex),\n/* harmony export */   cloneHasher: () => (/* binding */ cloneHasher),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   getRandomRng: () => (/* binding */ getRandomRng),\n/* harmony export */   hashIsEqual: () => (/* binding */ hashIsEqual),\n/* harmony export */   hex2ByteArray: () => (/* binding */ hex2ByteArray),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   rngFromBeaconParams: () => (/* binding */ rngFromBeaconParams),\n/* harmony export */   sameRatio: () => (/* binding */ sameRatio),\n/* harmony export */   stringifyBigIntsWithField: () => (/* binding */ stringifyBigIntsWithField)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\n\n\n\n\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    const ph = h.getPartialHash();\n    const res = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    res.setPartialHash(ph);\n    return res;\n}\n\nasync function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    if (false) {} else {\n        const rl = readline__WEBPACK_IMPORTED_MODULE_1__.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    hasher.update(crypto__WEBPACK_IMPORTED_MODULE_3__.randomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = Buffer.from(hasher.digest());\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = hash.readUInt32BE(i*4);\n    }\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.ChaCha(seed);\n    return rng;\n}\n\nfunction rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = crypto__WEBPACK_IMPORTED_MODULE_3__.createHash(\"sha256\").update(curHash).digest();\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbWlzYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtQztBQUNIO0FBQ007QUFDVjs7QUFFNUI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsZ0JBQWdCLHlDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1AsUUFBUSxLQUFlLEVBQUUsRUFFcEIsQ0FBQztBQUNOLG1CQUFtQixxREFBd0I7QUFDM0M7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQU87QUFDMUIsa0JBQWtCLCtDQUFrQjtBQUNwQyxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQU07QUFDMUI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QyxzQkFBc0Isb0JBQW9CO0FBQzFDLHNCQUFzQiw4Q0FBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQSxvQkFBb0IsZ0RBQU07O0FBRTFCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9taXNjLmpzPzRlNzUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0IHJlYWRsaW5lIGZyb20gXCJyZWFkbGluZVwiO1xuaW1wb3J0IHsgQ2hhQ2hhIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmNvbnN0IF9yZXZUYWJsZSA9IFtdO1xuZm9yIChsZXQgaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPTA7XG4gICAgbGV0IGEgPSBpZHg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpdHM7IGkrKykge1xuICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgIHJlcyA9IHJlcyB8IChhICYxKTtcbiAgICAgICAgYSA+Pj0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0UmV2ZXJzZShpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4RkZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2goYiwgdGl0bGUpIHtcbiAgICBjb25zdCBhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IFMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgaWYgKGk+MCkgUyArPSBcIlxcblwiO1xuICAgICAgICBTICs9IFwiXFx0XFx0XCI7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajw0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqPjApIFMgKz0gXCIgXCI7XG4gICAgICAgICAgICBTICs9IGEuZ2V0VWludDMyKGkqMTYraio0KS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkgUyA9IHRpdGxlICsgXCJcXG5cIiArIFM7XG4gICAgcmV0dXJuIFM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoSXNFcXVhbChoMSwgaDIpIHtcbiAgICBpZiAoaDEuYnl0ZUxlbmd0aCAhPSBoMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGR2MSA9IG5ldyBJbnQ4QXJyYXkoaDEpO1xuICAgIHZhciBkdjIgPSBuZXcgSW50OEFycmF5KGgyKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgIT0gaDEuYnl0ZUxlbmd0aCA7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChkdjFbaV0gIT0gZHYyW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVIYXNoZXIoaCkge1xuICAgIGNvbnN0IHBoID0gaC5nZXRQYXJ0aWFsSGFzaCgpO1xuICAgIGNvbnN0IHJlcyA9IEJsYWtlMmIoNjQpO1xuICAgIHJlcy5zZXRQYXJ0aWFsSGFzaChwaCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhbWVSYXRpbyhjdXJ2ZSwgZzFzLCBnMXN4LCBnMnMsIGcyc3gpIHtcbiAgICBpZiAoY3VydmUuRzEuaXNaZXJvKGcxcykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzEuaXNaZXJvKGcxc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGN1cnZlLkcyLmlzWmVybyhnMnMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGN1cnZlLkcyLmlzWmVybyhnMnN4KSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIHJldHVybiBjdXJ2ZS5GMTIuZXEoY3VydmUucGFpcmluZyhnMXMsIGcyc3gpLCBjdXJ2ZS5wYWlyaW5nKGcxc3gsIGcycykpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnBhaXJpbmdFcShnMXMsIGcyc3gsIGN1cnZlLkcxLm5lZyhnMXN4KSwgZzJzKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhc2tFbnRyb3B5KCkge1xuICAgIGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wcm9tcHQoXCJFbnRlciBhIHJhbmRvbSB0ZXh0LiAoRW50cm9weSk6IFwiLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBybCA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZSh7XG4gICAgICAgICAgICBpbnB1dDogcHJvY2Vzcy5zdGRpbixcbiAgICAgICAgICAgIG91dHB1dDogcHJvY2Vzcy5zdGRvdXRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBybC5xdWVzdGlvbihcIkVudGVyIGEgcmFuZG9tIHRleHQuIChFbnRyb3B5KTogXCIsIChpbnB1dCkgPT4gcmVzb2x2ZShpbnB1dCkgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmFuZG9tUm5nKGVudHJvcHkpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBSbmdcbiAgICB3aGlsZSAoIWVudHJvcHkpIHtcbiAgICAgICAgZW50cm9weSA9IGF3YWl0IGFza0VudHJvcHkoKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgaGFzaGVyLnVwZGF0ZShjcnlwdG8ucmFuZG9tQnl0ZXMoNjQpKTtcbiAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTsgLy8gYWx3YXlzIHV0Zi04XG4gICAgaGFzaGVyLnVwZGF0ZShlbmMuZW5jb2RlKGVudHJvcHkpKTtcbiAgICBjb25zdCBoYXNoID0gQnVmZmVyLmZyb20oaGFzaGVyLmRpZ2VzdCgpKTtcblxuICAgIGNvbnN0IHNlZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7aTw4O2krKykge1xuICAgICAgICBzZWVkW2ldID0gaGFzaC5yZWFkVUludDMyQkUoaSo0KTtcbiAgICB9XG4gICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcbiAgICByZXR1cm4gcm5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKSB7XG4gICAgbGV0IG5JdGVyYXRpb25zSW5uZXI7XG4gICAgbGV0IG5JdGVyYXRpb25zT3V0ZXI7XG4gICAgaWYgKG51bUl0ZXJhdGlvbnNFeHA8MzIpIHtcbiAgICAgICAgbkl0ZXJhdGlvbnNJbm5lciA9ICgxIDw8IG51bUl0ZXJhdGlvbnNFeHApID4+PiAwO1xuICAgICAgICBuSXRlcmF0aW9uc091dGVyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuSXRlcmF0aW9uc0lubmVyID0gMHgxMDAwMDAwMDA7XG4gICAgICAgIG5JdGVyYXRpb25zT3V0ZXIgPSAoMSA8PCAobnVtSXRlcmF0aW9uc0V4cC0zMikpID4+PiAwO1xuICAgIH1cblxuICAgIGxldCBjdXJIYXNoID0gYmVhY29uSGFzaDtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkl0ZXJhdGlvbnNPdXRlcjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxuSXRlcmF0aW9uc0lubmVyOyBqKyspIHtcbiAgICAgICAgICAgIGN1ckhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoY3VySGFzaCkuZGlnZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjdXJIYXNoViA9IG5ldyBEYXRhVmlldyhjdXJIYXNoLmJ1ZmZlciwgY3VySGFzaC5ieXRlT2Zmc2V0LCBjdXJIYXNoLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHNlZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgIHNlZWRbaV0gPSBjdXJIYXNoVi5nZXRVaW50MzIoaSo0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcblxuICAgIHJldHVybiBybmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXgyQnl0ZUFycmF5KHMpIHtcbiAgICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBzO1xuICAgIGlmIChzLnNsaWNlKDAsMikgPT0gXCIweFwiKSBzPSBzLnNsaWNlKDIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzLm1hdGNoKC9bXFxkYS1mXXsyfS9naSkubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChoLCAxNik7XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZUFycmF5MmhleChieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGJ5dGVBcnJheSwgZnVuY3Rpb24oYnl0ZSkge1xuICAgICAgICByZXR1cm4gKFwiMFwiICsgKGJ5dGUgJiAweEZGKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChGciwgbykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgVWludDhBcnJheSkgIHtcbiAgICAgICAgcmV0dXJuIEZyLnRvU3RyaW5nKG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICByZXR1cm4gby5tYXAoc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZC5iaW5kKG51bGwsIEZyKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCggKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIG9ba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YobykgPT0gXCJiaWdpbnRcIikgfHwgby5lcSAhPT0gdW5kZWZpbmVkKSAge1xuICAgICAgICByZXR1cm4gby50b1N0cmluZygxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/misc.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/mpc_applykey.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyKeyToChallengeSection: () => (/* binding */ applyKeyToChallengeSection),\n/* harmony export */   applyKeyToSection: () => (/* binding */ applyKeyToSection)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the pooints in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections,idSection );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHVFQUFtQztBQUM3QyxVQUFVLGtFQUE4Qjs7QUFFeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0VBQTRCO0FBQ3RDLFVBQVUsK0RBQTJCO0FBQ3JDOzs7O0FBSU87QUFDUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsaURBQWlELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9tcGNfYXBwbHlrZXkuanM/NTFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcblxuLypcbiAgICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgc2VjdGlvbiBpbiB0aGUgZmRUbyBmaWxlIHdpdGggaWQgaWRTZWN0aW9uLlxuICAgIEl0IG11bHRpcGxpZXMgdGhlIHBvb2ludHMgaW4gZmRGcm9tIGJ5IGZpcnN0LCBmaXJzdCppbmMsIGZpcnN0KmluY14yLCAuLi4uXG4gICAgblBvaW50IFRpbWVzLlxuICAgIEl0IGFsc28gdXBkYXRlcyB0aGUgbmV3Q2hhbGxlbmdlSGFzaGVyIHdpdGggdGhlIG5ldyBwb2ludHNcbiovXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCBpZFNlY3Rpb24sIGN1cnZlLCBncm91cE5hbWUsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMTY7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBuUG9pbnRzID0gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsaWRTZWN0aW9uICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBpZFNlY3Rpb24pO1xuXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleTogJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihuUG9pbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgYnVmZiA9IGF3YWl0IGZkT2xkLnJlYWQobipzRyk7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZiwgdCwgaW5jKTtcbiAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgIH1cblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCk7XG59XG5cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRPbGQsIGZkTmV3LCByZXNwb25zZUhhc2hlciwgY3VydmUsIGdyb3VwTmFtZSwgblBvaW50cywgZmlyc3QsIGluYywgZm9ybWF0T3V0LCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmZsb29yKCgxPDwyMCkgLyBzRyk7ICAgLy8gMTI4TWIgY2h1bmtzXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTAgOyBpPG5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQXBwbHlpbmcga2V5ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cy1pLCBjaHVua1NpemUgKTtcbiAgICAgICAgY29uc3QgYnVmZkluVSA9IGF3YWl0IGZkT2xkLnJlYWQobiAqIHNHKTtcbiAgICAgICAgY29uc3QgYnVmZkluTEVNID0gYXdhaXQgRy5iYXRjaFV0b0xFTShidWZmSW5VKTtcbiAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW5MRU0sIHQsIGluYyk7XG4gICAgICAgIGxldCBidWZmT3V0O1xuICAgICAgICBpZiAoZm9ybWF0T3V0ID09IFwiQ09NUFJFU1NFRFwiKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvQyhidWZmT3V0TEVNKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZPdXRMRU0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlSGFzaGVyKSByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk.js":
/*!****************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_setup.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_setup.js\");\n/* harmony import */ var _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plonk_fullprove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_fullprove.js\");\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plonk_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plonk_verify.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_verify.js\");\n/* harmony import */ var _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plonk_exportsoliditycalldata.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWtEO0FBQ1E7QUFDUjtBQUNFO0FBQ2dDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanM/OGRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgc2V0dXB9IGZyb20gXCIuL3Bsb25rX3NldHVwLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZnVsbFByb3ZlfSBmcm9tIFwiLi9wbG9ua19mdWxscHJvdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwcm92ZX0gZnJvbSBcIi4vcGxvbmtfcHJvdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnl9IGZyb20gXCIuL3Bsb25rX3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydFNvbGlkaXR5Q2FsbERhdGF9IGZyb20gXCIuL3Bsb25rX2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_equation.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_equation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFFlonkAdditionConstraint: () => (/* binding */ getFFlonkAdditionConstraint),\n/* harmony export */   getFFlonkConstantConstraint: () => (/* binding */ getFFlonkConstantConstraint),\n/* harmony export */   getFFlonkMultiplicationConstraint: () => (/* binding */ getFFlonkMultiplicationConstraint)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXF1YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXF1YXRpb24uanM/ODU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBXZSBleHBvcnQgdG8gemtleSB0aGUgc2lnbmFscyBhbmQgdmFsdWVzIG9mIHRoZSBhLCBiLCBjLCBxbCwgcXIsIHFtLCBxbyBhbmQgcWNcblxuLy8gYSwgYiBhbmQgYyBhcmUgc2lnbmFscyBpZCAoMzItYml0IGludGVnZXJzKVxuLy8gcWwsIHFyLCBxbSwgcW8gYW5kIHFjIGFyZSBmaWVsZCB2YWx1ZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludChzaWduYWwxLCBGcikge1xuICAgIHJldHVybiBbc2lnbmFsMSwgMCwgMCwgRnIub25lLCBGci56ZXJvLCBGci56ZXJvLCBGci56ZXJvLCBGci56ZXJvXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZGbG9ua0FkZGl0aW9uQ29uc3RyYWludChzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxYykge1xuICAgIHJldHVybiBbc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50KHNpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjLCBGcikge1xuICAgIHJldHVybiBbc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWNdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_equation.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    const proofBuff = new Uint8Array(G1.F.n8*2*9 + Fr.n8*7);\n    G1.toRprUncompressed(proofBuff, 0, G1.e(proof.A));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*2, G1.e(proof.B));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*4, G1.e(proof.C));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*6, G1.e(proof.Z));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*8, G1.e(proof.T1));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*10, G1.e(proof.T2));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*12, G1.e(proof.T3));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*14, G1.e(proof.Wxi));\n    G1.toRprUncompressed(proofBuff, G1.F.n8*16, G1.e(proof.Wxiw));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 , Fr.e(proof.eval_a));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8, Fr.e(proof.eval_b));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*2, Fr.e(proof.eval_c));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*3, Fr.e(proof.eval_s1));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*4, Fr.e(proof.eval_s2));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*5, Fr.e(proof.eval_zw));\n    Fr.toRprBE(proofBuff, G1.F.n8*18 + Fr.n8*6, Fr.e(proof.eval_r));\n\n    const proofHex = Array.from(proofBuff).map(i2hex).join(\"\");\n\n    const S=\"0x\"+proofHex+\",[\"+inputs+\"]\";\n\n    return S;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUrQztBQUNQO0FBQ3hDLFFBQVEsb0JBQW9CLEVBQUUsK0NBQUs7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQSx3QkFBd0IsNERBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcz8yMDliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGdldEN1cnZlRnJvbU5hbWUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIGkyaGV4KGkpIHtcbiAgICByZXR1cm4gKFwiMFwiICsgaS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbn1cblxuZnVuY3Rpb24gcDI1NihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiK25zdHI7XG4gICAgbnN0ciA9IGBcIjB4JHtuc3RyfVwiYDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtFeHBvcnRTb2xpZGl0eUNhbGxEYXRhKF9wcm9vZiwgX3B1Yikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgaW5wdXRzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpPTA7IGk8cHViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dHMgIT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9vZkJ1ZmYgPSBuZXcgVWludDhBcnJheShHMS5GLm44KjIqOSArIEZyLm44KjcpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHByb29mQnVmZiwgMCwgRzEuZShwcm9vZi5BKSk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQocHJvb2ZCdWZmLCBHMS5GLm44KjIsIEcxLmUocHJvb2YuQikpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHByb29mQnVmZiwgRzEuRi5uOCo0LCBHMS5lKHByb29mLkMpKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZChwcm9vZkJ1ZmYsIEcxLkYubjgqNiwgRzEuZShwcm9vZi5aKSk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQocHJvb2ZCdWZmLCBHMS5GLm44KjgsIEcxLmUocHJvb2YuVDEpKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZChwcm9vZkJ1ZmYsIEcxLkYubjgqMTAsIEcxLmUocHJvb2YuVDIpKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZChwcm9vZkJ1ZmYsIEcxLkYubjgqMTIsIEcxLmUocHJvb2YuVDMpKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZChwcm9vZkJ1ZmYsIEcxLkYubjgqMTQsIEcxLmUocHJvb2YuV3hpKSk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQocHJvb2ZCdWZmLCBHMS5GLm44KjE2LCBHMS5lKHByb29mLld4aXcpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCoxOCAsIEZyLmUocHJvb2YuZXZhbF9hKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjgqMTggKyBGci5uOCwgRnIuZShwcm9vZi5ldmFsX2IpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCoxOCArIEZyLm44KjIsIEZyLmUocHJvb2YuZXZhbF9jKSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjgqMTggKyBGci5uOCozLCBGci5lKHByb29mLmV2YWxfczEpKTtcbiAgICBGci50b1JwckJFKHByb29mQnVmZiwgRzEuRi5uOCoxOCArIEZyLm44KjQsIEZyLmUocHJvb2YuZXZhbF9zMikpO1xuICAgIEZyLnRvUnByQkUocHJvb2ZCdWZmLCBHMS5GLm44KjE4ICsgRnIubjgqNSwgRnIuZShwcm9vZi5ldmFsX3p3KSk7XG4gICAgRnIudG9ScHJCRShwcm9vZkJ1ZmYsIEcxLkYubjgqMTggKyBGci5uOCo2LCBGci5lKHByb29mLmV2YWxfcikpO1xuXG4gICAgY29uc3QgcHJvb2ZIZXggPSBBcnJheS5mcm9tKHByb29mQnVmZikubWFwKGkyaGV4KS5qb2luKFwiXCIpO1xuXG4gICAgY29uc3QgUz1cIjB4XCIrcHJvb2ZIZXgrXCIsW1wiK2lucHV0cytcIl1cIjtcblxuICAgIHJldHVybiBTO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_fullprove.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_fullprove.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_prove.js */ \"(rsc)/../backend/node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns);\n    return await (0,_plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZnVsbHByb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUyQztBQUNNO0FBQ2Q7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFjO0FBQ3hCLGlCQUFpQiwyREFBVztBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2Z1bGxwcm92ZS5qcz9iMWU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBwbG9ua19wcm92ZSBmcm9tIFwiLi9wbG9ua19wcm92ZS5qc1wiO1xuaW1wb3J0IHd0bnNfY2FsY3VsYXRlIGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9ua0Z1bGxQcm92ZShfaW5wdXQsIHdhc21GaWxlLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7XG4gICAgICAgIHR5cGU6IFwibWVtXCJcbiAgICB9O1xuICAgIGF3YWl0IHd0bnNfY2FsY3VsYXRlKGlucHV0LCB3YXNtRmlsZSwgd3Rucyk7XG4gICAgcmV0dXJuIGF3YWl0IHBsb25rX3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_fullprove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_prove.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_prove.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonk16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-sha3 */ \"(rsc)/../backend/node_modules/js-sha3/src/sha3.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.utils;\n\nconst { keccak256 } = js_sha3__WEBPACK_IMPORTED_MODULE_5__;\n\nasync function plonk16Prove(zkeyFileName, witnessFileName, logger) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*zkey.nAdditions);\n\n    await calculateAdditions();\n\n    let A,B,C,Z;\n    let A4, B4, C4, Z4;\n    let pol_a,pol_b,pol_c, pol_z, pol_t, pol_r;\n    let proof = {};\n\n    const sigmaBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r*4*3);\n    let o = sectionsZKey[12][0].p + zkey.domainSize*n8r;\n    await fdZKey.readToBuffer(sigmaBuff, 0 , zkey.domainSize*n8r*4, o);\n    o += zkey.domainSize*n8r*5;\n    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*4 , zkey.domainSize*n8r*4, o);\n    o += zkey.domainSize*n8r*5;\n    await fdZKey.readToBuffer(sigmaBuff, zkey.domainSize*n8r*8 , zkey.domainSize*n8r*4, o);\n\n    const pol_s1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n    await fdZKey.readToBuffer(pol_s1, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p);\n\n    const pol_s2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n    await fdZKey.readToBuffer(pol_s2, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p + 5*zkey.domainSize*n8r);\n\n    const PTau = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 14);\n\n\n    const ch = {};\n\n    await round1();\n    await round2();\n    await round3();\n    await round4();\n    await round5();\n\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    proof.protocol = \"plonk\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.fromRprLE(pub));\n    }\n\n    proof.A = G1.toObject(proof.A);\n    proof.B = G1.toObject(proof.B);\n    proof.C = G1.toObject(proof.C);\n    proof.Z = G1.toObject(proof.Z);\n\n    proof.T1 = G1.toObject(proof.T1);\n    proof.T2 = G1.toObject(proof.T2);\n    proof.T3 = G1.toObject(proof.T3);\n\n    proof.eval_a = Fr.toObject(proof.eval_a);\n    proof.eval_b = Fr.toObject(proof.eval_b);\n    proof.eval_c = Fr.toObject(proof.eval_c);\n    proof.eval_s1 = Fr.toObject(proof.eval_s1);\n    proof.eval_s2 = Fr.toObject(proof.eval_s2);\n    proof.eval_zw = Fr.toObject(proof.eval_zw);\n    proof.eval_t = Fr.toObject(proof.eval_t);\n    proof.eval_r = Fr.toObject(proof.eval_r);\n\n    proof.Wxi = G1.toObject(proof.Wxi);\n    proof.Wxiw = G1.toObject(proof.Wxiw);\n\n    delete proof.eval_t;\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n\n    async function calculateAdditions() {\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 3);\n\n        const sSum = 8+curve.Fr.n8*2;\n\n        for (let i=0; i<zkey.nAdditions; i++) {\n            const ai= readUInt32(additionsBuff, i*sSum);\n            const bi= readUInt32(additionsBuff, i*sSum+4);\n            const ac= additionsBuff.slice(i*sSum+8, i*sSum+8+n8r);\n            const bc= additionsBuff.slice(i*sSum+8+n8r, i*sSum+8+n8r*2);\n            const aw= getWitness(ai);\n            const bw= getWitness(bi);\n\n            const r = curve.Fr.add(\n                curve.Fr.mul(ac, aw),\n                curve.Fr.mul(bc, bw)\n            );\n            buffInternalWitness.set(r, n8r*i);\n        }\n\n    }\n\n    async function buildABC() {\n        let A = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize * n8r);\n        let B = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize * n8r);\n        let C = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize * n8r);\n\n        const aMap = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 4);\n        const bMap = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n        const cMap = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n\n        for (let i=0; i<zkey.nConstrains; i++) {\n            const iA = readUInt32(aMap, i*4);\n            A.set(getWitness(iA), i*n8r);\n            const iB = readUInt32(bMap, i*4);\n            B.set(getWitness(iB), i*n8r);\n            const iC = readUInt32(cMap, i*4);\n            C.set(getWitness(iC), i*n8r);\n        }\n\n        A = await Fr.batchToMontgomery(A);\n        B = await Fr.batchToMontgomery(B);\n        C = await Fr.batchToMontgomery(C);\n\n        return [A,B,C];\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        ch.b = [];\n        for (let i=1; i<=11; i++) {\n            ch.b[i] = curve.Fr.random();\n        }\n    \n        [A, B, C] = await buildABC();\n\n        [pol_a, A4] = await to4T(A, [ch.b[2], ch.b[1]]);\n        [pol_b, B4] = await to4T(B, [ch.b[4], ch.b[3]]);\n        [pol_c, C4] = await to4T(C, [ch.b[6], ch.b[5]]);\n\n                \n        proof.A = await expTau(pol_a, \"multiexp A\");\n        proof.B = await expTau(pol_b, \"multiexp B\");\n        proof.C = await expTau(pol_c, \"multiexp C\");\n    }\n\n    async function round2() {\n\n        const transcript1 = new Uint8Array(zkey.nPublic*n8r + G1.F.n8*2*3);\n        for (let i=0; i<zkey.nPublic; i++) {\n            Fr.toRprBE(transcript1, i*n8r, A.slice((i)*n8r, (i+1)*n8r));\n        }\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + 0, proof.A);\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*2, proof.B);\n        G1.toRprUncompressed(transcript1, zkey.nPublic*n8r + G1.F.n8*4, proof.C);\n\n        ch.beta = hashToFr(transcript1);\n        if (logger) logger.debug(\"beta: \" + Fr.toString(ch.beta));\n    \n        const transcript2 = new Uint8Array(n8r);\n        Fr.toRprBE(transcript2, 0, ch.beta);\n        ch.gamma = hashToFr(transcript2);\n        if (logger) logger.debug(\"gamma: \" + Fr.toString(ch.gamma));\n    \n        let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(Fr.n8*zkey.domainSize);\n        let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(Fr.n8*zkey.domainSize);\n\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        let w = Fr.one;\n        for (let i=0; i<zkey.domainSize; i++) {\n            let n1 = A.slice(i*n8r, (i+1)*n8r);\n            n1 = Fr.add( n1, Fr.mul(ch.beta, w) );\n            n1 = Fr.add( n1, ch.gamma );\n\n            let n2 = B.slice(i*n8r, (i+1)*n8r);\n            n2 = Fr.add( n2, Fr.mul(zkey.k1, Fr.mul(ch.beta, w) ));\n            n2 = Fr.add( n2, ch.gamma );\n\n            let n3 = C.slice(i*n8r, (i+1)*n8r);\n            n3 = Fr.add( n3, Fr.mul(zkey.k2, Fr.mul(ch.beta, w) ));\n            n3 = Fr.add( n3, ch.gamma );\n\n            const num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            let d1 = A.slice(i*n8r, (i+1)*n8r);\n            d1 = Fr.add(d1, Fr.mul( sigmaBuff.slice(i*n8r*4, i*n8r*4 + n8r) , ch.beta));\n            d1 = Fr.add(d1, ch.gamma);\n\n            let d2 = B.slice(i*n8r, (i+1)*n8r);\n            d2 = Fr.add(d2, Fr.mul( sigmaBuff.slice((zkey.domainSize + i)*4*n8r, (zkey.domainSize + i)*4*n8r+n8r) , ch.beta));\n            d2 = Fr.add(d2, ch.gamma);\n\n            let d3 = C.slice(i*n8r, (i+1)*n8r);\n            d3 = Fr.add(d3, Fr.mul( sigmaBuff.slice((zkey.domainSize*2 + i)*4*n8r, (zkey.domainSize*2 + i)*4*n8r + n8r) , ch.beta));\n            d3 = Fr.add(d3, ch.gamma);\n\n            const den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            numArr.set(  \n                Fr.mul( \n                    numArr.slice(i*n8r,(i+1)*n8r) , \n                    num\n                ),\n                ((i+1)%zkey.domainSize)*n8r\n            );\n\n            denArr.set(  \n                Fr.mul( \n                    denArr.slice(i*n8r,(i+1)*n8r) , \n                    den\n                ),\n                ((i+1)%zkey.domainSize)*n8r\n            );\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        for (let i=0; i<zkey.domainSize; i++) {\n            numArr.set(   Fr.mul( numArr.slice(i*n8r, (i+1)*n8r), denArr.slice(i*n8r, (i+1)*n8r) )      ,i*n8r);\n        }\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        Z = numArr;\n\n        [pol_z, Z4] = await to4T(Z, [ch.b[9], ch.b[8], ch.b[7]]);\n\n        proof.Z = await expTau( pol_z, \"multiexp Z\");\n    }\n\n    async function round3() {\n\n        /*\n        async function checkDegree(P) {\n            const p = await curve.Fr.ifft(P);\n            let deg = (P.byteLength/n8r)-1;\n            while ((deg>0)&&(Fr.isZero(p.slice(deg*n8r, deg*n8r+n8r)))) deg--;\n            return deg;\n        }\n\n        function printPol(P) {\n            const n=(P.byteLength/n8r);\n            console.log(\"[\");\n            for (let i=0; i<n; i++) {\n                console.log(Fr.toString(P.slice(i*n8r, i*n8r+n8r)));\n            }\n            console.log(\"]\");\n        }\n        */\n\n        if (logger) logger.debug(\"phse3: Reading QM4\");    \n        const QM4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QM4, 0 , zkey.domainSize*n8r*4, sectionsZKey[7][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QL4\");    \n        const QL4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QL4, 0 , zkey.domainSize*n8r*4, sectionsZKey[8][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QR4\");    \n        const QR4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QR4, 0 , zkey.domainSize*n8r*4, sectionsZKey[9][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QO4\");    \n        const QO4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QO4, 0 , zkey.domainSize*n8r*4, sectionsZKey[10][0].p + zkey.domainSize*n8r);\n\n        if (logger) logger.debug(\"phse3: Reading QC4\");    \n        const QC4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        await fdZKey.readToBuffer(QC4, 0 , zkey.domainSize*n8r*4, sectionsZKey[11][0].p + zkey.domainSize*n8r);\n\n        const lPols = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 13);\n\n        const transcript3 = new Uint8Array(G1.F.n8*2);\n        G1.toRprUncompressed(transcript3, 0, proof.Z);\n\n        ch.alpha = hashToFr(transcript3);\n\n        if (logger) logger.debug(\"alpha: \" + Fr.toString(ch.alpha));    \n\n\n        const Z1 = [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n\n        const Z2 = [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n\n        const Z3 = [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n        const T = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n        const Tz = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*4*n8r);\n\n        let w = Fr.one;\n        for (let i=0; i<zkey.domainSize*4; i++) {\n            if ((i%4096 == 0)&&(logger)) logger.debug(`calculating t ${i}/${zkey.domainSize*4}`);\n\n            const a = A4.slice(i*n8r, i*n8r+n8r);\n            const b = B4.slice(i*n8r, i*n8r+n8r);\n            const c = C4.slice(i*n8r, i*n8r+n8r);\n            const z = Z4.slice(i*n8r, i*n8r+n8r);\n            const zw = Z4.slice(((i+zkey.domainSize*4+4)%(zkey.domainSize*4)) *n8r, ((i+zkey.domainSize*4+4)%(zkey.domainSize*4)) *n8r +n8r);\n            const qm = QM4.slice(i*n8r, i*n8r+n8r);\n            const ql = QL4.slice(i*n8r, i*n8r+n8r);\n            const qr = QR4.slice(i*n8r, i*n8r+n8r);\n            const qo = QO4.slice(i*n8r, i*n8r+n8r);\n            const qc = QC4.slice(i*n8r, i*n8r+n8r);\n            const s1 = sigmaBuff.slice(i*n8r, i*n8r+n8r);\n            const s2 = sigmaBuff.slice((i+zkey.domainSize*4)*n8r, (i+zkey.domainSize*4)*n8r+n8r);\n            const s3 = sigmaBuff.slice((i+zkey.domainSize*8)*n8r, (i+zkey.domainSize*8)*n8r+n8r);\n            const ap = Fr.add(ch.b[2], Fr.mul(ch.b[1], w));\n            const bp = Fr.add(ch.b[4], Fr.mul(ch.b[3], w));\n            const cp = Fr.add(ch.b[6], Fr.mul(ch.b[5], w));\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(ch.b[7], w2), Fr.mul(ch.b[8], w)), ch.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(ch.b[7], wW2), Fr.mul(ch.b[8], wW)), ch.b[9]);\n\n            let pl = Fr.zero;\n            for (let j=0; j<zkey.nPublic; j++) {\n                pl = Fr.sub(pl, Fr.mul( \n                    lPols.slice( (j*5*zkey.domainSize+ zkey.domainSize+ i)*n8r, (j*5*zkey.domainSize+ zkey.domainSize + i+1)*n8r),\n                    A.slice(j*n8r, (j+1)*n8r)\n                ));\n            }\n\n            let [e1, e1z] = mul2(a, b, ap, bp, i%4);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pl);\n            e1 = Fr.add(e1, qc);\n\n            const betaw = Fr.mul(ch.beta, w);\n            let e2a =a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, ch.gamma);\n\n            let e2b =b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, ch.gamma);\n\n            let e2c =c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, ch.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i%4);\n            e2 = Fr.mul(e2, ch.alpha);\n            e2z = Fr.mul(e2z, ch.alpha);\n\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(ch.beta, s1));\n            e3a = Fr.add(e3a, ch.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(ch.beta,s2));\n            e3b = Fr.add(e3b, ch.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(ch.beta,s3));\n            e3c = Fr.add(e3c, ch.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i%4);\n\n            e3 = Fr.mul(e3, ch.alpha);\n            e3z = Fr.mul(e3z, ch.alpha);\n\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, lPols.slice( (zkey.domainSize + i)*n8r, (zkey.domainSize+i+1)*n8r));\n            e4 = Fr.mul(e4, Fr.mul(ch.alpha, ch.alpha));\n\n            let e4z = Fr.mul(zp, lPols.slice( (zkey.domainSize + i)*n8r, (zkey.domainSize+i+1)*n8r));\n            e4z = Fr.mul(e4z, Fr.mul(ch.alpha, ch.alpha));\n\n            let e = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let ez = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            T.set(e, i*n8r);\n            Tz.set(ez, i*n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power+2]);\n        }\n\n        if (logger) logger.debug(\"ifft T\");    \n        let t = await Fr.ifft(T);\n\n        if (logger) logger.debug(\"dividing T/Z\");    \n        for (let i=0; i<zkey.domainSize; i++) {\n            t.set(Fr.neg(t.slice(i*n8r, i*n8r+n8r)), i*n8r);\n        }\n\n        for (let i=zkey.domainSize; i<zkey.domainSize*4; i++) {\n            const a = Fr.sub(\n                t.slice((i-zkey.domainSize)*n8r, (i-zkey.domainSize)*n8r + n8r),\n                t.slice(i*n8r, i*n8r+n8r)\n            );\n            t.set(a, i*n8r);\n            if (i > (zkey.domainSize*3 -4) ) {\n                if (!Fr.isZero(a)) {\n                    throw new Error(\"T Polynomial is not divisible\");\n                }\n            }\n        }\n\n        if (logger) logger.debug(\"ifft Tz\");    \n        const tz = await Fr.ifft(Tz);\n        for (let i=0; i<zkey.domainSize*4; i++) {\n            const a = tz.slice(i*n8r, (i+1)*n8r);\n            if (i > (zkey.domainSize*3 +5) ) {\n                if (!Fr.isZero(a)) {\n                    throw new Error(\"Tz Polynomial is not well calculated\");\n                }\n            } else {\n                t.set(  \n                    Fr.add(\n                        t.slice(i*n8r, (i+1)*n8r),\n                        a\n                    ),\n                    i*n8r\n                );\n            }\n        }\n\n        pol_t = t.slice(0, (zkey.domainSize * 3 + 6) * n8r);\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // t'_low and t'_mid  with a degree < n and t'_high with a degree n+5\n        // such that t(x) = t'_low(X) + X^n t'_mid(X) + X^{2n} t'_hi(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // t_low(X) = t'_low(X) + b_10 X^n\n        // t_mid(X) = t'_mid(X) - b_10 + b_11 X^n\n        // t_high(X) = t'_high(X) - b_11\n        // such that\n        // t(X) = t_low(X) + X^n t_mid(X) + X^2n t_high(X)\n\n        // compute t_low(X)\n        let polTLow = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize + 1) * n8r);\n        polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // Add blinding scalar b_10 as a new coefficient n\n        polTLow.set(ch.b[10], zkey.domainSize * n8r);\n\n        // compute t_mid(X)\n        let polTMid = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize + 1) * n8r);\n        polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        polTMid.set(lowestMid, 0);\n        // Add blinding scalar b_11 as a new coefficient n\n        polTMid.set(ch.b[11], zkey.domainSize * n8r);\n\n        // compute t_high(X)\n        let polTHigh = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize + 6) * n8r);\n        polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        polTHigh.set(lowestHigh, 0);\n\n        proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n\n        function mul2(a,b, ap, bp,  p) {\n            let r, rz;\n\n            \n            const a_b = Fr.mul(a,b);\n            const a_bp = Fr.mul(a,bp);\n            const ap_b = Fr.mul(ap,b);\n            const ap_bp = Fr.mul(ap,bp);\n\n            r = a_b;\n\n            let a0 = Fr.add(a_bp, ap_b);\n\n            let a1 = ap_bp;\n\n            rz = a0;\n            if (p) {\n                rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            }\n\n            return [r, rz];\n        }\n\n        function mul4(a,b,c,d, ap, bp, cp, dp, p) {\n            let r, rz;\n\n            \n            const a_b = Fr.mul(a,b);\n            const a_bp = Fr.mul(a,bp);\n            const ap_b = Fr.mul(ap,b);\n            const ap_bp = Fr.mul(ap,bp);\n\n            const c_d = Fr.mul(c,d);\n            const c_dp = Fr.mul(c,dp);\n            const cp_d = Fr.mul(cp,d);\n            const cp_dp = Fr.mul(cp,dp);\n\n            r = Fr.mul(a_b, c_d);\n\n            let a0 = Fr.mul(ap_b, c_d);\n            a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n            a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n            a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n            let a1 = Fr.mul(ap_bp, c_d);\n            a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n            a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n            a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n            a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n            a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n            let a2 = Fr.mul(a_bp, cp_dp);\n            a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n            a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n            a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n            let a3 = Fr.mul(ap_bp, cp_dp);\n\n            rz = a0;\n            if (p) {\n                rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n                rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n                rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n            }\n\n            return [r, rz];\n        }\n    }\n\n    async function round4() {\n        const pol_qm = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qm, 0 , zkey.domainSize*n8r, sectionsZKey[7][0].p);\n\n        const pol_ql = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_ql, 0 , zkey.domainSize*n8r, sectionsZKey[8][0].p);\n\n        const pol_qr = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qr, 0 , zkey.domainSize*n8r, sectionsZKey[9][0].p);\n\n        const pol_qo = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qo, 0 , zkey.domainSize*n8r, sectionsZKey[10][0].p);\n\n        const pol_qc = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_qc, 0 , zkey.domainSize*n8r, sectionsZKey[11][0].p);\n\n        const pol_s3 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(zkey.domainSize*n8r);\n        await fdZKey.readToBuffer(pol_s3, 0 , zkey.domainSize*n8r, sectionsZKey[12][0].p + 10*zkey.domainSize*n8r);\n\n        const transcript4 = new Uint8Array(G1.F.n8*2*3);\n        G1.toRprUncompressed(transcript4, 0, proof.T1);\n        G1.toRprUncompressed(transcript4, G1.F.n8*2, proof.T2);\n        G1.toRprUncompressed(transcript4, G1.F.n8*4, proof.T3);\n        ch.xi = hashToFr(transcript4);\n\n        if (logger) logger.debug(\"xi: \" + Fr.toString(ch.xi));    \n\n        proof.eval_a = evalPol(pol_a, ch.xi);\n        proof.eval_b = evalPol(pol_b, ch.xi);\n        proof.eval_c = evalPol(pol_c, ch.xi);\n        proof.eval_s1 = evalPol(pol_s1, ch.xi);\n        proof.eval_s2 = evalPol(pol_s2, ch.xi);\n        proof.eval_t = evalPol(pol_t, ch.xi);\n        proof.eval_zw = evalPol(pol_z, Fr.mul(ch.xi, Fr.w[zkey.power]));\n\n        const coef_ab = Fr.mul(proof.eval_a, proof.eval_b);\n        \n        let e2a = proof.eval_a;\n        const betaxi = Fr.mul(ch.beta, ch.xi);\n        e2a = Fr.add( e2a, betaxi);\n        e2a = Fr.add( e2a, ch.gamma);\n\n        let e2b = proof.eval_b;\n        e2b = Fr.add( e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add( e2b, ch.gamma);\n\n        let e2c = proof.eval_c;\n        e2c = Fr.add( e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add( e2c, ch.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), ch.alpha);\n\n        let e3a = proof.eval_a;\n        e3a = Fr.add( e3a, Fr.mul(ch.beta, proof.eval_s1));\n        e3a = Fr.add( e3a, ch.gamma);\n\n        let e3b = proof.eval_b;\n        e3b = Fr.add( e3b, Fr.mul(ch.beta, proof.eval_s2));\n        e3b = Fr.add( e3b, ch.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, ch.beta);\n        e3 = Fr.mul(e3, proof.eval_zw);\n        e3 = Fr.mul(e3, ch.alpha);\n\n        ch.xim= ch.xi;\n        for (let i=0; i<zkey.power; i++) ch.xim = Fr.mul(ch.xim, ch.xim);\n        const eval_l1 = Fr.div(\n            Fr.sub(ch.xim, Fr.one),\n            Fr.mul(Fr.sub(ch.xi, Fr.one), Fr.e(zkey.domainSize))\n        );\n\n        const e4 = Fr.mul(eval_l1, Fr.mul(ch.alpha, ch.alpha));\n\n        const coefs3 = e3;\n        const coefz = Fr.add(e2, e4);\n\n        pol_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize+3)*n8r);\n\n        for (let i = 0; i<zkey.domainSize+3; i++) {\n            let v = Fr.mul(coefz, pol_z.slice(i*n8r,(i+1)*n8r));\n            if (i<zkey.domainSize) {\n                v = Fr.add(v, Fr.mul(coef_ab, pol_qm.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_a, pol_ql.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_b, pol_qr.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, Fr.mul(proof.eval_c, pol_qo.slice(i*n8r,(i+1)*n8r)));\n                v = Fr.add(v, pol_qc.slice(i*n8r,(i+1)*n8r));\n                v = Fr.sub(v, Fr.mul(coefs3, pol_s3.slice(i*n8r,(i+1)*n8r)));\n            }\n            pol_r.set(v, i*n8r);\n        }\n\n        proof.eval_r = evalPol(pol_r, ch.xi);\n    }\n\n    async function round5() {\n        const transcript5 = new Uint8Array(n8r*7);\n        Fr.toRprBE(transcript5, 0, proof.eval_a);\n        Fr.toRprBE(transcript5, n8r, proof.eval_b);\n        Fr.toRprBE(transcript5, n8r*2, proof.eval_c);\n        Fr.toRprBE(transcript5, n8r*3, proof.eval_s1);\n        Fr.toRprBE(transcript5, n8r*4, proof.eval_s2);\n        Fr.toRprBE(transcript5, n8r*5, proof.eval_zw);\n        Fr.toRprBE(transcript5, n8r*6, proof.eval_r);\n        ch.v = [];\n        ch.v[1] = hashToFr(transcript5);\n        if (logger) logger.debug(\"v: \" + Fr.toString(ch.v[1]));    \n\n        for (let i=2; i<=6; i++ ) ch.v[i] = Fr.mul(ch.v[i-1], ch.v[1]);\n        \n        let pol_wxi = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize+6)*n8r);\n\n        const xi2m = Fr.mul(ch.xim, ch.xim);\n\n        for (let i = 0; i < zkey.domainSize + 6; i++) {\n            let w = Fr.zero;\n\n            const polTHigh = pol_t.slice((zkey.domainSize * 2 + i) * n8r, (zkey.domainSize * 2 + i + 1) * n8r);\n            w = Fr.add(w, Fr.mul(xi2m, polTHigh));\n\n            if (i < zkey.domainSize + 3) {\n                w = Fr.add(w, Fr.mul(ch.v[1], pol_r.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            if (i < zkey.domainSize + 2) {\n                w = Fr.add(w, Fr.mul(ch.v[2], pol_a.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[3], pol_b.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[4], pol_c.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            if (i < zkey.domainSize) {\n                const polTLow = pol_t.slice(i * n8r, (i + 1) * n8r);\n                w = Fr.add(w, polTLow);\n\n                const polTMid = pol_t.slice((zkey.domainSize + i) * n8r, (zkey.domainSize + i + 1) * n8r);\n                w = Fr.add(w, Fr.mul(ch.xim, polTMid));\n\n                w = Fr.add(w, Fr.mul(ch.v[5], pol_s1.slice(i * n8r, (i + 1) * n8r)));\n                w = Fr.add(w, Fr.mul(ch.v[6], pol_s2.slice(i * n8r, (i + 1) * n8r)));\n            }\n\n            // b_10 and b_11 blinding scalars were applied on round 3 to randomize the polynomials t_low, t_mid, t_high\n            // Subtract blinding scalar b_10 and b_11 to the lowest coefficient\n            if (i === 0) {\n                w = Fr.sub(w, Fr.mul(xi2m, ch.b[11]));\n                w = Fr.sub(w, Fr.mul(ch.xim, ch.b[10]));\n            }\n\n            // Add blinding scalars b_10 and b_11 to the coefficient n\n            if (i === zkey.domainSize) {\n                w = Fr.add(w, ch.b[10]);\n                w = Fr.add(w, Fr.mul(ch.xim, ch.b[11]));\n            }\n\n            pol_wxi.set(w, i * n8r);\n        }\n\n        let w0 = pol_wxi.slice(0, n8r);\n        w0 = Fr.sub(w0, proof.eval_t);\n        w0 = Fr.sub(w0, Fr.mul(ch.v[1], proof.eval_r));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[2], proof.eval_a));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[3], proof.eval_b));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[4], proof.eval_c));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[5], proof.eval_s1));\n        w0 = Fr.sub(w0, Fr.mul(ch.v[6], proof.eval_s2));\n        pol_wxi.set(w0, 0);\n\n        pol_wxi= divPol1(pol_wxi, ch.xi);\n\n        proof.Wxi = await expTau(pol_wxi, \"multiexp Wxi\");\n\n        let pol_wxiw = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((zkey.domainSize+3)*n8r);\n        for (let i=0; i<zkey.domainSize+3; i++) {\n            const w = pol_z.slice(i*n8r, (i+1)*n8r);\n            pol_wxiw.set(w, i*n8r);\n        }\n        w0 = pol_wxiw.slice(0, n8r);\n        w0 = Fr.sub(w0, proof.eval_zw);\n        pol_wxiw.set(w0, 0);\n\n        pol_wxiw= divPol1(pol_wxiw, Fr.mul(ch.xi, Fr.w[zkey.power]));\n        proof.Wxiw = await expTau(pol_wxiw, \"multiexp Wxiw\");\n    }\n\n    function hashToFr(transcript) {\n        const v = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(transcript)));\n        return Fr.e(v);\n    }\n\n\n    function evalPol(P, x) {\n        const n = P.byteLength / n8r;\n        if (n == 0) return Fr.zero;\n        let res = P.slice((n-1)*n8r, n*n8r);\n        for (let i=n-2; i>=0; i--) {\n            res = Fr.add(Fr.mul(res, x), P.slice(i*n8r, (i+1)*n8r));\n        }\n        return res;\n    }\n\n    function divPol1(P, d) {\n        const n = P.byteLength/n8r;\n        const res = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n*n8r);\n        res.set(Fr.zero, (n-1) *n8r);\n        res.set(P.slice((n-1)*n8r, n*n8r), (n-2)*n8r);\n        for (let i=n-3; i>=0; i--) {\n            res.set(\n                Fr.add(\n                    P.slice((i+1)*n8r, (i+2)*n8r), \n                    Fr.mul(\n                        d, \n                        res.slice((i+1)*n8r, (i+2)*n8r)\n                    )\n                ),\n                i*n8r\n            );\n        }\n        if (!Fr.eq(\n            P.slice(0, n8r),\n            Fr.mul(\n                Fr.neg(d),\n                res.slice(0, n8r)\n            )\n        )) {\n            throw new Error(\"Polinomial does not divide\");\n        }\n        return res;\n    }\n\n    async function expTau(b, name) {\n        const n = b.byteLength/n8r;\n        const PTauN = PTau.slice(0, n*curve.G1.F.n8*2);\n        const bm = await curve.Fr.batchFromMontgomery(b);\n        let res = await curve.G1.multiExpAffine(PTauN, bm, logger, name);\n        res = curve.G1.toAffine(res);\n        return res;\n    }\n\n\n    async function to4T(A, pz) {\n        pz = pz || []; \n        let a = await Fr.ifft(A);\n        const a4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*zkey.domainSize*4);\n        a4.set(a, 0);\n\n        const a1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*(zkey.domainSize + pz.length));\n        a1.set(a, 0);\n        for (let i= 0; i<pz.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((zkey.domainSize+i)*n8r, (zkey.domainSize+i+1)*n8r),\n                    pz[i]\n                ),\n                (zkey.domainSize+i)*n8r\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i*n8r, (i+1)*n8r),\n                    pz[i]\n                ),\n                i*n8r\n            );\n        }\n        const A4 = await Fr.fft(a4);\n        return [a1, A4];\n    }\n\n\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRW9EO0FBQ1A7QUFDQTtBQUNXO0FBQ0E7QUFDeEQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSztBQUNIO0FBQzdCLFFBQVEsWUFBWSxFQUFFLG9DQUFNOztBQUViO0FBQ2YsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7O0FBRTNDLFdBQVcsb0NBQW9DLFFBQVEsNERBQXdCOztBQUUvRSx1QkFBdUIsc0RBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYyxJQUFJLGdCQUFnQjtBQUN0SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw0REFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFTOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbURBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtREFBUztBQUNoQzs7QUFFQSx1QkFBdUIsbURBQVM7QUFDaEM7O0FBRUEsdUJBQXVCLDREQUF3Qjs7O0FBRy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjtBQUNBLG9DQUFvQyw0REFBd0I7O0FBRTVEOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixtREFBUztBQUM3QixvQkFBb0IsbURBQVM7QUFDN0Isb0JBQW9CLG1EQUFTOztBQUU3QiwyQkFBMkIsNERBQXdCO0FBQ25ELDJCQUEyQiw0REFBd0I7QUFDbkQsMkJBQTJCLDREQUF3Qjs7QUFFbkQsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQVM7QUFDbEMseUJBQXlCLG1EQUFTOztBQUVsQztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakM7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakM7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakM7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakM7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakM7O0FBRUEsNEJBQTRCLDREQUF3Qjs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1EQUFTO0FBQy9CLHVCQUF1QixtREFBUzs7QUFFaEM7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDLHVFQUF1RSxFQUFFLEdBQUcsa0JBQWtCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7O0FBRUEsb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsbURBQVM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG1EQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixtREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1EQUFTO0FBQ3BDOztBQUVBLDJCQUEyQixtREFBUztBQUNwQzs7QUFFQSwyQkFBMkIsbURBQVM7QUFDcEM7O0FBRUEsMkJBQTJCLG1EQUFTO0FBQ3BDOztBQUVBLDJCQUEyQixtREFBUztBQUNwQzs7QUFFQSwyQkFBMkIsbURBQVM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbURBQVM7O0FBRTdCLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBLDBCQUEwQixtREFBUzs7QUFFbkM7O0FBRUEsd0JBQXdCLHlCQUF5QjtBQUNqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsbURBQVM7QUFDcEMsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdEQUFNO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixtREFBUztBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDOztBQUVBLHVCQUF1QixtREFBUztBQUNoQztBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua19wcm92ZS5qcz9hNDk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qIEltcGxlbWVudGF0aW9uIG9mIHRoaXMgcGFwZXI6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvOTUzLnBkZiBzZWN0aW9uIDguNCAqL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCB1dGlscywgQmlnQnVmZmVyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3N0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5pbXBvcnQganNTaGEzIGZyb20gXCJqcy1zaGEzXCI7XG5jb25zdCB7IGtlY2NhazI1NiB9ID0ganNTaGEzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9uazE2UHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IHtmZDogZmRXdG5zLCBzZWN0aW9uczogc2VjdGlvbnNXdG5zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3Qgd3RucyA9IGF3YWl0IHd0bnNVdGlscy5yZWFkSGVhZGVyKGZkV3Rucywgc2VjdGlvbnNXdG5zKTtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogc2VjdGlvbnNaS2V5fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgc2VjdGlvbnNaS2V5KTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcInBsb25rXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBwbG9ua1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIVNjYWxhci5lcSh6a2V5LnIsICB3dG5zLnEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnZlIG9mIHRoZSB3aXRuZXNzIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJ2ZSBvZiB0aGUgcHJvdmluZyBrZXlcIik7XG4gICAgfVxuXG4gICAgaWYgKHd0bnMubldpdG5lc3MgIT0gemtleS5uVmFycyAtemtleS5uQWRkaXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfSwgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBuOHIgPSBjdXJ2ZS5Gci5uODtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgV3Ruc1wiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFd0bnMsIHNlY3Rpb25zV3RucywgMik7XG4gICAgLy8gRmlyc3QgZWxlbWVudCBpbiBwbG9uayBpcyBub3QgdXNlZCBhbmQgY2FuIGJlIGFueSB2YWx1ZS4gKEJ1dCBhbHdheXMgdGhlIHNhbWUpLlxuICAgIC8vIFdlIHNldCBpdCB0byB6ZXJvIHRvIGdvIGZhc3RlciBpbiB0aGUgZXhwb25lbnRpYXRpb25zLlxuICAgIGJ1ZmZXaXRuZXNzLnNldChGci56ZXJvLCAwKTtcbiAgICBjb25zdCBidWZmSW50ZXJuYWxXaXRuZXNzID0gbmV3IEJpZ0J1ZmZlcihuOHIqemtleS5uQWRkaXRpb25zKTtcblxuICAgIGF3YWl0IGNhbGN1bGF0ZUFkZGl0aW9ucygpO1xuXG4gICAgbGV0IEEsQixDLFo7XG4gICAgbGV0IEE0LCBCNCwgQzQsIFo0O1xuICAgIGxldCBwb2xfYSxwb2xfYixwb2xfYywgcG9sX3osIHBvbF90LCBwb2xfcjtcbiAgICBsZXQgcHJvb2YgPSB7fTtcblxuICAgIGNvbnN0IHNpZ21hQnVmZiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplKm44cio0KjMpO1xuICAgIGxldCBvID0gc2VjdGlvbnNaS2V5WzEyXVswXS5wICsgemtleS5kb21haW5TaXplKm44cjtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHNpZ21hQnVmZiwgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIqNCwgbyk7XG4gICAgbyArPSB6a2V5LmRvbWFpblNpemUqbjhyKjU7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihzaWdtYUJ1ZmYsIHprZXkuZG9tYWluU2l6ZSpuOHIqNCAsIHprZXkuZG9tYWluU2l6ZSpuOHIqNCwgbyk7XG4gICAgbyArPSB6a2V5LmRvbWFpblNpemUqbjhyKjU7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihzaWdtYUJ1ZmYsIHprZXkuZG9tYWluU2l6ZSpuOHIqOCAsIHprZXkuZG9tYWluU2l6ZSpuOHIqNCwgbyk7XG5cbiAgICBjb25zdCBwb2xfczEgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9sX3MxLCAwICwgemtleS5kb21haW5TaXplKm44ciwgc2VjdGlvbnNaS2V5WzEyXVswXS5wKTtcblxuICAgIGNvbnN0IHBvbF9zMiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplKm44cik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2xfczIsIDAgLCB6a2V5LmRvbWFpblNpemUqbjhyLCBzZWN0aW9uc1pLZXlbMTJdWzBdLnAgKyA1KnprZXkuZG9tYWluU2l6ZSpuOHIpO1xuXG4gICAgY29uc3QgUFRhdSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgMTQpO1xuXG5cbiAgICBjb25zdCBjaCA9IHt9O1xuXG4gICAgYXdhaXQgcm91bmQxKCk7XG4gICAgYXdhaXQgcm91bmQyKCk7XG4gICAgYXdhaXQgcm91bmQzKCk7XG4gICAgYXdhaXQgcm91bmQ0KCk7XG4gICAgYXdhaXQgcm91bmQ1KCk7XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRmluYWwgYWRqdXN0bWVudHMgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgcHJvb2YucHJvdG9jb2wgPSBcInBsb25rXCI7XG4gICAgcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0xOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaSpGci5uOCwgaSpGci5uOCtGci5uOCk7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKHB1YikpO1xuICAgIH1cblxuICAgIHByb29mLkEgPSBHMS50b09iamVjdChwcm9vZi5BKTtcbiAgICBwcm9vZi5CID0gRzEudG9PYmplY3QocHJvb2YuQik7XG4gICAgcHJvb2YuQyA9IEcxLnRvT2JqZWN0KHByb29mLkMpO1xuICAgIHByb29mLlogPSBHMS50b09iamVjdChwcm9vZi5aKTtcblxuICAgIHByb29mLlQxID0gRzEudG9PYmplY3QocHJvb2YuVDEpO1xuICAgIHByb29mLlQyID0gRzEudG9PYmplY3QocHJvb2YuVDIpO1xuICAgIHByb29mLlQzID0gRzEudG9PYmplY3QocHJvb2YuVDMpO1xuXG4gICAgcHJvb2YuZXZhbF9hID0gRnIudG9PYmplY3QocHJvb2YuZXZhbF9hKTtcbiAgICBwcm9vZi5ldmFsX2IgPSBGci50b09iamVjdChwcm9vZi5ldmFsX2IpO1xuICAgIHByb29mLmV2YWxfYyA9IEZyLnRvT2JqZWN0KHByb29mLmV2YWxfYyk7XG4gICAgcHJvb2YuZXZhbF9zMSA9IEZyLnRvT2JqZWN0KHByb29mLmV2YWxfczEpO1xuICAgIHByb29mLmV2YWxfczIgPSBGci50b09iamVjdChwcm9vZi5ldmFsX3MyKTtcbiAgICBwcm9vZi5ldmFsX3p3ID0gRnIudG9PYmplY3QocHJvb2YuZXZhbF96dyk7XG4gICAgcHJvb2YuZXZhbF90ID0gRnIudG9PYmplY3QocHJvb2YuZXZhbF90KTtcbiAgICBwcm9vZi5ldmFsX3IgPSBGci50b09iamVjdChwcm9vZi5ldmFsX3IpO1xuXG4gICAgcHJvb2YuV3hpID0gRzEudG9PYmplY3QocHJvb2YuV3hpKTtcbiAgICBwcm9vZi5XeGl3ID0gRzEudG9PYmplY3QocHJvb2YuV3hpdyk7XG5cbiAgICBkZWxldGUgcHJvb2YuZXZhbF90O1xuXG4gICAgcHJvb2YgPSBzdHJpbmdpZnlCaWdJbnRzKHByb29mKTtcbiAgICBwdWJsaWNTaWduYWxzID0gc3RyaW5naWZ5QmlnSW50cyhwdWJsaWNTaWduYWxzKTtcblxuICAgIHJldHVybiB7cHJvb2YsIHB1YmxpY1NpZ25hbHN9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQWRkaXRpb25zKCkge1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCAzKTtcblxuICAgICAgICBjb25zdCBzU3VtID0gOCtjdXJ2ZS5Gci5uOCoyO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5BZGRpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWk9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgaSpzU3VtKTtcbiAgICAgICAgICAgIGNvbnN0IGJpPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIGkqc1N1bSs0KTtcbiAgICAgICAgICAgIGNvbnN0IGFjPSBhZGRpdGlvbnNCdWZmLnNsaWNlKGkqc1N1bSs4LCBpKnNTdW0rOCtuOHIpO1xuICAgICAgICAgICAgY29uc3QgYmM9IGFkZGl0aW9uc0J1ZmYuc2xpY2UoaSpzU3VtKzgrbjhyLCBpKnNTdW0rOCtuOHIqMik7XG4gICAgICAgICAgICBjb25zdCBhdz0gZ2V0V2l0bmVzcyhhaSk7XG4gICAgICAgICAgICBjb25zdCBidz0gZ2V0V2l0bmVzcyhiaSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHIgPSBjdXJ2ZS5Gci5hZGQoXG4gICAgICAgICAgICAgICAgY3VydmUuRnIubXVsKGFjLCBhdyksXG4gICAgICAgICAgICAgICAgY3VydmUuRnIubXVsKGJjLCBidylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmSW50ZXJuYWxXaXRuZXNzLnNldChyLCBuOHIqaSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGJ1aWxkQUJDKCkge1xuICAgICAgICBsZXQgQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjhyKTtcbiAgICAgICAgbGV0IEIgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIGxldCBDID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuXG4gICAgICAgIGNvbnN0IGFNYXAgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDQpO1xuICAgICAgICBjb25zdCBiTWFwID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA1KTtcbiAgICAgICAgY29uc3QgY01hcCA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNik7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkubkNvbnN0cmFpbnM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaUEgPSByZWFkVUludDMyKGFNYXAsIGkqNCk7XG4gICAgICAgICAgICBBLnNldChnZXRXaXRuZXNzKGlBKSwgaSpuOHIpO1xuICAgICAgICAgICAgY29uc3QgaUIgPSByZWFkVUludDMyKGJNYXAsIGkqNCk7XG4gICAgICAgICAgICBCLnNldChnZXRXaXRuZXNzKGlCKSwgaSpuOHIpO1xuICAgICAgICAgICAgY29uc3QgaUMgPSByZWFkVUludDMyKGNNYXAsIGkqNCk7XG4gICAgICAgICAgICBDLnNldChnZXRXaXRuZXNzKGlDKSwgaSpuOHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgQSA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KEEpO1xuICAgICAgICBCID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoQik7XG4gICAgICAgIEMgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShDKTtcblxuICAgICAgICByZXR1cm4gW0EsQixDXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDMyKGIsIG8pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGIuc2xpY2Uobywgbys0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzKGlkeCkge1xuICAgICAgICBpZiAoaWR4IDwgemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmV2l0bmVzcy5zbGljZShpZHgqbjhyLCBpZHgqbjhyK244cik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgemtleS5uVmFycykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2xpY2UoKGlkeCAtICh6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykpKm44ciwgKGlkeC0oemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpKSpuOHIgKyBuOHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLkZyLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDEoKSB7XG4gICAgICAgIGNoLmIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPD0xMTsgaSsrKSB7XG4gICAgICAgICAgICBjaC5iW2ldID0gY3VydmUuRnIucmFuZG9tKCk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgW0EsIEIsIENdID0gYXdhaXQgYnVpbGRBQkMoKTtcblxuICAgICAgICBbcG9sX2EsIEE0XSA9IGF3YWl0IHRvNFQoQSwgW2NoLmJbMl0sIGNoLmJbMV1dKTtcbiAgICAgICAgW3BvbF9iLCBCNF0gPSBhd2FpdCB0bzRUKEIsIFtjaC5iWzRdLCBjaC5iWzNdXSk7XG4gICAgICAgIFtwb2xfYywgQzRdID0gYXdhaXQgdG80VChDLCBbY2guYls2XSwgY2guYls1XV0pO1xuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHByb29mLkEgPSBhd2FpdCBleHBUYXUocG9sX2EsIFwibXVsdGlleHAgQVwiKTtcbiAgICAgICAgcHJvb2YuQiA9IGF3YWl0IGV4cFRhdShwb2xfYiwgXCJtdWx0aWV4cCBCXCIpO1xuICAgICAgICBwcm9vZi5DID0gYXdhaXQgZXhwVGF1KHBvbF9jLCBcIm11bHRpZXhwIENcIik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQyKCkge1xuXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQxID0gbmV3IFVpbnQ4QXJyYXkoemtleS5uUHVibGljKm44ciArIEcxLkYubjgqMiozKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBGci50b1JwckJFKHRyYW5zY3JpcHQxLCBpKm44ciwgQS5zbGljZSgoaSkqbjhyLCAoaSsxKSpuOHIpKTtcbiAgICAgICAgfVxuICAgICAgICBHMS50b1JwclVuY29tcHJlc3NlZCh0cmFuc2NyaXB0MSwgemtleS5uUHVibGljKm44ciArIDAsIHByb29mLkEpO1xuICAgICAgICBHMS50b1JwclVuY29tcHJlc3NlZCh0cmFuc2NyaXB0MSwgemtleS5uUHVibGljKm44ciArIEcxLkYubjgqMiwgcHJvb2YuQik7XG4gICAgICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQxLCB6a2V5Lm5QdWJsaWMqbjhyICsgRzEuRi5uOCo0LCBwcm9vZi5DKTtcblxuICAgICAgICBjaC5iZXRhID0gaGFzaFRvRnIodHJhbnNjcmlwdDEpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJiZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoLmJldGEpKTtcbiAgICBcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdDIgPSBuZXcgVWludDhBcnJheShuOHIpO1xuICAgICAgICBGci50b1JwckJFKHRyYW5zY3JpcHQyLCAwLCBjaC5iZXRhKTtcbiAgICAgICAgY2guZ2FtbWEgPSBoYXNoVG9Gcih0cmFuc2NyaXB0Mik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcImdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoLmdhbW1hKSk7XG4gICAgXG4gICAgICAgIGxldCBudW1BcnIgPSBuZXcgQmlnQnVmZmVyKEZyLm44KnprZXkuZG9tYWluU2l6ZSk7XG4gICAgICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKEZyLm44KnprZXkuZG9tYWluU2l6ZSk7XG5cbiAgICAgICAgbnVtQXJyLnNldChGci5vbmUsIDApO1xuICAgICAgICBkZW5BcnIuc2V0KEZyLm9uZSwgMCk7XG5cbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgbGV0IG4xID0gQS5zbGljZShpKm44ciwgKGkrMSkqbjhyKTtcbiAgICAgICAgICAgIG4xID0gRnIuYWRkKCBuMSwgRnIubXVsKGNoLmJldGEsIHcpICk7XG4gICAgICAgICAgICBuMSA9IEZyLmFkZCggbjEsIGNoLmdhbW1hICk7XG5cbiAgICAgICAgICAgIGxldCBuMiA9IEIuc2xpY2UoaSpuOHIsIChpKzEpKm44cik7XG4gICAgICAgICAgICBuMiA9IEZyLmFkZCggbjIsIEZyLm11bCh6a2V5LmsxLCBGci5tdWwoY2guYmV0YSwgdykgKSk7XG4gICAgICAgICAgICBuMiA9IEZyLmFkZCggbjIsIGNoLmdhbW1hICk7XG5cbiAgICAgICAgICAgIGxldCBuMyA9IEMuc2xpY2UoaSpuOHIsIChpKzEpKm44cik7XG4gICAgICAgICAgICBuMyA9IEZyLmFkZCggbjMsIEZyLm11bCh6a2V5LmsyLCBGci5tdWwoY2guYmV0YSwgdykgKSk7XG4gICAgICAgICAgICBuMyA9IEZyLmFkZCggbjMsIGNoLmdhbW1hICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IEZyLm11bChuMSwgRnIubXVsKG4yLCBuMykpO1xuXG4gICAgICAgICAgICBsZXQgZDEgPSBBLnNsaWNlKGkqbjhyLCAoaSsxKSpuOHIpO1xuICAgICAgICAgICAgZDEgPSBGci5hZGQoZDEsIEZyLm11bCggc2lnbWFCdWZmLnNsaWNlKGkqbjhyKjQsIGkqbjhyKjQgKyBuOHIpICwgY2guYmV0YSkpO1xuICAgICAgICAgICAgZDEgPSBGci5hZGQoZDEsIGNoLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQyID0gQi5zbGljZShpKm44ciwgKGkrMSkqbjhyKTtcbiAgICAgICAgICAgIGQyID0gRnIuYWRkKGQyLCBGci5tdWwoIHNpZ21hQnVmZi5zbGljZSgoemtleS5kb21haW5TaXplICsgaSkqNCpuOHIsICh6a2V5LmRvbWFpblNpemUgKyBpKSo0Km44cituOHIpICwgY2guYmV0YSkpO1xuICAgICAgICAgICAgZDIgPSBGci5hZGQoZDIsIGNoLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQzID0gQy5zbGljZShpKm44ciwgKGkrMSkqbjhyKTtcbiAgICAgICAgICAgIGQzID0gRnIuYWRkKGQzLCBGci5tdWwoIHNpZ21hQnVmZi5zbGljZSgoemtleS5kb21haW5TaXplKjIgKyBpKSo0Km44ciwgKHprZXkuZG9tYWluU2l6ZSoyICsgaSkqNCpuOHIgKyBuOHIpICwgY2guYmV0YSkpO1xuICAgICAgICAgICAgZDMgPSBGci5hZGQoZDMsIGNoLmdhbW1hKTtcblxuICAgICAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGQxLCBGci5tdWwoZDIsIGQzKSk7XG5cbiAgICAgICAgICAgIG51bUFyci5zZXQoICBcbiAgICAgICAgICAgICAgICBGci5tdWwoIFxuICAgICAgICAgICAgICAgICAgICBudW1BcnIuc2xpY2UoaSpuOHIsKGkrMSkqbjhyKSAsIFxuICAgICAgICAgICAgICAgICAgICBudW1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICgoaSsxKSV6a2V5LmRvbWFpblNpemUpKm44clxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZGVuQXJyLnNldCggIFxuICAgICAgICAgICAgICAgIEZyLm11bCggXG4gICAgICAgICAgICAgICAgICAgIGRlbkFyci5zbGljZShpKm44ciwoaSsxKSpuOHIpICwgXG4gICAgICAgICAgICAgICAgICAgIGRlblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKChpKzEpJXprZXkuZG9tYWluU2l6ZSkqbjhyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICAgICAgLy8gVE9ETzogRG8gaXQgaW4gYXNzZW1ibHkgYW5kIGluIHBhcmFsbGVsXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgbnVtQXJyLnNldCggICBGci5tdWwoIG51bUFyci5zbGljZShpKm44ciwgKGkrMSkqbjhyKSwgZGVuQXJyLnNsaWNlKGkqbjhyLCAoaSsxKSpuOHIpICkgICAgICAsaSpuOHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFGci5lcShudW1BcnIuc2xpY2UoMCwgbjhyKSwgRnIub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29weSBjb25zdHJhaW50cyBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFogPSBudW1BcnI7XG5cbiAgICAgICAgW3BvbF96LCBaNF0gPSBhd2FpdCB0bzRUKFosIFtjaC5iWzldLCBjaC5iWzhdLCBjaC5iWzddXSk7XG5cbiAgICAgICAgcHJvb2YuWiA9IGF3YWl0IGV4cFRhdSggcG9sX3osIFwibXVsdGlleHAgWlwiKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDMoKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY2hlY2tEZWdyZWUoUCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGF3YWl0IGN1cnZlLkZyLmlmZnQoUCk7XG4gICAgICAgICAgICBsZXQgZGVnID0gKFAuYnl0ZUxlbmd0aC9uOHIpLTE7XG4gICAgICAgICAgICB3aGlsZSAoKGRlZz4wKSYmKEZyLmlzWmVybyhwLnNsaWNlKGRlZypuOHIsIGRlZypuOHIrbjhyKSkpKSBkZWctLTtcbiAgICAgICAgICAgIHJldHVybiBkZWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmludFBvbChQKSB7XG4gICAgICAgICAgICBjb25zdCBuPShQLmJ5dGVMZW5ndGgvbjhyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhGci50b1N0cmluZyhQLnNsaWNlKGkqbjhyLCBpKm44cituOHIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJwaHNlMzogUmVhZGluZyBRTTRcIik7ICAgIFxuICAgICAgICBjb25zdCBRTTQgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSo0Km44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoUU00LCAwICwgemtleS5kb21haW5TaXplKm44cio0LCBzZWN0aW9uc1pLZXlbN11bMF0ucCArIHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBoc2UzOiBSZWFkaW5nIFFMNFwiKTsgICAgXG4gICAgICAgIGNvbnN0IFFMNCA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplKjQqbjhyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihRTDQsIDAgLCB6a2V5LmRvbWFpblNpemUqbjhyKjQsIHNlY3Rpb25zWktleVs4XVswXS5wICsgemtleS5kb21haW5TaXplKm44cik7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwicGhzZTM6IFJlYWRpbmcgUVI0XCIpOyAgICBcbiAgICAgICAgY29uc3QgUVI0ID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUqNCpuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKFFSNCwgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIqNCwgc2VjdGlvbnNaS2V5WzldWzBdLnAgKyB6a2V5LmRvbWFpblNpemUqbjhyKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJwaHNlMzogUmVhZGluZyBRTzRcIik7ICAgIFxuICAgICAgICBjb25zdCBRTzQgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSo0Km44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoUU80LCAwICwgemtleS5kb21haW5TaXplKm44cio0LCBzZWN0aW9uc1pLZXlbMTBdWzBdLnAgKyB6a2V5LmRvbWFpblNpemUqbjhyKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJwaHNlMzogUmVhZGluZyBRQzRcIik7ICAgIFxuICAgICAgICBjb25zdCBRQzQgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSo0Km44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoUUM0LCAwICwgemtleS5kb21haW5TaXplKm44cio0LCBzZWN0aW9uc1pLZXlbMTFdWzBdLnAgKyB6a2V5LmRvbWFpblNpemUqbjhyKTtcblxuICAgICAgICBjb25zdCBsUG9scyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgMTMpO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQzID0gbmV3IFVpbnQ4QXJyYXkoRzEuRi5uOCoyKTtcbiAgICAgICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDMsIDAsIHByb29mLlopO1xuXG4gICAgICAgIGNoLmFscGhhID0gaGFzaFRvRnIodHJhbnNjcmlwdDMpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcImFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoLmFscGhhKSk7ICAgIFxuXG5cbiAgICAgICAgY29uc3QgWjEgPSBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgICAgIEZyLmUoLTIpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBaMiA9IFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKDQpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLnplcm8sIEZyLm11bChGci5lKC0yKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IFozID0gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICAgICAgRnIuZSgtOCksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgyKSwgRnIubXVsKEZyLmUoMiksIEZyLndbMl0pKSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBUID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUqNCpuOHIpO1xuICAgICAgICBjb25zdCBUeiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplKjQqbjhyKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZSo0OyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoaSU0MDk2ID09IDApJiYobG9nZ2VyKSkgbG9nZ2VyLmRlYnVnKGBjYWxjdWxhdGluZyB0ICR7aX0vJHt6a2V5LmRvbWFpblNpemUqNH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYSA9IEE0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgYiA9IEI0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgYyA9IEM0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgeiA9IFo0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgencgPSBaNC5zbGljZSgoKGkremtleS5kb21haW5TaXplKjQrNCklKHprZXkuZG9tYWluU2l6ZSo0KSkgKm44ciwgKChpK3prZXkuZG9tYWluU2l6ZSo0KzQpJSh6a2V5LmRvbWFpblNpemUqNCkpICpuOHIgK244cik7XG4gICAgICAgICAgICBjb25zdCBxbSA9IFFNNC5zbGljZShpKm44ciwgaSpuOHIrbjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gUUw0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBRUjQuc2xpY2UoaSpuOHIsIGkqbjhyK244cik7XG4gICAgICAgICAgICBjb25zdCBxbyA9IFFPNC5zbGljZShpKm44ciwgaSpuOHIrbjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHFjID0gUUM0LnNsaWNlKGkqbjhyLCBpKm44cituOHIpO1xuICAgICAgICAgICAgY29uc3QgczEgPSBzaWdtYUJ1ZmYuc2xpY2UoaSpuOHIsIGkqbjhyK244cik7XG4gICAgICAgICAgICBjb25zdCBzMiA9IHNpZ21hQnVmZi5zbGljZSgoaSt6a2V5LmRvbWFpblNpemUqNCkqbjhyLCAoaSt6a2V5LmRvbWFpblNpemUqNCkqbjhyK244cik7XG4gICAgICAgICAgICBjb25zdCBzMyA9IHNpZ21hQnVmZi5zbGljZSgoaSt6a2V5LmRvbWFpblNpemUqOCkqbjhyLCAoaSt6a2V5LmRvbWFpblNpemUqOCkqbjhyK244cik7XG4gICAgICAgICAgICBjb25zdCBhcCA9IEZyLmFkZChjaC5iWzJdLCBGci5tdWwoY2guYlsxXSwgdykpO1xuICAgICAgICAgICAgY29uc3QgYnAgPSBGci5hZGQoY2guYls0XSwgRnIubXVsKGNoLmJbM10sIHcpKTtcbiAgICAgICAgICAgIGNvbnN0IGNwID0gRnIuYWRkKGNoLmJbNl0sIEZyLm11bChjaC5iWzVdLCB3KSk7XG4gICAgICAgICAgICBjb25zdCB3MiA9IEZyLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2guYls3XSwgdzIpLCBGci5tdWwoY2guYls4XSwgdykpLCBjaC5iWzldKTtcbiAgICAgICAgICAgIGNvbnN0IHdXID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgY29uc3Qgd1cyID0gRnIuc3F1YXJlKHdXKTtcbiAgICAgICAgICAgIGNvbnN0IHpXcCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoLmJbN10sIHdXMiksIEZyLm11bChjaC5iWzhdLCB3VykpLCBjaC5iWzldKTtcblxuICAgICAgICAgICAgbGV0IHBsID0gRnIuemVybztcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx6a2V5Lm5QdWJsaWM7IGorKykge1xuICAgICAgICAgICAgICAgIHBsID0gRnIuc3ViKHBsLCBGci5tdWwoIFxuICAgICAgICAgICAgICAgICAgICBsUG9scy5zbGljZSggKGoqNSp6a2V5LmRvbWFpblNpemUrIHprZXkuZG9tYWluU2l6ZSsgaSkqbjhyLCAoaio1KnprZXkuZG9tYWluU2l6ZSsgemtleS5kb21haW5TaXplICsgaSsxKSpuOHIpLFxuICAgICAgICAgICAgICAgICAgICBBLnNsaWNlKGoqbjhyLCAoaisxKSpuOHIpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBbZTEsIGUxel0gPSBtdWwyKGEsIGIsIGFwLCBicCwgaSU0KTtcbiAgICAgICAgICAgIGUxID0gRnIubXVsKGUxLCBxbSk7XG4gICAgICAgICAgICBlMXogPSBGci5tdWwoZTF6LCBxbSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYSwgcWwpKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChhcCwgcWwpKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChiLCBxcikpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGJwLCBxcikpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGMsIHFvKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoY3AsIHFvKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBwbCk7XG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgcWMpO1xuXG4gICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaC5iZXRhLCB3KTtcbiAgICAgICAgICAgIGxldCBlMmEgPWE7XG4gICAgICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBiZXRhdyk7XG4gICAgICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBjaC5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmIgPWI7XG4gICAgICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBGci5tdWwoYmV0YXcsIHprZXkuazEpKTtcbiAgICAgICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIGNoLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyYyA9YztcbiAgICAgICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIEZyLm11bChiZXRhdywgemtleS5rMikpO1xuICAgICAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgY2guZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJkID0gejtcblxuICAgICAgICAgICAgbGV0IFtlMiwgZTJ6XSA9IG11bDQoZTJhLCBlMmIsIGUyYywgZTJkLCBhcCwgYnAsIGNwLCB6cCwgaSU0KTtcbiAgICAgICAgICAgIGUyID0gRnIubXVsKGUyLCBjaC5hbHBoYSk7XG4gICAgICAgICAgICBlMnogPSBGci5tdWwoZTJ6LCBjaC5hbHBoYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2EgPSBhO1xuICAgICAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoLmJldGEsIHMxKSk7XG4gICAgICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBjaC5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2IgPSBiO1xuICAgICAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgRnIubXVsKGNoLmJldGEsczIpKTtcbiAgICAgICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzYyA9IGM7XG4gICAgICAgICAgICBlM2MgPSBGci5hZGQoZTNjLCBGci5tdWwoY2guYmV0YSxzMykpO1xuICAgICAgICAgICAgZTNjID0gRnIuYWRkKGUzYywgY2guZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNkID0genc7XG4gICAgICAgICAgICBsZXQgW2UzLCBlM3pdID0gbXVsNChlM2EsIGUzYiwgZTNjLCBlM2QsIGFwLCBicCwgY3AsIHpXcCwgaSU0KTtcblxuICAgICAgICAgICAgZTMgPSBGci5tdWwoZTMsIGNoLmFscGhhKTtcbiAgICAgICAgICAgIGUzeiA9IEZyLm11bChlM3osIGNoLmFscGhhKTtcblxuICAgICAgICAgICAgbGV0IGU0ID0gRnIuc3ViKHosIEZyLm9uZSk7XG4gICAgICAgICAgICBlNCA9IEZyLm11bChlNCwgbFBvbHMuc2xpY2UoICh6a2V5LmRvbWFpblNpemUgKyBpKSpuOHIsICh6a2V5LmRvbWFpblNpemUraSsxKSpuOHIpKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBGci5tdWwoY2guYWxwaGEsIGNoLmFscGhhKSk7XG5cbiAgICAgICAgICAgIGxldCBlNHogPSBGci5tdWwoenAsIGxQb2xzLnNsaWNlKCAoemtleS5kb21haW5TaXplICsgaSkqbjhyLCAoemtleS5kb21haW5TaXplK2krMSkqbjhyKSk7XG4gICAgICAgICAgICBlNHogPSBGci5tdWwoZTR6LCBGci5tdWwoY2guYWxwaGEsIGNoLmFscGhhKSk7XG5cbiAgICAgICAgICAgIGxldCBlID0gRnIuYWRkKEZyLnN1YihGci5hZGQoZTEsIGUyKSwgZTMpLCBlNCk7XG4gICAgICAgICAgICBsZXQgZXogPSBGci5hZGQoRnIuc3ViKEZyLmFkZChlMXosIGUyeiksIGUzeiksIGU0eik7XG5cbiAgICAgICAgICAgIFQuc2V0KGUsIGkqbjhyKTtcbiAgICAgICAgICAgIFR6LnNldChleiwgaSpuOHIpO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcisyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJpZmZ0IFRcIik7ICAgIFxuICAgICAgICBsZXQgdCA9IGF3YWl0IEZyLmlmZnQoVCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiZGl2aWRpbmcgVC9aXCIpOyAgICBcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0LnNldChGci5uZWcodC5zbGljZShpKm44ciwgaSpuOHIrbjhyKSksIGkqbjhyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGk9emtleS5kb21haW5TaXplOyBpPHprZXkuZG9tYWluU2l6ZSo0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBGci5zdWIoXG4gICAgICAgICAgICAgICAgdC5zbGljZSgoaS16a2V5LmRvbWFpblNpemUpKm44ciwgKGktemtleS5kb21haW5TaXplKSpuOHIgKyBuOHIpLFxuICAgICAgICAgICAgICAgIHQuc2xpY2UoaSpuOHIsIGkqbjhyK244cilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0LnNldChhLCBpKm44cik7XG4gICAgICAgICAgICBpZiAoaSA+ICh6a2V5LmRvbWFpblNpemUqMyAtNCkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFGci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVCBQb2x5bm9taWFsIGlzIG5vdCBkaXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiaWZmdCBUelwiKTsgICAgXG4gICAgICAgIGNvbnN0IHR6ID0gYXdhaXQgRnIuaWZmdChUeik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemUqNDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdHouc2xpY2UoaSpuOHIsIChpKzEpKm44cik7XG4gICAgICAgICAgICBpZiAoaSA+ICh6a2V5LmRvbWFpblNpemUqMyArNSkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFGci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHogUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5zZXQoICBcbiAgICAgICAgICAgICAgICAgICAgRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgdC5zbGljZShpKm44ciwgKGkrMSkqbjhyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgaSpuOHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9sX3QgPSB0LnNsaWNlKDAsICh6a2V5LmRvbWFpblNpemUgKiAzICsgNikgKiBuOHIpO1xuXG4gICAgICAgIC8vIHQoeCkgaGFzIGRlZ3JlZSAzbiArIDUsIHdlIGFyZSBnb2luZyB0byBzcGxpdCB0KHgpIGludG8gdGhyZWUgc21hbGxlciBwb2x5bm9taWFsczpcbiAgICAgICAgLy8gdCdfbG93IGFuZCB0J19taWQgIHdpdGggYSBkZWdyZWUgPCBuIGFuZCB0J19oaWdoIHdpdGggYSBkZWdyZWUgbis1XG4gICAgICAgIC8vIHN1Y2ggdGhhdCB0KHgpID0gdCdfbG93KFgpICsgWF5uIHQnX21pZChYKSArIFheezJufSB0J19oaShYKVxuICAgICAgICAvLyBUbyByYW5kb21pemUgdGhlIHBhcnRzIHdlIHVzZSBibGluZGluZyBzY2FsYXJzIGJfMTAgYW5kIGJfMTEgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IGNoYW5nZSB0KFgpOlxuICAgICAgICAvLyB0X2xvdyhYKSA9IHQnX2xvdyhYKSArIGJfMTAgWF5uXG4gICAgICAgIC8vIHRfbWlkKFgpID0gdCdfbWlkKFgpIC0gYl8xMCArIGJfMTEgWF5uXG4gICAgICAgIC8vIHRfaGlnaChYKSA9IHQnX2hpZ2goWCkgLSBiXzExXG4gICAgICAgIC8vIHN1Y2ggdGhhdFxuICAgICAgICAvLyB0KFgpID0gdF9sb3coWCkgKyBYXm4gdF9taWQoWCkgKyBYXjJuIHRfaGlnaChYKVxuXG4gICAgICAgIC8vIGNvbXB1dGUgdF9sb3coWClcbiAgICAgICAgbGV0IHBvbFRMb3cgPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44cik7XG4gICAgICAgIHBvbFRMb3cuc2V0KHQuc2xpY2UoMCwgemtleS5kb21haW5TaXplICogbjhyKSwgMCk7XG4gICAgICAgIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIHBvbFRMb3cuc2V0KGNoLmJbMTBdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdF9taWQoWClcbiAgICAgICAgbGV0IHBvbFRNaWQgPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44cik7XG4gICAgICAgIHBvbFRNaWQuc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogbjhyLCB6a2V5LmRvbWFpblNpemUgKiAyICogbjhyKSwgMCk7XG4gICAgICAgIC8vIFN1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzEwIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9taWRcbiAgICAgICAgY29uc3QgbG93ZXN0TWlkID0gRnIuc3ViKHBvbFRNaWQuc2xpY2UoMCwgbjhyKSwgY2guYlsxMF0pO1xuICAgICAgICBwb2xUTWlkLnNldChsb3dlc3RNaWQsIDApO1xuICAgICAgICAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTEgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICBwb2xUTWlkLnNldChjaC5iWzExXSwgemtleS5kb21haW5TaXplICogbjhyKTtcblxuICAgICAgICAvLyBjb21wdXRlIHRfaGlnaChYKVxuICAgICAgICBsZXQgcG9sVEhpZ2ggPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyA2KSAqIG44cik7XG4gICAgICAgIHBvbFRIaWdoLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIDIgKiBuOHIsICh6a2V5LmRvbWFpblNpemUgKiAzICsgNikgKiBuOHIpLCAwKTtcbiAgICAgICAgLy9TdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfaGlnaFxuICAgICAgICBjb25zdCBsb3dlc3RIaWdoID0gRnIuc3ViKHBvbFRIaWdoLnNsaWNlKDAsIG44ciksIGNoLmJbMTFdKTtcbiAgICAgICAgcG9sVEhpZ2guc2V0KGxvd2VzdEhpZ2gsIDApO1xuXG4gICAgICAgIHByb29mLlQxID0gYXdhaXQgZXhwVGF1KHBvbFRMb3csIFwibXVsdGlleHAgVDFcIik7XG4gICAgICAgIHByb29mLlQyID0gYXdhaXQgZXhwVGF1KHBvbFRNaWQsIFwibXVsdGlleHAgVDJcIik7XG4gICAgICAgIHByb29mLlQzID0gYXdhaXQgZXhwVGF1KHBvbFRIaWdoLCBcIm11bHRpZXhwIFQzXCIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG11bDIoYSxiLCBhcCwgYnAsICBwKSB7XG4gICAgICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsYik7XG4gICAgICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsYnApO1xuICAgICAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCxiKTtcbiAgICAgICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLGJwKTtcblxuICAgICAgICAgICAgciA9IGFfYjtcblxuICAgICAgICAgICAgbGV0IGEwID0gRnIuYWRkKGFfYnAsIGFwX2IpO1xuXG4gICAgICAgICAgICBsZXQgYTEgPSBhcF9icDtcblxuICAgICAgICAgICAgcnogPSBhMDtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtdWw0KGEsYixjLGQsIGFwLCBicCwgY3AsIGRwLCBwKSB7XG4gICAgICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsYik7XG4gICAgICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsYnApO1xuICAgICAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCxiKTtcbiAgICAgICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLGJwKTtcblxuICAgICAgICAgICAgY29uc3QgY19kID0gRnIubXVsKGMsZCk7XG4gICAgICAgICAgICBjb25zdCBjX2RwID0gRnIubXVsKGMsZHApO1xuICAgICAgICAgICAgY29uc3QgY3BfZCA9IEZyLm11bChjcCxkKTtcbiAgICAgICAgICAgIGNvbnN0IGNwX2RwID0gRnIubXVsKGNwLGRwKTtcblxuICAgICAgICAgICAgciA9IEZyLm11bChhX2IsIGNfZCk7XG5cbiAgICAgICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjX2QpO1xuICAgICAgICAgICAgYTAgPSBGci5hZGQoYTAsIEZyLm11bChhX2JwLCBjX2QpKTtcbiAgICAgICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcF9kKSk7XG4gICAgICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY19kcCkpO1xuXG4gICAgICAgICAgICBsZXQgYTEgPSBGci5tdWwoYXBfYnAsIGNfZCk7XG4gICAgICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFwX2IsIGNwX2QpKTtcbiAgICAgICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYXBfYiwgY19kcCkpO1xuICAgICAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2JwLCBjcF9kKSk7XG4gICAgICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNfZHApKTtcbiAgICAgICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9iLCBjcF9kcCkpO1xuXG4gICAgICAgICAgICBsZXQgYTIgPSBGci5tdWwoYV9icCwgY3BfZHApO1xuICAgICAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9iLCBjcF9kcCkpO1xuICAgICAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9icCwgY19kcCkpO1xuICAgICAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9icCwgY3BfZCkpO1xuXG4gICAgICAgICAgICBsZXQgYTMgPSBGci5tdWwoYXBfYnAsIGNwX2RwKTtcblxuICAgICAgICAgICAgcnogPSBhMDtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoyW3BdLCBhMikpO1xuICAgICAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjNbcF0sIGEzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbciwgcnpdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ0KCkge1xuICAgICAgICBjb25zdCBwb2xfcW0gPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbF9xbSwgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIsIHNlY3Rpb25zWktleVs3XVswXS5wKTtcblxuICAgICAgICBjb25zdCBwb2xfcWwgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbF9xbCwgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIsIHNlY3Rpb25zWktleVs4XVswXS5wKTtcblxuICAgICAgICBjb25zdCBwb2xfcXIgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbF9xciwgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIsIHNlY3Rpb25zWktleVs5XVswXS5wKTtcblxuICAgICAgICBjb25zdCBwb2xfcW8gPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbF9xbywgMCAsIHprZXkuZG9tYWluU2l6ZSpuOHIsIHNlY3Rpb25zWktleVsxMF1bMF0ucCk7XG5cbiAgICAgICAgY29uc3QgcG9sX3FjID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2xfcWMsIDAgLCB6a2V5LmRvbWFpblNpemUqbjhyLCBzZWN0aW9uc1pLZXlbMTFdWzBdLnApO1xuXG4gICAgICAgIGNvbnN0IHBvbF9zMyA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplKm44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9sX3MzLCAwICwgemtleS5kb21haW5TaXplKm44ciwgc2VjdGlvbnNaS2V5WzEyXVswXS5wICsgMTAqemtleS5kb21haW5TaXplKm44cik7XG5cbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdDQgPSBuZXcgVWludDhBcnJheShHMS5GLm44KjIqMyk7XG4gICAgICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQ0LCAwLCBwcm9vZi5UMSk7XG4gICAgICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQ0LCBHMS5GLm44KjIsIHByb29mLlQyKTtcbiAgICAgICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDQsIEcxLkYubjgqNCwgcHJvb2YuVDMpO1xuICAgICAgICBjaC54aSA9IGhhc2hUb0ZyKHRyYW5zY3JpcHQ0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJ4aTogXCIgKyBGci50b1N0cmluZyhjaC54aSkpOyAgICBcblxuICAgICAgICBwcm9vZi5ldmFsX2EgPSBldmFsUG9sKHBvbF9hLCBjaC54aSk7XG4gICAgICAgIHByb29mLmV2YWxfYiA9IGV2YWxQb2wocG9sX2IsIGNoLnhpKTtcbiAgICAgICAgcHJvb2YuZXZhbF9jID0gZXZhbFBvbChwb2xfYywgY2gueGkpO1xuICAgICAgICBwcm9vZi5ldmFsX3MxID0gZXZhbFBvbChwb2xfczEsIGNoLnhpKTtcbiAgICAgICAgcHJvb2YuZXZhbF9zMiA9IGV2YWxQb2wocG9sX3MyLCBjaC54aSk7XG4gICAgICAgIHByb29mLmV2YWxfdCA9IGV2YWxQb2wocG9sX3QsIGNoLnhpKTtcbiAgICAgICAgcHJvb2YuZXZhbF96dyA9IGV2YWxQb2wocG9sX3osIEZyLm11bChjaC54aSwgRnIud1t6a2V5LnBvd2VyXSkpO1xuXG4gICAgICAgIGNvbnN0IGNvZWZfYWIgPSBGci5tdWwocHJvb2YuZXZhbF9hLCBwcm9vZi5ldmFsX2IpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGUyYSA9IHByb29mLmV2YWxfYTtcbiAgICAgICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoLmJldGEsIGNoLnhpKTtcbiAgICAgICAgZTJhID0gRnIuYWRkKCBlMmEsIGJldGF4aSk7XG4gICAgICAgIGUyYSA9IEZyLmFkZCggZTJhLCBjaC5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUyYiA9IHByb29mLmV2YWxfYjtcbiAgICAgICAgZTJiID0gRnIuYWRkKCBlMmIsIEZyLm11bChiZXRheGksIHprZXkuazEpKTtcbiAgICAgICAgZTJiID0gRnIuYWRkKCBlMmIsIGNoLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTJjID0gcHJvb2YuZXZhbF9jO1xuICAgICAgICBlMmMgPSBGci5hZGQoIGUyYywgRnIubXVsKGJldGF4aSwgemtleS5rMikpO1xuICAgICAgICBlMmMgPSBGci5hZGQoIGUyYywgY2guZ2FtbWEpO1xuXG4gICAgICAgIGNvbnN0IGUyID0gRnIubXVsKEZyLm11bChGci5tdWwoZTJhLCBlMmIpLCBlMmMpLCBjaC5hbHBoYSk7XG5cbiAgICAgICAgbGV0IGUzYSA9IHByb29mLmV2YWxfYTtcbiAgICAgICAgZTNhID0gRnIuYWRkKCBlM2EsIEZyLm11bChjaC5iZXRhLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgICAgIGUzYSA9IEZyLmFkZCggZTNhLCBjaC5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUzYiA9IHByb29mLmV2YWxfYjtcbiAgICAgICAgZTNiID0gRnIuYWRkKCBlM2IsIEZyLm11bChjaC5iZXRhLCBwcm9vZi5ldmFsX3MyKSk7XG4gICAgICAgIGUzYiA9IEZyLmFkZCggZTNiLCBjaC5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUzID0gRnIubXVsKGUzYSwgZTNiKTtcbiAgICAgICAgZTMgPSBGci5tdWwoZTMsIGNoLmJldGEpO1xuICAgICAgICBlMyA9IEZyLm11bChlMywgcHJvb2YuZXZhbF96dyk7XG4gICAgICAgIGUzID0gRnIubXVsKGUzLCBjaC5hbHBoYSk7XG5cbiAgICAgICAgY2gueGltPSBjaC54aTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkucG93ZXI7IGkrKykgY2gueGltID0gRnIubXVsKGNoLnhpbSwgY2gueGltKTtcbiAgICAgICAgY29uc3QgZXZhbF9sMSA9IEZyLmRpdihcbiAgICAgICAgICAgIEZyLnN1YihjaC54aW0sIEZyLm9uZSksXG4gICAgICAgICAgICBGci5tdWwoRnIuc3ViKGNoLnhpLCBGci5vbmUpLCBGci5lKHprZXkuZG9tYWluU2l6ZSkpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZTQgPSBGci5tdWwoZXZhbF9sMSwgRnIubXVsKGNoLmFscGhhLCBjaC5hbHBoYSkpO1xuXG4gICAgICAgIGNvbnN0IGNvZWZzMyA9IGUzO1xuICAgICAgICBjb25zdCBjb2VmeiA9IEZyLmFkZChlMiwgZTQpO1xuXG4gICAgICAgIHBvbF9yID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplKzMpKm44cik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8emtleS5kb21haW5TaXplKzM7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSBGci5tdWwoY29lZnosIHBvbF96LnNsaWNlKGkqbjhyLChpKzEpKm44cikpO1xuICAgICAgICAgICAgaWYgKGk8emtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLmFkZCh2LCBGci5tdWwoY29lZl9hYiwgcG9sX3FtLnNsaWNlKGkqbjhyLChpKzEpKm44cikpKTtcbiAgICAgICAgICAgICAgICB2ID0gRnIuYWRkKHYsIEZyLm11bChwcm9vZi5ldmFsX2EsIHBvbF9xbC5zbGljZShpKm44ciwoaSsxKSpuOHIpKSk7XG4gICAgICAgICAgICAgICAgdiA9IEZyLmFkZCh2LCBGci5tdWwocHJvb2YuZXZhbF9iLCBwb2xfcXIuc2xpY2UoaSpuOHIsKGkrMSkqbjhyKSkpO1xuICAgICAgICAgICAgICAgIHYgPSBGci5hZGQodiwgRnIubXVsKHByb29mLmV2YWxfYywgcG9sX3FvLnNsaWNlKGkqbjhyLChpKzEpKm44cikpKTtcbiAgICAgICAgICAgICAgICB2ID0gRnIuYWRkKHYsIHBvbF9xYy5zbGljZShpKm44ciwoaSsxKSpuOHIpKTtcbiAgICAgICAgICAgICAgICB2ID0gRnIuc3ViKHYsIEZyLm11bChjb2VmczMsIHBvbF9zMy5zbGljZShpKm44ciwoaSsxKSpuOHIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xfci5zZXQodiwgaSpuOHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvb2YuZXZhbF9yID0gZXZhbFBvbChwb2xfciwgY2gueGkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNSgpIHtcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdDUgPSBuZXcgVWludDhBcnJheShuOHIqNyk7XG4gICAgICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIDAsIHByb29mLmV2YWxfYSk7XG4gICAgICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIG44ciwgcHJvb2YuZXZhbF9iKTtcbiAgICAgICAgRnIudG9ScHJCRSh0cmFuc2NyaXB0NSwgbjhyKjIsIHByb29mLmV2YWxfYyk7XG4gICAgICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIG44ciozLCBwcm9vZi5ldmFsX3MxKTtcbiAgICAgICAgRnIudG9ScHJCRSh0cmFuc2NyaXB0NSwgbjhyKjQsIHByb29mLmV2YWxfczIpO1xuICAgICAgICBGci50b1JwckJFKHRyYW5zY3JpcHQ1LCBuOHIqNSwgcHJvb2YuZXZhbF96dyk7XG4gICAgICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIG44cio2LCBwcm9vZi5ldmFsX3IpO1xuICAgICAgICBjaC52ID0gW107XG4gICAgICAgIGNoLnZbMV0gPSBoYXNoVG9Gcih0cmFuc2NyaXB0NSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInY6IFwiICsgRnIudG9TdHJpbmcoY2gudlsxXSkpOyAgICBcblxuICAgICAgICBmb3IgKGxldCBpPTI7IGk8PTY7IGkrKyApIGNoLnZbaV0gPSBGci5tdWwoY2gudltpLTFdLCBjaC52WzFdKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBwb2xfd3hpID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplKzYpKm44cik7XG5cbiAgICAgICAgY29uc3QgeGkybSA9IEZyLm11bChjaC54aW0sIGNoLnhpbSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKyA2OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB3ID0gRnIuemVybztcblxuICAgICAgICAgICAgY29uc3QgcG9sVEhpZ2ggPSBwb2xfdC5zbGljZSgoemtleS5kb21haW5TaXplICogMiArIGkpICogbjhyLCAoemtleS5kb21haW5TaXplICogMiArIGkgKyAxKSAqIG44cik7XG4gICAgICAgICAgICB3ID0gRnIuYWRkKHcsIEZyLm11bCh4aTJtLCBwb2xUSGlnaCkpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IHprZXkuZG9tYWluU2l6ZSArIDMpIHtcbiAgICAgICAgICAgICAgICB3ID0gRnIuYWRkKHcsIEZyLm11bChjaC52WzFdLCBwb2xfci5zbGljZShpICogbjhyLCAoaSArIDEpICogbjhyKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgICAgICB3ID0gRnIuYWRkKHcsIEZyLm11bChjaC52WzJdLCBwb2xfYS5zbGljZShpICogbjhyLCAoaSArIDEpICogbjhyKSkpO1xuICAgICAgICAgICAgICAgIHcgPSBGci5hZGQodywgRnIubXVsKGNoLnZbM10sIHBvbF9iLnNsaWNlKGkgKiBuOHIsIChpICsgMSkgKiBuOHIpKSk7XG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBGci5tdWwoY2gudls0XSwgcG9sX2Muc2xpY2UoaSAqIG44ciwgKGkgKyAxKSAqIG44cikpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPCB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2xUTG93ID0gcG9sX3Quc2xpY2UoaSAqIG44ciwgKGkgKyAxKSAqIG44cik7XG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBwb2xUTG93KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBvbFRNaWQgPSBwb2xfdC5zbGljZSgoemtleS5kb21haW5TaXplICsgaSkgKiBuOHIsICh6a2V5LmRvbWFpblNpemUgKyBpICsgMSkgKiBuOHIpO1xuICAgICAgICAgICAgICAgIHcgPSBGci5hZGQodywgRnIubXVsKGNoLnhpbSwgcG9sVE1pZCkpO1xuXG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBGci5tdWwoY2gudls1XSwgcG9sX3MxLnNsaWNlKGkgKiBuOHIsIChpICsgMSkgKiBuOHIpKSk7XG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBGci5tdWwoY2gudls2XSwgcG9sX3MyLnNsaWNlKGkgKiBuOHIsIChpICsgMSkgKiBuOHIpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJfMTAgYW5kIGJfMTEgYmxpbmRpbmcgc2NhbGFycyB3ZXJlIGFwcGxpZWQgb24gcm91bmQgMyB0byByYW5kb21pemUgdGhlIHBvbHlub21pYWxzIHRfbG93LCB0X21pZCwgdF9oaWdoXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCBhbmQgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPSBGci5zdWIodywgRnIubXVsKHhpMm0sIGNoLmJbMTFdKSk7XG4gICAgICAgICAgICAgICAgdyA9IEZyLnN1Yih3LCBGci5tdWwoY2gueGltLCBjaC5iWzEwXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgYmxpbmRpbmcgc2NhbGFycyBiXzEwIGFuZCBiXzExIHRvIHRoZSBjb2VmZmljaWVudCBuXG4gICAgICAgICAgICBpZiAoaSA9PT0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBjaC5iWzEwXSk7XG4gICAgICAgICAgICAgICAgdyA9IEZyLmFkZCh3LCBGci5tdWwoY2gueGltLCBjaC5iWzExXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb2xfd3hpLnNldCh3LCBpICogbjhyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3MCA9IHBvbF93eGkuc2xpY2UoMCwgbjhyKTtcbiAgICAgICAgdzAgPSBGci5zdWIodzAsIHByb29mLmV2YWxfdCk7XG4gICAgICAgIHcwID0gRnIuc3ViKHcwLCBGci5tdWwoY2gudlsxXSwgcHJvb2YuZXZhbF9yKSk7XG4gICAgICAgIHcwID0gRnIuc3ViKHcwLCBGci5tdWwoY2gudlsyXSwgcHJvb2YuZXZhbF9hKSk7XG4gICAgICAgIHcwID0gRnIuc3ViKHcwLCBGci5tdWwoY2gudlszXSwgcHJvb2YuZXZhbF9iKSk7XG4gICAgICAgIHcwID0gRnIuc3ViKHcwLCBGci5tdWwoY2gudls0XSwgcHJvb2YuZXZhbF9jKSk7XG4gICAgICAgIHcwID0gRnIuc3ViKHcwLCBGci5tdWwoY2gudls1XSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgICAgICB3MCA9IEZyLnN1Yih3MCwgRnIubXVsKGNoLnZbNl0sIHByb29mLmV2YWxfczIpKTtcbiAgICAgICAgcG9sX3d4aS5zZXQodzAsIDApO1xuXG4gICAgICAgIHBvbF93eGk9IGRpdlBvbDEocG9sX3d4aSwgY2gueGkpO1xuXG4gICAgICAgIHByb29mLld4aSA9IGF3YWl0IGV4cFRhdShwb2xfd3hpLCBcIm11bHRpZXhwIFd4aVwiKTtcblxuICAgICAgICBsZXQgcG9sX3d4aXcgPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUrMykqbjhyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZSszOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBwb2xfei5zbGljZShpKm44ciwgKGkrMSkqbjhyKTtcbiAgICAgICAgICAgIHBvbF93eGl3LnNldCh3LCBpKm44cik7XG4gICAgICAgIH1cbiAgICAgICAgdzAgPSBwb2xfd3hpdy5zbGljZSgwLCBuOHIpO1xuICAgICAgICB3MCA9IEZyLnN1Yih3MCwgcHJvb2YuZXZhbF96dyk7XG4gICAgICAgIHBvbF93eGl3LnNldCh3MCwgMCk7XG5cbiAgICAgICAgcG9sX3d4aXc9IGRpdlBvbDEocG9sX3d4aXcsIEZyLm11bChjaC54aSwgRnIud1t6a2V5LnBvd2VyXSkpO1xuICAgICAgICBwcm9vZi5XeGl3ID0gYXdhaXQgZXhwVGF1KHBvbF93eGl3LCBcIm11bHRpZXhwIFd4aXdcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzaFRvRnIodHJhbnNjcmlwdCkge1xuICAgICAgICBjb25zdCB2ID0gU2NhbGFyLmZyb21ScHJCRShuZXcgVWludDhBcnJheShrZWNjYWsyNTYuYXJyYXlCdWZmZXIodHJhbnNjcmlwdCkpKTtcbiAgICAgICAgcmV0dXJuIEZyLmUodik7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBldmFsUG9sKFAsIHgpIHtcbiAgICAgICAgY29uc3QgbiA9IFAuYnl0ZUxlbmd0aCAvIG44cjtcbiAgICAgICAgaWYgKG4gPT0gMCkgcmV0dXJuIEZyLnplcm87XG4gICAgICAgIGxldCByZXMgPSBQLnNsaWNlKChuLTEpKm44ciwgbipuOHIpO1xuICAgICAgICBmb3IgKGxldCBpPW4tMjsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXMgPSBGci5hZGQoRnIubXVsKHJlcywgeCksIFAuc2xpY2UoaSpuOHIsIChpKzEpKm44cikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2UG9sMShQLCBkKSB7XG4gICAgICAgIGNvbnN0IG4gPSBQLmJ5dGVMZW5ndGgvbjhyO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQmlnQnVmZmVyKG4qbjhyKTtcbiAgICAgICAgcmVzLnNldChGci56ZXJvLCAobi0xKSAqbjhyKTtcbiAgICAgICAgcmVzLnNldChQLnNsaWNlKChuLTEpKm44ciwgbipuOHIpLCAobi0yKSpuOHIpO1xuICAgICAgICBmb3IgKGxldCBpPW4tMzsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXMuc2V0KFxuICAgICAgICAgICAgICAgIEZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgUC5zbGljZSgoaSsxKSpuOHIsIChpKzIpKm44ciksIFxuICAgICAgICAgICAgICAgICAgICBGci5tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBkLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zbGljZSgoaSsxKSpuOHIsIChpKzIpKm44cilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSpuOHJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGci5lcShcbiAgICAgICAgICAgIFAuc2xpY2UoMCwgbjhyKSxcbiAgICAgICAgICAgIEZyLm11bChcbiAgICAgICAgICAgICAgICBGci5uZWcoZCksXG4gICAgICAgICAgICAgICAgcmVzLnNsaWNlKDAsIG44cilcbiAgICAgICAgICAgIClcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9saW5vbWlhbCBkb2VzIG5vdCBkaXZpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBUYXUoYiwgbmFtZSkge1xuICAgICAgICBjb25zdCBuID0gYi5ieXRlTGVuZ3RoL244cjtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4qY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KGIpO1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCBsb2dnZXIsIG5hbWUpO1xuICAgICAgICByZXMgPSBjdXJ2ZS5HMS50b0FmZmluZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdG80VChBLCBweikge1xuICAgICAgICBweiA9IHB6IHx8IFtdOyBcbiAgICAgICAgbGV0IGEgPSBhd2FpdCBGci5pZmZ0KEEpO1xuICAgICAgICBjb25zdCBhNCA9IG5ldyBCaWdCdWZmZXIobjhyKnprZXkuZG9tYWluU2l6ZSo0KTtcbiAgICAgICAgYTQuc2V0KGEsIDApO1xuXG4gICAgICAgIGNvbnN0IGExID0gbmV3IEJpZ0J1ZmZlcihuOHIqKHprZXkuZG9tYWluU2l6ZSArIHB6Lmxlbmd0aCkpO1xuICAgICAgICBhMS5zZXQoYSwgMCk7XG4gICAgICAgIGZvciAobGV0IGk9IDA7IGk8cHoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGExLnNldChcbiAgICAgICAgICAgICAgICBGci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGExLnNsaWNlKCh6a2V5LmRvbWFpblNpemUraSkqbjhyLCAoemtleS5kb21haW5TaXplK2krMSkqbjhyKSxcbiAgICAgICAgICAgICAgICAgICAgcHpbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICh6a2V5LmRvbWFpblNpemUraSkqbjhyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYTEuc2V0KFxuICAgICAgICAgICAgICAgIEZyLnN1YihcbiAgICAgICAgICAgICAgICAgICAgYTEuc2xpY2UoaSpuOHIsIChpKzEpKm44ciksXG4gICAgICAgICAgICAgICAgICAgIHB6W2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpKm44clxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBBNCA9IGF3YWl0IEZyLmZmdChhNCk7XG4gICAgICAgIHJldHVybiBbYTEsIEE0XTtcbiAgICB9XG5cblxufVxuXG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_prove.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_setup.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_setup.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/../backend/node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\n\n\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__.ready();\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    const plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polinomal is n+5 whe need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 14);\n    const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = linearComb2[s];\n                } else {\n                    res[s] = Fr.add(res[s], linearComb2[s]);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await writeP4(Q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is storen in  Montgomery. stored = v*R\n            // so when montgomery multiplicated by the witness  it result = v*R*w/R = v*w \n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](plonkNVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVvQztBQUNZO0FBUW5CO0FBQ0s7QUFDZTtBQUNkO0FBQ0U7OztBQUd0Qjs7QUFFZix3QkFBd0I7O0FBRXhCLFVBQVUsK0NBQWE7O0FBRXZCLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9CO0FBQ3JELFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7O0FBRWxFLHVCQUF1QixvREFBVSx3QkFBd0IsNkNBQTZDOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdFQUFXOztBQUVqQyxpQ0FBaUMsb0RBQVE7QUFDekMsK0JBQStCLG9EQUFRO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEIseUJBQXlCLGtFQUFhOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDhDQUFJO0FBQ3ZCLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GLHlCQUF5QixPQUFPLE1BQU07QUFDMUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBLFVBQVUsc0VBQWlCO0FBQzNCLHdCQUF3QixtREFBUztBQUNqQztBQUNBO0FBQ0EsVUFBVSxvRUFBZTtBQUN6Qix3QkFBd0I7OztBQUd4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDZCQUE2QjtBQUNyRCx1RkFBdUYsRUFBRSxHQUFHLGtCQUFrQjtBQUM5RztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQixzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0Esb0VBQW9FLEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzFHO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLG9CQUFvQixtREFBUztBQUM3QixzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0Esb0VBQW9FLEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzFHO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQSxjQUFjLG9FQUFlO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBLG9FQUFvRSxLQUFLLElBQUksRUFBRSxHQUFHLHNCQUFzQjtBQUN4RztBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSwwQkFBMEIsbURBQVM7QUFDbkMsa0NBQWtDLG9EQUFRO0FBQzFDLDZCQUE2QixvREFBUTtBQUNyQztBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTSxVQUFVLEVBQUUsR0FBRyx3QkFBd0I7QUFDakg7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNLFVBQVUsRUFBRSxHQUFHLFdBQVc7QUFDcEc7O0FBRUEsNEJBQTRCO0FBQzVCLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGNBQWMsb0VBQWU7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0IsMkJBQTJCLG1EQUFTO0FBQ3BDO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTSxFQUFFLEVBQUUsR0FBRyxFQUFFO0FBQy9EO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0Isb0NBQW9DO0FBQ3BDLGNBQWMsb0VBQWU7O0FBRTdCO0FBQ0E7O0FBRUEsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQSxrQ0FBa0MsZ0RBQU07O0FBRXhDO0FBQ0Esa0NBQWtDLGdEQUFNOztBQUV4QztBQUNBLGNBQWMsZ0VBQVc7QUFDekI7QUFDQSxjQUFjLGdFQUFXO0FBQ3pCLHFFQUFxRTtBQUNyRSxnRUFBZ0U7QUFDaEUsOERBQThEO0FBQzlELHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanM/ZDU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgKi9cblxuaW1wb3J0IHtyZWFkUjFjc0ZkfSBmcm9tIFwicjFjc2ZpbGVcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQge1xuICAgIHJlYWRCaW5GaWxlLFxuICAgIGNyZWF0ZUJpbkZpbGUsXG4gICAgcmVhZFNlY3Rpb24sXG4gICAgd3JpdGVCaWdJbnQsXG4gICAgc3RhcnRXcml0ZVNlY3Rpb24sXG4gICAgZW5kV3JpdGVTZWN0aW9uLFxufSBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHsgbG9nMiAgfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCBCaWdBcnJheSBmcm9tIFwiLi9iaWdhcnJheS5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsb25rU2V0dXAocjFjc05hbWUsIHB0YXVOYW1lLCB6a2V5TmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkUFRhdSwgc2VjdGlvbnM6IHNlY3Rpb25zUFRhdX0gPSBhd2FpdCByZWFkQmluRmlsZShwdGF1TmFtZSwgXCJwdGF1XCIsIDEsIDE8PDIyLCAxPDwyNCk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZFBUYXUsIHNlY3Rpb25zUFRhdSk7XG4gICAgY29uc3Qge2ZkOiBmZFIxY3MsIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3N9ID0gYXdhaXQgcmVhZEJpbkZpbGUocjFjc05hbWUsIFwicjFjc1wiLCAxLCAxPDwyMiwgMTw8MjQpO1xuXG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzRmQoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIHtsb2FkQ29uc3RyYWludHM6IHRydWUsIGxvYWRDdXN0b21HYXRlczogdHJ1ZX0pO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgcjFjc1wiKTtcbiAgICBsZXQgc1IxY3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBjb25zdCBwbG9ua0NvbnN0cmFpbnRzID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgY29uc3QgcGxvbmtBZGRpdGlvbnMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICBsZXQgcGxvbmtOVmFycyA9IHIxY3MublZhcnM7XG5cbiAgICBjb25zdCBuUHVibGljID0gcjFjcy5uT3V0cHV0cyArIHIxY3MublB1YklucHV0cztcblxuICAgIGF3YWl0IHByb2Nlc3NDb25zdHJhaW50cyhjdXJ2ZS5GciwgcjFjcywgbG9nZ2VyKTtcblxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAxLCAxNCwgMTw8MjIsIDE8PDI0KTtcblxuXG4gICAgaWYgKHIxY3MucHJpbWUgIT0gY3VydmUucikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBsZXQgY2lyUG93ZXIgPSBsb2cyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoIC0xKSArMTtcbiAgICBpZiAoY2lyUG93ZXIgPCAzKSBjaXJQb3dlciA9IDM7ICAgLy8gQXMgdGhlIHQgcG9saW5vbWFsIGlzIG4rNSB3aGUgbmVlZCBhdCBsZWFzdCBhIHBvd2VyIG9mIDRcbiAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBjaXJQb3dlcjtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUGxvbmsgY29uc3RyYWludHM6IFwiICsgcGxvbmtDb25zdHJhaW50cy5sZW5ndGgpO1xuICAgIGlmIChjaXJQb3dlciA+IHBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgY2lyY3VpdCB0b28gYmlnIGZvciB0aGlzIHBvd2VyIG9mIHRhdSBjZXJlbW9ueS4gJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH0gPiAyKioke3Bvd2VyfWApO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKCFzZWN0aW9uc1BUYXVbMTJdKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBvd2VycyBvZiB0YXUgaXMgbm90IHByZXBhcmVkLlwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuXG4gICAgY29uc3QgTFBvaW50cyA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpzRzEpO1xuICAgIGNvbnN0IG8gPSBzZWN0aW9uc1BUYXVbMTJdWzBdLnAgKyAoKDIgKiogKGNpclBvd2VyKSkgLTEpKnNHMTtcbiAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKExQb2ludHMsIDAsIGRvbWFpblNpemUqc0cxLCBvKTtcblxuICAgIGNvbnN0IFtrMSwgazJdID0gZ2V0SzFLMigpO1xuXG4gICAgY29uc3QgdmsgPSB7fTtcblxuXG4gICAgYXdhaXQgd3JpdGVBZGRpdGlvbnMoMywgXCJBZGRpdGlvbnNcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg0LCAwLCBcIkFtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg1LCAxLCBcIkJtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcCg2LCAyLCBcIkNtYXBcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg3LCAzLCBcIlFtXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoOCwgNCwgXCJRbFwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDksIDUsIFwiUXJcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCgxMCwgNiwgXCJRb1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDExLCA3LCBcIlFjXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVNpZ21hKDEyLCBcInNpZ21hXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZUxzKDEzLCBcImxhZ3JhbmdlIHBvbHlub21pYWxzXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuICAgIC8vIFdyaXRlIFBUYXUgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy8vXG5cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDE0KTtcbiAgICBjb25zdCBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcigoZG9tYWluU2l6ZSs2KSpzRzEpO1xuICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoYnVmZk91dCwgMCwgKGRvbWFpblNpemUrNikqc0cxLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuXG4gICAgYXdhaXQgd3JpdGVIZWFkZXJzKCk7XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiU2V0dXAgRmluaXNoZWRcIik7XG5cbiAgICByZXR1cm4gO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NvbnN0cmFpbnRzKEZyLCByMWNzLCBsb2dnZXIpIHtcblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUobGluZWFyQ29tYikge1xuICAgICAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsaW5lYXJDb21iKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZWFyQ29tYltzc1tpXV0gPT0gMG4pIGRlbGV0ZSBsaW5lYXJDb21iW3NzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGpvaW4obGluZWFyQ29tYjEsIGssIGxpbmVhckNvbWIyKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5lYXJDb21iMSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIubXVsKGssIGxpbmVhckNvbWIxW3NdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5hZGQocmVzW3NdLCBGci5tdWwoaywgbGluZWFyQ29tYjFbc10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYjIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IGxpbmVhckNvbWIyW3NdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLmFkZChyZXNbc10sIGxpbmVhckNvbWIyW3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemUocmVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWR1Y2VDb2VmcyhsaW5lYXJDb21iLCBtYXhDKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgazogRnIuemVybyxcbiAgICAgICAgICAgICAgICBzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2VmczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgICAgICBpZiAocyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5rID0gRnIuYWRkKHJlcy5rLCBsaW5lYXJDb21iW3NdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVhckNvbWJbc10gIT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHMpLCBsaW5lYXJDb21iW3NdXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY3MubGVuZ3RoID4gbWF4Qykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjMiA9IGNzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzbCA9IGMxWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyID0gYzJbMF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc28gPSBwbG9ua05WYXJzKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcW0gPSBGci56ZXJvO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFsID0gRnIubmVnKGMxWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxciA9IEZyLm5lZyhjMlsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcW8gPSBGci5vbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgcWMgPSBGci56ZXJvO1xuXG4gICAgICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcblxuICAgICAgICAgICAgICAgIHBsb25rQWRkaXRpb25zLnB1c2goW3NsLCBzciwgYzFbMV0sIGMyWzFdXSk7XG5cbiAgICAgICAgICAgICAgICBjcy5wdXNoKFtzbywgRnIub25lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNbaV0gPSBjc1tpXVswXTtcbiAgICAgICAgICAgICAgICByZXMuY29lZnNbaV0gPSBjc1tpXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyZXMuY29lZnMubGVuZ3RoIDwgbWF4Qykge1xuICAgICAgICAgICAgICAgIHJlcy5zLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgcmVzLmNvZWZzLnB1c2goRnIuemVybyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ29uc3RyYWludFN1bShsYykge1xuICAgICAgICAgICAgY29uc3QgQyA9IHJlZHVjZUNvZWZzKGxjLCAzKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gQy5zWzBdO1xuICAgICAgICAgICAgY29uc3Qgc3IgPSBDLnNbMV07XG4gICAgICAgICAgICBjb25zdCBzbyA9IEMuc1syXTtcbiAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFsID0gQy5jb2Vmc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHFyID0gQy5jb2Vmc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHFvID0gQy5jb2Vmc1syXTtcbiAgICAgICAgICAgIGNvbnN0IHFjID0gQy5rO1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbnN0cmFpbnRNdWwobGNBLCBsY0IsIGxjQykge1xuICAgICAgICAgICAgY29uc3QgQSA9IHJlZHVjZUNvZWZzKGxjQSwgMSk7XG4gICAgICAgICAgICBjb25zdCBCID0gcmVkdWNlQ29lZnMobGNCLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IEMgPSByZWR1Y2VDb2VmcyhsY0MsIDEpO1xuXG5cbiAgICAgICAgICAgIGNvbnN0IHNsID0gQS5zWzBdO1xuICAgICAgICAgICAgY29uc3Qgc3IgPSBCLnNbMF07XG4gICAgICAgICAgICBjb25zdCBzbyA9IEMuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHFtID0gRnIubXVsKEEuY29lZnNbMF0sIEIuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcWwgPSBGci5tdWwoQS5jb2Vmc1swXSwgQi5rKTtcbiAgICAgICAgICAgIGNvbnN0IHFyID0gRnIubXVsKEEuaywgQi5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxbyA9IEZyLm5lZyhDLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuc3ViKEZyLm11bChBLmssIEIuayksIEMuayk7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjKSB7XG4gICAgICAgICAgICBsZXQgayA9IEZyLnplcm87XG4gICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxjKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGNbc3NbaV1dID09IDBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsY1tzc1tpXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzc1tpXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBGci5hZGQoaywgbGNbc3NbaV1dKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gPiAwKSByZXR1cm4gbi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGsgIT0gRnIuemVybykgcmV0dXJuIFwia1wiO1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhsY0EsIGxjQiwgbGNDKSB7XG4gICAgICAgICAgICBjb25zdCBsY3RBID0gZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQSk7XG4gICAgICAgICAgICBjb25zdCBsY3RCID0gZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQik7XG4gICAgICAgICAgICBpZiAoKGxjdEEgPT09IFwiMFwiKSB8fCAobGN0QiA9PT0gXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplKGxjQyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uc3RyYWludFN1bShsY0MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsY3RBID09PSBcImtcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSBqb2luKGxjQiwgbGNBWzBdLCBsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDQyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxjdEIgPT09IFwia1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGNDQyA9IGpvaW4obGNBLCBsY0JbMF0sIGxjQyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uc3RyYWludFN1bShsY0NDKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ29uc3RyYWludE11bChsY0EsIGxjQiwgbGNDKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHMgPSAxOyBzIDw9IG5QdWJsaWM7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc2wgPSBzO1xuICAgICAgICAgICAgY29uc3Qgc3IgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc28gPSAwO1xuICAgICAgICAgICAgY29uc3QgcW0gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWwgPSBGci5vbmU7XG4gICAgICAgICAgICBjb25zdCBxciA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbyA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxYyA9IEZyLnplcm87XG5cbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHIxY3MuY29uc3RyYWludHMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoYyAlIDEwMDAwID09PSAwKSkgbG9nZ2VyLmRlYnVnKGBwcm9jZXNzaW5nIGNvbnN0cmFpbnRzOiAke2N9LyR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgICAgICBwcm9jZXNzKC4uLnIxY3MuY29uc3RyYWludHNbY10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVXaXRuZXNzTWFwKHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBsb25rQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0pO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGxldCBRID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKm44cik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBRLnNldChwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdLCBpKm44cik7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgYXdhaXQgd3JpdGVQNChRKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgICAgIFEgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFEpO1xuICAgICAgICB2a1tuYW1lXT0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUSwgbG9nZ2VyLCBcIm11bHRpZXhwIFwiK25hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUDQoYnVmZikge1xuICAgICAgICBjb25zdCBxID0gYXdhaXQgRnIuaWZmdChidWZmKTtcbiAgICAgICAgY29uc3QgcTQgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKjQpO1xuICAgICAgICBxNC5zZXQocSwgMCk7XG4gICAgICAgIGNvbnN0IFE0ID0gYXdhaXQgRnIuZmZ0KHE0KTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoUTQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQWRkaXRpb25zKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KCgyKjQrMipuOHIpKTtcbiAgICAgICAgY29uc3QgYnVmZk91dFYgPSBuZXcgRGF0YVZpZXcoYnVmZk91dC5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtBZGRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uPXBsb25rQWRkaXRpb25zW2ldO1xuICAgICAgICAgICAgbGV0IG89MDtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMihvLCBhZGRpdGlvblswXSwgdHJ1ZSk7IG8rPTQ7XG4gICAgICAgICAgICBidWZmT3V0Vi5zZXRVaW50MzIobywgYWRkaXRpb25bMV0sIHRydWUpOyBvKz00O1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIHN0b3JlbiBpbiAgTW9udGdvbWVyeS4gc3RvcmVkID0gdipSXG4gICAgICAgICAgICAvLyBzbyB3aGVuIG1vbnRnb21lcnkgbXVsdGlwbGljYXRlZCBieSB0aGUgd2l0bmVzcyAgaXQgcmVzdWx0ID0gdipSKncvUiA9IHYqdyBcbiAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGFkZGl0aW9uWzJdLCBvKTsgbys9IG44cjtcbiAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGFkZGl0aW9uWzNdLCBvKTsgbys9IG44cjtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0FkZGl0aW9ucy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVTaWdtYShzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IEJpZ0J1ZmZlcihuOHIqZG9tYWluU2l6ZSozKTtcbiAgICAgICAgY29uc3QgbGFzdEFwYXJlbmNlID0gIG5ldyBCaWdBcnJheShwbG9ua05WYXJzKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb3MgPSBuZXcgQmlnQXJyYXkocGxvbmtOVmFycyk7XG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ZG9tYWluU2l6ZTtpKyspIHtcbiAgICAgICAgICAgIGlmIChpPHBsb25rQ29uc3RyYWludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzBdLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMV0sIGRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMl0sIGRvbWFpblNpemUqMiArIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgZG9tYWluU2l6ZSoyICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbY2lyUG93ZXJdKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX0gcGhhc2UxOiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcz0wOyBzPHBsb25rTlZhcnM7IHMrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBvc1tzXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0QXBhcmVuY2Vbc10sIGZpcnN0UG9zW3NdKm44cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIG5vdCB1c2VkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihzJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9IHBoYXNlMjogJHtzfS8ke3Bsb25rTlZhcnN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGxldCBTMSA9IHNpZ21hLnNsaWNlKDAsIGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVQNChTMSk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgbGV0IFMyID0gc2lnbWEuc2xpY2UoZG9tYWluU2l6ZSpuOHIsIGRvbWFpblNpemUqbjhyKjIpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMyKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBsZXQgUzMgPSBzaWdtYS5zbGljZShkb21haW5TaXplKm44cioyLCBkb21haW5TaXplKm44ciozKTtcbiAgICAgICAgYXdhaXQgd3JpdGVQNChTMyk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgUzEgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMxKTtcbiAgICAgICAgUzIgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMyKTtcbiAgICAgICAgUzMgPSBhd2FpdCBGci5iYXRjaEZyb21Nb250Z29tZXJ5KFMzKTtcblxuICAgICAgICB2ay5TMT0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzEsIGxvZ2dlciwgXCJtdWx0aWV4cCBTMVwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICB2ay5TMj0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzIsIGxvZ2dlciwgXCJtdWx0aWV4cCBTMlwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICB2ay5TMz0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoTFBvaW50cywgUzMsIGxvZ2dlciwgXCJtdWx0aWV4cCBTM1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2lnbWEocywgcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0QXBhcmVuY2Vbc10gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc1tzXSA9IHA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0QXBhcmVuY2Vbc10sIHAqbjhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2O1xuICAgICAgICAgICAgaWYgKHA8ZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwPDIqZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RBcGFyZW5jZVtzXT12O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVMcyhzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGNvbnN0IGw9TWF0aC5tYXgoblB1YmxpYywgMSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKm44cik7XG4gICAgICAgICAgICBidWZmLnNldChGci5vbmUsIGkqbjhyKTtcbiAgICAgICAgICAgIGF3YWl0IHdyaXRlUDQoYnVmZik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSAke2l9LyR7bH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUhlYWRlcnMoKSB7XG5cbiAgICAgICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgICAgICAvLy8vLy8vLy8vL1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMigyKTsgLy8gUGxvbmtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgLy8gV3JpdGUgdGhlIFBsb25rIGhlYWRlciBzZWN0aW9uXG4gICAgICAgIC8vLy8vLy8vLy8vXG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAyKTtcbiAgICAgICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICAgICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArMSkqODtcblxuICAgICAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgICAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cSk7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUiwgbjhyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtOVmFycyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBiYXJzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoZG9tYWluU2l6ZSk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0FkZGl0aW9ucy5sZW5ndGgpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50cy5sZW5ndGgpOyBcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RbSkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUWwpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFyKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RbykpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUWMpKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzEpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMyKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMykpO1xuXG4gICAgICAgIGxldCBiWF8yO1xuICAgICAgICBiWF8yID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cyLCBzZWN0aW9uc1BUYXVbM11bMF0ucCArIHNHMik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShiWF8yKTtcblxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRLMUsyKCkge1xuICAgICAgICBsZXQgazEgPSBGci50d287XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsxLCBbXSwgY2lyUG93ZXIpKSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIGxldCBrMiA9IEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazIsIFtrMV0sIGNpclBvd2VyKSkgRnIuYWRkKGsyLCBGci5vbmUpO1xuICAgICAgICByZXR1cm4gW2sxLCBrMl07XG5cblxuICAgICAgICBmdW5jdGlvbiBpc0luY2x1ZGVkKGssIGtBcnIsIHBvdykge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluU2l6ZT0gMioqcG93O1xuICAgICAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8ZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIHcpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8a0Fyci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgRnIubXVsKGtBcnJbal0sIHcpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1twb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_setup.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/plonk_verify.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/plonk_verify.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkVerify)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-sha3 */ \"(rsc)/../backend/node_modules/js-sha3/src/sha3.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nconst { keccak256 } = js_sha3__WEBPACK_IMPORTED_MODULE_2__;\n\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    let proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    proof = fromObjectProof(curve,proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof is not well constructed\");\n        return false;\n    }\n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n    const challanges = calculateChallanges(curve, proof, publicSignals);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challanges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challanges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challanges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challanges.xi, 16));    \n        logger.debug(\"v1: \" + Fr.toString(challanges.v[1], 16));    \n        logger.debug(\"v6: \" + Fr.toString(challanges.v[6], 16));    \n        logger.debug(\"u: \" + Fr.toString(challanges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challanges, vk_verifier);\n    if (logger) {\n        logger.debug(\"Lagrange Evaluations: \");\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pl = calculatePl(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"Pl: \" + Fr.toString(pl, 16));\n    }\n\n    const t = calculateT(curve, proof, challanges, pl, L[1]);\n    if (logger) {\n        logger.debug(\"t: \" + Fr.toString(t, 16));\n    }\n\n    const D = calculateD(curve, proof, challanges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challanges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challanges, vk_verifier, t);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challanges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.eval_r = Fr.fromObject(proof.eval_r);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction calculateChallanges(curve, proof, publicSignals) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const res = {};\n\n    const transcript1 = new Uint8Array(publicSignals.length*n8r + G1.F.n8*2*3);\n    for (let i=0; i<publicSignals.length; i++) {\n        Fr.toRprBE(transcript1, i*n8r, Fr.e(publicSignals[i]));\n    }\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + 0, proof.A);\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + G1.F.n8*2, proof.B);\n    G1.toRprUncompressed(transcript1, publicSignals.length*n8r + G1.F.n8*4, proof.C);\n\n    res.beta = hashToFr(curve, transcript1);\n\n    const transcript2 = new Uint8Array(n8r);\n    Fr.toRprBE(transcript2, 0, res.beta);\n    res.gamma = hashToFr(curve, transcript2);\n\n    const transcript3 = new Uint8Array(G1.F.n8*2);\n    G1.toRprUncompressed(transcript3, 0, proof.Z);\n    res.alpha = hashToFr(curve, transcript3);\n\n    const transcript4 = new Uint8Array(G1.F.n8*2*3);\n    G1.toRprUncompressed(transcript4, 0, proof.T1);\n    G1.toRprUncompressed(transcript4, G1.F.n8*2, proof.T2);\n    G1.toRprUncompressed(transcript4, G1.F.n8*4, proof.T3);\n    res.xi = hashToFr(curve, transcript4);\n\n    const transcript5 = new Uint8Array(n8r*7);\n    Fr.toRprBE(transcript5, 0, proof.eval_a);\n    Fr.toRprBE(transcript5, n8r, proof.eval_b);\n    Fr.toRprBE(transcript5, n8r*2, proof.eval_c);\n    Fr.toRprBE(transcript5, n8r*3, proof.eval_s1);\n    Fr.toRprBE(transcript5, n8r*4, proof.eval_s2);\n    Fr.toRprBE(transcript5, n8r*5, proof.eval_zw);\n    Fr.toRprBE(transcript5, n8r*6, proof.eval_r);\n    res.v = [];\n    res.v[1] = hashToFr(curve, transcript5);\n\n    for (let i=2; i<=6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    const transcript6 = new Uint8Array(G1.F.n8*2*2);\n    G1.toRprUncompressed(transcript6, 0, proof.Wxi);\n    G1.toRprUncompressed(transcript6, G1.F.n8*2, proof.Wxiw);\n    res.u = hashToFr(curve, transcript6);\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challanges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challanges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challanges.xin = xin;\n\n    challanges.zh = Fr.sub(xin, Fr.one);\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challanges.zh), Fr.mul(n, Fr.sub(challanges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction hashToFr(curve, transcript) {\n    const v = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(transcript)));\n    return curve.Fr.e(v);\n}\n\nfunction calculatePl(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pl = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pl = Fr.sub(pl, Fr.mul(w, L[i+1]));\n    }\n    return pl;\n}\n\nfunction calculateT(curve, proof, challanges, pl, l1) {\n    const Fr = curve.Fr;\n    let num = proof.eval_r;\n    num = Fr.add(num, pl);\n\n    let e1 = proof.eval_a;\n    e1 = Fr.add(e1, Fr.mul(challanges.beta, proof.eval_s1));\n    e1 = Fr.add(e1, challanges.gamma);\n\n    let e2 = proof.eval_b;\n    e2 = Fr.add(e2, Fr.mul(challanges.beta, proof.eval_s2));\n    e2 = Fr.add(e2, challanges.gamma);\n\n    let e3 = proof.eval_c;\n    e3 = Fr.add(e3, challanges.gamma);\n\n    let e = Fr.mul(Fr.mul(e1, e2), e3);\n    e = Fr.mul(e, proof.eval_zw);\n    e = Fr.mul(e, challanges.alpha);\n\n    num = Fr.sub(num, e);\n\n    num = Fr.sub(num, Fr.mul(l1, Fr.square(challanges.alpha)));\n\n    const t = Fr.div(num, challanges.zh);\n\n    return t;\n}\n\nfunction calculateD(curve, proof, challanges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let s1 = Fr.mul(Fr.mul(proof.eval_a, proof.eval_b), challanges.v[1]);\n    let res = G1.timesFr(vk.Qm, s1);\n\n    let s2 = Fr.mul(proof.eval_a, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Ql, s2));\n\n    let s3 = Fr.mul(proof.eval_b, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Qr, s3));\n\n    let s4 = Fr.mul(proof.eval_c, challanges.v[1]);\n    res = G1.add(res, G1.timesFr(vk.Qo, s4));\n\n    res = G1.add(res, G1.timesFr(vk.Qc, challanges.v[1]));\n\n    const betaxi = Fr.mul(challanges.beta, challanges.xi);\n    let s6a = proof.eval_a;\n    s6a = Fr.add(s6a, betaxi);\n    s6a = Fr.add(s6a, challanges.gamma);\n\n    let s6b = proof.eval_b;\n    s6b = Fr.add(s6b, Fr.mul(betaxi, vk.k1));\n    s6b = Fr.add(s6b, challanges.gamma);\n\n    let s6c = proof.eval_c;\n    s6c = Fr.add(s6c, Fr.mul(betaxi, vk.k2));\n    s6c = Fr.add(s6c, challanges.gamma);\n\n    let s6 = Fr.mul(Fr.mul(s6a, s6b), s6c);\n    s6 = Fr.mul(s6, Fr.mul(challanges.alpha, challanges.v[1]));\n\n    let s6d = Fr.mul(Fr.mul(l1, Fr.square(challanges.alpha)), challanges.v[1]);\n    s6 = Fr.add(s6, s6d);\n\n    s6 = Fr.add(s6, challanges.u);\n    res = G1.add(res, G1.timesFr(proof.Z, s6));\n\n\n    let s7a = proof.eval_a;\n    s7a = Fr.add(s7a, Fr.mul(challanges.beta, proof.eval_s1));\n    s7a = Fr.add(s7a, challanges.gamma);\n\n    let s7b = proof.eval_b;\n    s7b = Fr.add(s7b, Fr.mul(challanges.beta, proof.eval_s2));\n    s7b = Fr.add(s7b, challanges.gamma);\n\n    let s7 = Fr.mul(s7a, s7b);\n    s7 = Fr.mul(s7, challanges.alpha);\n    s7 = Fr.mul(s7, challanges.v[1]);\n    s7 = Fr.mul(s7, challanges.beta);\n    s7 = Fr.mul(s7, proof.eval_zw);\n    res = G1.sub(res, G1.timesFr(vk.S3, s7));\n\n    return res;\n}\n\nfunction calculateF(curve, proof, challanges, vk, D) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let res = proof.T1;\n\n    res = G1.add(res, G1.timesFr(proof.T2, challanges.xin));\n    res = G1.add(res, G1.timesFr(proof.T3, Fr.square(challanges.xin)));\n    res = G1.add(res, D);\n    res = G1.add(res, G1.timesFr(proof.A, challanges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.B, challanges.v[3]));\n    res = G1.add(res, G1.timesFr(proof.C, challanges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S1, challanges.v[5]));\n    res = G1.add(res, G1.timesFr(vk.S2, challanges.v[6]));\n\n    return res;\n}\n\n\nfunction calculateE(curve, proof, challanges, vk, t) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let s = t;\n\n    s = Fr.add(s, Fr.mul(challanges.v[1], proof.eval_r));\n    s = Fr.add(s, Fr.mul(challanges.v[2], proof.eval_a));\n    s = Fr.add(s, Fr.mul(challanges.v[3], proof.eval_b));\n    s = Fr.add(s, Fr.mul(challanges.v[4], proof.eval_c));\n    s = Fr.add(s, Fr.mul(challanges.v[5], proof.eval_s1));\n    s = Fr.add(s, Fr.mul(challanges.v[6], proof.eval_s2));\n    s = Fr.add(s, Fr.mul(challanges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, s);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challanges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challanges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challanges.xi);\n    const s = Fr.mul(Fr.mul(challanges.u, challanges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ3NDO0FBQ0E7QUFDRTtBQUN4QyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLO0FBQ0w7QUFDN0IsUUFBUSxZQUFZLEVBQUUsb0NBQU07OztBQUdiO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE1BQU07O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0RBQU07QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua192ZXJpZnkuanM/MmVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgKi9cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcbmltcG9ydCBqc1NoYTMgZnJvbSBcImpzLXNoYTNcIjtcbmNvbnN0IHsga2VjY2FrMjU2IH0gPSBqc1NoYTM7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBsZXQgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBsZXQgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBsZXQgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIHByb29mID0gZnJvbU9iamVjdFByb29mKGN1cnZlLHByb29mKTtcbiAgICB2a192ZXJpZmllciA9IGZyb21PYmplY3RWayhjdXJ2ZSwgdmtfdmVyaWZpZXIpO1xuICAgIGlmICghaXNXZWxsQ29uc3RydWN0ZWQoY3VydmUsIHByb29mKSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJQcm9vZiBpcyBub3Qgd2VsbCBjb25zdHJ1Y3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT0gdmtfdmVyaWZpZXIublB1YmxpYykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwdWJsaWMgaW5wdXRzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNoYWxsYW5nZXMgPSBjYWxjdWxhdGVDaGFsbGFuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscyk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJiZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsYW5nZXMuYmV0YSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsYW5nZXMuZ2FtbWEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJhbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGFuZ2VzLmFscGhhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwieGk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxhbmdlcy54aSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInYxOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsYW5nZXMudlsxXSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInY2OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsYW5nZXMudls2XSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInU6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxhbmdlcy51LCAxNikpOyAgICBcbiAgICB9XG4gICAgY29uc3QgTCA9IGNhbGN1bGF0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsYW5nZXMsIHZrX3ZlcmlmaWVyKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkxhZ3JhbmdlIEV2YWx1YXRpb25zOiBcIik7XG4gICAgICAgIGZvciAobGV0IGk9MTsgaTxMLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEwke2l9KHhpKT1gICsgRnIudG9TdHJpbmcoTFtpXSwgMTYpKTsgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwbCA9IGNhbGN1bGF0ZVBsKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBMKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBsOiBcIiArIEZyLnRvU3RyaW5nKHBsLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBjYWxjdWxhdGVUKGN1cnZlLCBwcm9vZiwgY2hhbGxhbmdlcywgcGwsIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwidDogXCIgKyBGci50b1N0cmluZyh0LCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEQgPSBjYWxjdWxhdGVEKGN1cnZlLCBwcm9vZiwgY2hhbGxhbmdlcywgdmtfdmVyaWZpZXIsIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRDogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShEKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBGID0gY2FsY3VsYXRlRihjdXJ2ZSwgcHJvb2YsIGNoYWxsYW5nZXMsIHZrX3ZlcmlmaWVyLCBEKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkY6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRiksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRSA9IGNhbGN1bGF0ZUUoY3VydmUsIHByb29mLCBjaGFsbGFuZ2VzLCB2a192ZXJpZmllciwgdCk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEUpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxhbmdlcywgdmtfdmVyaWZpZXIsIEUsIEYpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIk9LIVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiSW52YWxpZCBQcm9vZlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG5cbn1cblxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0UHJvb2YoY3VydmUsIHByb29mKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIHJlcy5BID0gRzEuZnJvbU9iamVjdChwcm9vZi5BKTtcbiAgICByZXMuQiA9IEcxLmZyb21PYmplY3QocHJvb2YuQik7XG4gICAgcmVzLkMgPSBHMS5mcm9tT2JqZWN0KHByb29mLkMpO1xuICAgIHJlcy5aID0gRzEuZnJvbU9iamVjdChwcm9vZi5aKTtcbiAgICByZXMuVDEgPSBHMS5mcm9tT2JqZWN0KHByb29mLlQxKTtcbiAgICByZXMuVDIgPSBHMS5mcm9tT2JqZWN0KHByb29mLlQyKTtcbiAgICByZXMuVDMgPSBHMS5mcm9tT2JqZWN0KHByb29mLlQzKTtcbiAgICByZXMuZXZhbF9hID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2EpO1xuICAgIHJlcy5ldmFsX2IgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYik7XG4gICAgcmVzLmV2YWxfYyA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9jKTtcbiAgICByZXMuZXZhbF96dyA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF96dyk7XG4gICAgcmVzLmV2YWxfczEgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfczEpO1xuICAgIHJlcy5ldmFsX3MyID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3MyKTtcbiAgICByZXMuZXZhbF9yID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3IpO1xuICAgIHJlcy5XeGkgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aSk7XG4gICAgcmVzLld4aXcgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aXcpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEcyID0gY3VydmUuRzI7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuUW0gPSBHMS5mcm9tT2JqZWN0KHZrLlFtKTtcbiAgICByZXMuUWwgPSBHMS5mcm9tT2JqZWN0KHZrLlFsKTtcbiAgICByZXMuUXIgPSBHMS5mcm9tT2JqZWN0KHZrLlFyKTtcbiAgICByZXMuUW8gPSBHMS5mcm9tT2JqZWN0KHZrLlFvKTtcbiAgICByZXMuUWMgPSBHMS5mcm9tT2JqZWN0KHZrLlFjKTtcbiAgICByZXMuUzEgPSBHMS5mcm9tT2JqZWN0KHZrLlMxKTtcbiAgICByZXMuUzIgPSBHMS5mcm9tT2JqZWN0KHZrLlMyKTtcbiAgICByZXMuUzMgPSBHMS5mcm9tT2JqZWN0KHZrLlMzKTtcbiAgICByZXMuazEgPSBGci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBGci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMuWF8yID0gRzIuZnJvbU9iamVjdCh2ay5YXzIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaXNXZWxsQ29uc3RydWN0ZWQoY3VydmUsIHByb29mKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuWikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDEpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuV3hpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGl3KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFsbGFuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBuOHIgPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCByZXMgPSB7fTtcblxuICAgIGNvbnN0IHRyYW5zY3JpcHQxID0gbmV3IFVpbnQ4QXJyYXkocHVibGljU2lnbmFscy5sZW5ndGgqbjhyICsgRzEuRi5uOCoyKjMpO1xuICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDEsIGkqbjhyLCBGci5lKHB1YmxpY1NpZ25hbHNbaV0pKTtcbiAgICB9XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDEsIHB1YmxpY1NpZ25hbHMubGVuZ3RoKm44ciArIDAsIHByb29mLkEpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQxLCBwdWJsaWNTaWduYWxzLmxlbmd0aCpuOHIgKyBHMS5GLm44KjIsIHByb29mLkIpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQxLCBwdWJsaWNTaWduYWxzLmxlbmd0aCpuOHIgKyBHMS5GLm44KjQsIHByb29mLkMpO1xuXG4gICAgcmVzLmJldGEgPSBoYXNoVG9GcihjdXJ2ZSwgdHJhbnNjcmlwdDEpO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdDIgPSBuZXcgVWludDhBcnJheShuOHIpO1xuICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDIsIDAsIHJlcy5iZXRhKTtcbiAgICByZXMuZ2FtbWEgPSBoYXNoVG9GcihjdXJ2ZSwgdHJhbnNjcmlwdDIpO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdDMgPSBuZXcgVWludDhBcnJheShHMS5GLm44KjIpO1xuICAgIEcxLnRvUnByVW5jb21wcmVzc2VkKHRyYW5zY3JpcHQzLCAwLCBwcm9vZi5aKTtcbiAgICByZXMuYWxwaGEgPSBoYXNoVG9GcihjdXJ2ZSwgdHJhbnNjcmlwdDMpO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdDQgPSBuZXcgVWludDhBcnJheShHMS5GLm44KjIqMyk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDQsIDAsIHByb29mLlQxKTtcbiAgICBHMS50b1JwclVuY29tcHJlc3NlZCh0cmFuc2NyaXB0NCwgRzEuRi5uOCoyLCBwcm9vZi5UMik7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDQsIEcxLkYubjgqNCwgcHJvb2YuVDMpO1xuICAgIHJlcy54aSA9IGhhc2hUb0ZyKGN1cnZlLCB0cmFuc2NyaXB0NCk7XG5cbiAgICBjb25zdCB0cmFuc2NyaXB0NSA9IG5ldyBVaW50OEFycmF5KG44cio3KTtcbiAgICBGci50b1JwckJFKHRyYW5zY3JpcHQ1LCAwLCBwcm9vZi5ldmFsX2EpO1xuICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIG44ciwgcHJvb2YuZXZhbF9iKTtcbiAgICBGci50b1JwckJFKHRyYW5zY3JpcHQ1LCBuOHIqMiwgcHJvb2YuZXZhbF9jKTtcbiAgICBGci50b1JwckJFKHRyYW5zY3JpcHQ1LCBuOHIqMywgcHJvb2YuZXZhbF9zMSk7XG4gICAgRnIudG9ScHJCRSh0cmFuc2NyaXB0NSwgbjhyKjQsIHByb29mLmV2YWxfczIpO1xuICAgIEZyLnRvUnByQkUodHJhbnNjcmlwdDUsIG44cio1LCBwcm9vZi5ldmFsX3p3KTtcbiAgICBGci50b1JwckJFKHRyYW5zY3JpcHQ1LCBuOHIqNiwgcHJvb2YuZXZhbF9yKTtcbiAgICByZXMudiA9IFtdO1xuICAgIHJlcy52WzFdID0gaGFzaFRvRnIoY3VydmUsIHRyYW5zY3JpcHQ1KTtcblxuICAgIGZvciAobGV0IGk9MjsgaTw9NjsgaSsrICkgcmVzLnZbaV0gPSBGci5tdWwocmVzLnZbaS0xXSwgcmVzLnZbMV0pO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdDYgPSBuZXcgVWludDhBcnJheShHMS5GLm44KjIqMik7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDYsIDAsIHByb29mLld4aSk7XG4gICAgRzEudG9ScHJVbmNvbXByZXNzZWQodHJhbnNjcmlwdDYsIEcxLkYubjgqMiwgcHJvb2YuV3hpdyk7XG4gICAgcmVzLnUgPSBoYXNoVG9GcihjdXJ2ZSwgdHJhbnNjcmlwdDYpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGFncmFuZ2VFdmFsdWF0aW9ucyhjdXJ2ZSwgY2hhbGxhbmdlcywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHhpbiA9IGNoYWxsYW5nZXMueGk7XG4gICAgbGV0IGRvbWFpblNpemUgPSAxO1xuICAgIGZvciAobGV0IGk9MDsgaTx2ay5wb3dlcjsgaSsrKSB7XG4gICAgICAgIHhpbiA9IEZyLnNxdWFyZSh4aW4pO1xuICAgICAgICBkb21haW5TaXplICo9IDI7XG4gICAgfVxuICAgIGNoYWxsYW5nZXMueGluID0geGluO1xuXG4gICAgY2hhbGxhbmdlcy56aCA9IEZyLnN1Yih4aW4sIEZyLm9uZSk7XG4gICAgY29uc3QgTCA9IFtdO1xuXG4gICAgY29uc3QgbiA9IEZyLmUoZG9tYWluU2l6ZSk7XG4gICAgbGV0IHcgPSBGci5vbmU7XG4gICAgZm9yIChsZXQgaT0xOyBpPD1NYXRoLm1heCgxLCB2ay5uUHVibGljKTsgaSsrKSB7XG4gICAgICAgIExbaV0gPSBGci5kaXYoRnIubXVsKHcsIGNoYWxsYW5nZXMuemgpLCBGci5tdWwobiwgRnIuc3ViKGNoYWxsYW5nZXMueGksIHcpKSk7XG4gICAgICAgIHcgPSBGci5tdWwodywgRnIud1t2ay5wb3dlcl0pO1xuICAgIH1cblxuICAgIHJldHVybiBMO1xufVxuXG5mdW5jdGlvbiBoYXNoVG9GcihjdXJ2ZSwgdHJhbnNjcmlwdCkge1xuICAgIGNvbnN0IHYgPSBTY2FsYXIuZnJvbVJwckJFKG5ldyBVaW50OEFycmF5KGtlY2NhazI1Ni5hcnJheUJ1ZmZlcih0cmFuc2NyaXB0KSkpO1xuICAgIHJldHVybiBjdXJ2ZS5Gci5lKHYpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQbChjdXJ2ZSwgcHVibGljU2lnbmFscywgTCkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcGwgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICBwbCA9IEZyLnN1YihwbCwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGw7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVQoY3VydmUsIHByb29mLCBjaGFsbGFuZ2VzLCBwbCwgbDEpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGxldCBudW0gPSBwcm9vZi5ldmFsX3I7XG4gICAgbnVtID0gRnIuYWRkKG51bSwgcGwpO1xuXG4gICAgbGV0IGUxID0gcHJvb2YuZXZhbF9hO1xuICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoY2hhbGxhbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgZTEgPSBGci5hZGQoZTEsIGNoYWxsYW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUyID0gcHJvb2YuZXZhbF9iO1xuICAgIGUyID0gRnIuYWRkKGUyLCBGci5tdWwoY2hhbGxhbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSk7XG4gICAgZTIgPSBGci5hZGQoZTIsIGNoYWxsYW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzID0gcHJvb2YuZXZhbF9jO1xuICAgIGUzID0gRnIuYWRkKGUzLCBjaGFsbGFuZ2VzLmdhbW1hKTtcblxuICAgIGxldCBlID0gRnIubXVsKEZyLm11bChlMSwgZTIpLCBlMyk7XG4gICAgZSA9IEZyLm11bChlLCBwcm9vZi5ldmFsX3p3KTtcbiAgICBlID0gRnIubXVsKGUsIGNoYWxsYW5nZXMuYWxwaGEpO1xuXG4gICAgbnVtID0gRnIuc3ViKG51bSwgZSk7XG5cbiAgICBudW0gPSBGci5zdWIobnVtLCBGci5tdWwobDEsIEZyLnNxdWFyZShjaGFsbGFuZ2VzLmFscGhhKSkpO1xuXG4gICAgY29uc3QgdCA9IEZyLmRpdihudW0sIGNoYWxsYW5nZXMuemgpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGFuZ2VzLCB2aywgbDEpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgczEgPSBGci5tdWwoRnIubXVsKHByb29mLmV2YWxfYSwgcHJvb2YuZXZhbF9iKSwgY2hhbGxhbmdlcy52WzFdKTtcbiAgICBsZXQgcmVzID0gRzEudGltZXNGcih2ay5RbSwgczEpO1xuXG4gICAgbGV0IHMyID0gRnIubXVsKHByb29mLmV2YWxfYSwgY2hhbGxhbmdlcy52WzFdKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHZrLlFsLCBzMikpO1xuXG4gICAgbGV0IHMzID0gRnIubXVsKHByb29mLmV2YWxfYiwgY2hhbGxhbmdlcy52WzFdKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHZrLlFyLCBzMykpO1xuXG4gICAgbGV0IHM0ID0gRnIubXVsKHByb29mLmV2YWxfYywgY2hhbGxhbmdlcy52WzFdKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHZrLlFvLCBzNCkpO1xuXG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcih2ay5RYywgY2hhbGxhbmdlcy52WzFdKSk7XG5cbiAgICBjb25zdCBiZXRheGkgPSBGci5tdWwoY2hhbGxhbmdlcy5iZXRhLCBjaGFsbGFuZ2VzLnhpKTtcbiAgICBsZXQgczZhID0gcHJvb2YuZXZhbF9hO1xuICAgIHM2YSA9IEZyLmFkZChzNmEsIGJldGF4aSk7XG4gICAgczZhID0gRnIuYWRkKHM2YSwgY2hhbGxhbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgczZiID0gcHJvb2YuZXZhbF9iO1xuICAgIHM2YiA9IEZyLmFkZChzNmIsIEZyLm11bChiZXRheGksIHZrLmsxKSk7XG4gICAgczZiID0gRnIuYWRkKHM2YiwgY2hhbGxhbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgczZjID0gcHJvb2YuZXZhbF9jO1xuICAgIHM2YyA9IEZyLmFkZChzNmMsIEZyLm11bChiZXRheGksIHZrLmsyKSk7XG4gICAgczZjID0gRnIuYWRkKHM2YywgY2hhbGxhbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgczYgPSBGci5tdWwoRnIubXVsKHM2YSwgczZiKSwgczZjKTtcbiAgICBzNiA9IEZyLm11bChzNiwgRnIubXVsKGNoYWxsYW5nZXMuYWxwaGEsIGNoYWxsYW5nZXMudlsxXSkpO1xuXG4gICAgbGV0IHM2ZCA9IEZyLm11bChGci5tdWwobDEsIEZyLnNxdWFyZShjaGFsbGFuZ2VzLmFscGhhKSksIGNoYWxsYW5nZXMudlsxXSk7XG4gICAgczYgPSBGci5hZGQoczYsIHM2ZCk7XG5cbiAgICBzNiA9IEZyLmFkZChzNiwgY2hhbGxhbmdlcy51KTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLlosIHM2KSk7XG5cblxuICAgIGxldCBzN2EgPSBwcm9vZi5ldmFsX2E7XG4gICAgczdhID0gRnIuYWRkKHM3YSwgRnIubXVsKGNoYWxsYW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIHM3YSA9IEZyLmFkZChzN2EsIGNoYWxsYW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IHM3YiA9IHByb29mLmV2YWxfYjtcbiAgICBzN2IgPSBGci5hZGQoczdiLCBGci5tdWwoY2hhbGxhbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSk7XG4gICAgczdiID0gRnIuYWRkKHM3YiwgY2hhbGxhbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgczcgPSBGci5tdWwoczdhLCBzN2IpO1xuICAgIHM3ID0gRnIubXVsKHM3LCBjaGFsbGFuZ2VzLmFscGhhKTtcbiAgICBzNyA9IEZyLm11bChzNywgY2hhbGxhbmdlcy52WzFdKTtcbiAgICBzNyA9IEZyLm11bChzNywgY2hhbGxhbmdlcy5iZXRhKTtcbiAgICBzNyA9IEZyLm11bChzNywgcHJvb2YuZXZhbF96dyk7XG4gICAgcmVzID0gRzEuc3ViKHJlcywgRzEudGltZXNGcih2ay5TMywgczcpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUYoY3VydmUsIHByb29mLCBjaGFsbGFuZ2VzLCB2aywgRCkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCByZXMgPSBwcm9vZi5UMTtcblxuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIocHJvb2YuVDIsIGNoYWxsYW5nZXMueGluKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5UMywgRnIuc3F1YXJlKGNoYWxsYW5nZXMueGluKSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEQpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIocHJvb2YuQSwgY2hhbGxhbmdlcy52WzJdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5CLCBjaGFsbGFuZ2VzLnZbM10pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLkMsIGNoYWxsYW5nZXMudls0XSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzEsIGNoYWxsYW5nZXMudls1XSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzIsIGNoYWxsYW5nZXMudls2XSkpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxhbmdlcywgdmssIHQpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcyA9IHQ7XG5cbiAgICBzID0gRnIuYWRkKHMsIEZyLm11bChjaGFsbGFuZ2VzLnZbMV0sIHByb29mLmV2YWxfcikpO1xuICAgIHMgPSBGci5hZGQocywgRnIubXVsKGNoYWxsYW5nZXMudlsyXSwgcHJvb2YuZXZhbF9hKSk7XG4gICAgcyA9IEZyLmFkZChzLCBGci5tdWwoY2hhbGxhbmdlcy52WzNdLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBzID0gRnIuYWRkKHMsIEZyLm11bChjaGFsbGFuZ2VzLnZbNF0sIHByb29mLmV2YWxfYykpO1xuICAgIHMgPSBGci5hZGQocywgRnIubXVsKGNoYWxsYW5nZXMudls1XSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIHMgPSBGci5hZGQocywgRnIubXVsKGNoYWxsYW5nZXMudls2XSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIHMgPSBGci5hZGQocywgRnIubXVsKGNoYWxsYW5nZXMudSwgcHJvb2YuZXZhbF96dykpO1xuXG4gICAgY29uc3QgcmVzID0gRzEudGltZXNGcihHMS5vbmUsIHMpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGFuZ2VzLCB2aywgRSwgRikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBBMSA9IHByb29mLld4aTtcbiAgICBBMSA9IEcxLmFkZChBMSwgRzEudGltZXNGcihwcm9vZi5XeGl3LCBjaGFsbGFuZ2VzLnUpKTtcblxuICAgIGxldCBCMSA9IEcxLnRpbWVzRnIocHJvb2YuV3hpLCBjaGFsbGFuZ2VzLnhpKTtcbiAgICBjb25zdCBzID0gRnIubXVsKEZyLm11bChjaGFsbGFuZ2VzLnUsIGNoYWxsYW5nZXMueGkpLCBGci53W3ZrLnBvd2VyXSk7XG4gICAgQjEgPSBHMS5hZGQoQjEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgcykpO1xuICAgIEIxID0gRzEuYWRkKEIxLCBGKTtcbiAgICBCMSA9IEcxLnN1YihCMSwgRSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoXG4gICAgICAgIEcxLm5lZyhBMSkgLCB2ay5YXzIsXG4gICAgICAgIEIxICwgY3VydmUuRzIub25lXG4gICAgKTtcblxuICAgIHJldHVybiByZXM7XG5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/plonk_verify.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/polynomial/cpolynomial.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/polynomial/cpolynomial.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPolynomial: () => (/* binding */ CPolynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _polynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polynomial.js */ \"(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\n\n\n\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.log2)(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new _polynomial_js__WEBPACK_IMPORTED_MODULE_2__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9jcG9seW5vbWlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxJQUFJLElBQUksSUFBSTtBQUNsRTtBQUNBOztBQUV1QztBQUNQO0FBQ1c7O0FBRXBDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFJO0FBQ3ZDOztBQUVBLDZCQUE2QixzREFBVSxLQUFLLG1EQUFTOztBQUVyRCx3QkFBd0IsZUFBZTtBQUN2QztBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3BvbHlub21pYWwvY3BvbHlub21pYWwuanM/ZmNlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBDUG9seW5vbWlhbCBpcyBhIENvbWJpbmVkIFBvbHlub21pYWwgb2YgdGhlIHR5cGUgOlxuLy8gQ1BvbHlub21pYWwoWCkgOj0gUF8wKFhebikgKyBYwrdQXzEoWF5uKSArIC4uLiArIFhee24tMX3Ct1Bfe24tMX0oWF5uKVxuLy8gV2UgY2FuIHVzZSB0aGlzIGNsYXNzIHRvIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIGEgYmlnIG1lbW9yeSBidWZmZXJcbi8vIGZvciB0aGUgY29lZmZpY2llbnRzIGJlY2F1c2UgaW4gc29tZSBjYXNlcyBhIGJpZyBudW1iZXIgb2YgdGhlIGNvZWZmaWNpZW50cyBhcmUgemVyb1xuXG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IHtsb2cyfSBmcm9tIFwiLi4vbWlzYy5qc1wiO1xuaW1wb3J0IHtQb2x5bm9taWFsfSBmcm9tIFwiLi9wb2x5bm9taWFsLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBDUG9seW5vbWlhbCB7XG4gICAgY29uc3RydWN0b3IobiwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLm4gPSBuO1xuICAgICAgICB0aGlzLnBvbHlub21pYWxzID0gQXJyYXkobikuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMuRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgdGhpcy5HMSA9IGN1cnZlLkcxO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBhZGRQb2x5bm9taWFsKHBvc2l0aW9uLCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubiAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNQb2x5bm9taWFsOmFkZFBvbHlub21pYWwsIGNhbm5vdCBhZGQgYSBwb2x5bm9taWFsIHRvIGEgcG9zaXRpb24gZ3JlYXRlciB0aGFuIG4tMVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9seW5vbWlhbHNbcG9zaXRpb25dID0gcG9seW5vbWlhbDtcbiAgICB9XG5cbiAgICBkZWdyZWUoKSB7XG4gICAgICAgIGxldCBkZWdyZWVzID0gdGhpcy5wb2x5bm9taWFscy5tYXAoXG4gICAgICAgICAgICAocG9seW5vbWlhbCwgaW5kZXgpID0+IHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBwb2x5bm9taWFsLmRlZ3JlZSgpICogdGhpcy5uICsgaW5kZXgpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoLi4uZGVncmVlcyk7XG4gICAgfVxuXG4gICAgZ2V0UG9seW5vbWlhbCgpIHtcbiAgICAgICAgbGV0IGRlZ3JlZXMgPSB0aGlzLnBvbHlub21pYWxzLm1hcChwb2x5bm9taWFsID0+IHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBwb2x5bm9taWFsLmRlZ3JlZSgpKTtcbiAgICAgICAgY29uc3QgbWF4RGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyID0gMiAqKiAobG9nMihtYXhEZWdyZWUgLSAxKSArIDEpO1xuICAgICAgICBjb25zdCBzRnIgPSB0aGlzLkZyLm44O1xuXG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihsZW5ndGhCdWZmZXIgKiBzRnIpLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhEZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiBzRnI7XG4gICAgICAgICAgICBjb25zdCBpX3NGciA9IGlfbjggKiB0aGlzLm47XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb2x5bm9taWFsc1tqXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDw9IGRlZ3JlZXNbal0pIHBvbHlub21pYWwuY29lZi5zZXQodGhpcy5wb2x5bm9taWFsc1tqXS5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyBzRnIpLCBpX3NGciArIGogKiBzRnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGFzeW5jIG11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgbmFtZSkge1xuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IHRoaXMuZ2V0UG9seW5vbWlhbCgpO1xuICAgICAgICBjb25zdCBuID0gcG9seW5vbWlhbC5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBjb25zdCBQVGF1TiA9IFBUYXUuc2xpY2UoMCwgbiAqIHRoaXMuRzEuRi5uOCAqIDIpO1xuICAgICAgICBjb25zdCBibSA9IGF3YWl0IHRoaXMuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShwb2x5bm9taWFsLmNvZWYpO1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy5HMS5tdWx0aUV4cEFmZmluZShQVGF1TiwgYm0sIHRoaXMubG9nZ2VyLCBuYW1lKTtcbiAgICAgICAgcmVzID0gdGhpcy5HMS50b0FmZmluZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/polynomial/cpolynomial.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/polynomial/evaluations.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/polynomial/evaluations.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Evaluations: () => (/* binding */ Evaluations)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXVDOztBQUVoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxtREFBUztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3BvbHlub21pYWwvZXZhbHVhdGlvbnMuanM/ZmYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbHVhdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGV2YWx1YXRpb25zLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZXZhbCA9IGV2YWx1YXRpb25zO1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMuRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGZyb21Qb2x5bm9taWFsKHBvbHlub21pYWwsIGV4dGVuc2lvbiwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBjb2VmZmljaWVudHNOID0gbmV3IEJpZ0J1ZmZlcihwb2x5bm9taWFsLmxlbmd0aCgpICogZXh0ZW5zaW9uICogY3VydmUuRnIubjgpO1xuICAgICAgICBjb2VmZmljaWVudHNOLnNldChwb2x5bm9taWFsLmNvZWYsIDApO1xuXG4gICAgICAgIGNvbnN0IGV2YWx1YXRpb25zID0gYXdhaXQgY3VydmUuRnIuZmZ0KGNvZWZmaWNpZW50c04pO1xuXG4gICAgICAgIHJldHVybiBuZXcgRXZhbHVhdGlvbnMoZXZhbHVhdGlvbnMsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGdldEV2YWx1YXRpb24oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaV9uOCA9IGluZGV4ICogdGhpcy5Gci5uODtcblxuICAgICAgICBpZiAoaV9uOCArIHRoaXMuRnIubjggPiB0aGlzLmV2YWwuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZhbHVhdGlvbnMuZ2V0RXZhbHVhdGlvbigpIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmV2YWwuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE1hdGguZmxvb3IodGhpcy5ldmFsLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBldmFsdWF0aW9ucyBidWZmZXIgaGFzIGluY29ycmVjdCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQb2x5bm9taWFsIGhhcyBsZW5ndGggemVyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/polynomial/evaluations.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/polynomial/polynomial.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polynomial: () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        for (let i = domainSize; i < domainSize * extensions; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9wb2x5bm9taWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qix3QkFBd0Isa0JBQWtCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsbURBQVM7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLG1EQUFTO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLHFFQUFxRSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTs7QUFFQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsT0FBTztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYzs7QUFFMUM7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsNkJBQTZCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUzs7QUFFekI7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEUsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVMsV0FBVyxTQUFTO0FBQ2pHLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7O0FBRUEsaUVBQWlFLG1EQUFTO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZSxXQUFXLFNBQVM7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL3BvbHlub21pYWwuanM/M2IwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgY2xhc3MgUG9seW5vbWlhbCB7XG4gICAgY29uc3RydWN0b3IoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGZyb21FdmFsdWF0aW9ucyhidWZmZXIsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IGF3YWl0IGN1cnZlLkZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUNvZWZmaWNpZW50c0FycmF5KGFycmF5LCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGxldCBidWZmID0gYXJyYXkubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKGFycmF5Lmxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYnVmZi5zZXQoYXJyYXlbaV0sIGkgKiBGci5uOCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUG9seW5vbWlhbChwb2x5bm9taWFsLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBsZXQgRnIgPSBjdXJ2ZS5GcjtcblxuICAgICAgICBsZXQgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KHBvbHlub21pYWwuY29lZi5zbGljZSgpLCAwKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgaXNFcXVhbChwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IGRlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGlmIChkZWdyZWUgIT09IHBvbHlub21pYWwuZGVncmVlKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmVxKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGkpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYmxpbmRDb2VmZmljaWVudHMoYmxpbmRpbmdGYWN0b3JzKSB7XG4gICAgICAgIGJsaW5kaW5nRmFjdG9ycyA9IGJsaW5kaW5nRmFjdG9ycyB8fCBbXTtcblxuICAgICAgICBjb25zdCBibGluZGVkQ29lZmZpY2llbnRzID0gKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigodGhpcy5sZW5ndGgoKSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogdGhpcy5Gci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KHRoaXMuY29lZiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZSgodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOCwgKHRoaXMubGVuZ3RoKCkgKyBpICsgMSkgKiB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNsaWNlKGkgKiB0aGlzLkZyLm44LCAoaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2VmID0gYmxpbmRlZENvZWZmaWNpZW50cztcbiAgICB9XG5cbiAgICBnZXRDb2VmKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5jb2VmLmJ5dGVMZW5ndGgpIHJldHVybiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc2V0Q29lZihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gKHRoaXMubGVuZ3RoKCkgLSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29lZiBpbmRleCBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmLnNldCh2YWx1ZSwgaW5kZXggKiB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgdG80VChidWZmZXIsIGRvbWFpblNpemUsIGJsaW5kaW5nRmFjdG9ycywgRnIpIHtcbiAgICAgICAgYmxpbmRpbmdGYWN0b3JzID0gYmxpbmRpbmdGYWN0b3JzIHx8IFtdO1xuICAgICAgICBsZXQgYSA9IGF3YWl0IEZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBhNCA9IChkb21haW5TaXplICogNCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShkb21haW5TaXplICogNCAqIEZyLm44KTtcbiAgICAgICAgYTQuc2V0KGEsIDApO1xuXG4gICAgICAgIGNvbnN0IEE0ID0gYXdhaXQgRnIuZmZ0KGE0KTtcblxuICAgICAgICBpZiAoYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBBNF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhMSA9IGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKChkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiBGci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIEZyLm44KTtcblxuICAgICAgICBhMS5zZXQoYSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhMS5zZXQoXG4gICAgICAgICAgICAgICAgRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBhMS5zbGljZSgoZG9tYWluU2l6ZSArIGkpICogRnIubjgsIChkb21haW5TaXplICsgaSArIDEpICogRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkb21haW5TaXplICsgaSkgKiBGci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGExLnNldChcbiAgICAgICAgICAgICAgICBGci5zdWIoXG4gICAgICAgICAgICAgICAgICAgIGExLnNsaWNlKGkgKiBGci5uOCwgKGkgKyAxKSAqIEZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ExLCBBNF07XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBNYXRoLmZsb29yKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgY29lZmZpY2llbnRzIGJ1ZmZlciBoYXMgaW5jb3JyZWN0IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBvbHlub21pYWwgaGFzIGxlbmd0aCB6ZXJvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGlmICghdGhpcy5Gci5lcSh0aGlzLkZyLnplcm8sIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShwb2ludCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRlZ3JlZSgpICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2VmZmljaWVudCA9IHRoaXMuY29lZi5zbGljZShpX244IC0gdGhpcy5Gci5uOCwgaV9uOCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLkZyLmFkZChjdXJyZW50Q29lZmZpY2llbnQsIHRoaXMuRnIubXVsKHJlcywgcG9pbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZmFzdEV2YWx1YXRlKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcblxuICAgICAgICBsZXQgbkNvZWZzID0gdGhpcy5kZWdyZWUoKSArIDE7XG4gICAgICAgIGxldCBjb2Vmc1RocmVhZCA9IHBhcnNlSW50KG5Db2VmcyAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IHJlc2lkdWFsQ29lZnMgPSBuQ29lZnMgLSBjb2Vmc1RocmVhZCAqIG5UaHJlYWRzO1xuXG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgbGV0IHhOID0gW107XG5cbiAgICAgICAgeE5bMF0gPSBGci5vbmU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuVGhyZWFkczsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBsZXQgbkNvZWZzID0gaSA9PT0gKG5UaHJlYWRzIC0gMSkgPyBjb2Vmc1RocmVhZCArIHJlc2lkdWFsQ29lZnMgOiBjb2Vmc1RocmVhZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBuQ29lZnM7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBGci5hZGQodGhpcy5nZXRDb2VmKChpICogY29lZnNUaHJlYWQpICsgaiAtIDEpLCBGci5tdWwocmVzW2ldLCBwb2ludCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHhOWzBdID0gRnIubXVsKHhOWzBdLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5UaHJlYWRzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1swXSA9IEZyLmFkZChyZXNbMF0sIEZyLm11bCh4TltpIC0gMV0sIHJlc1tpXSkpO1xuICAgICAgICAgICAgeE5baV0gPSBGci5tdWwoeE5baSAtIDFdLCB4TlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgIH1cblxuICAgIGFkZChwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLmFkZChhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5hZGQoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1Yihwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLnN1YihhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11bFNjYWxhcih2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubXVsKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCksIHZhbHVlKSwgaV9uOCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gMCA9PT0gdGhpcy5sZW5ndGgoKSA/IHRoaXMuRnIuemVybyA6IHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KTtcbiAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLmFkZChjdXJyZW50VmFsdWUsIHZhbHVlKSwgMCk7XG4gICAgfVxuXG4gICAgc3ViU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IDAgPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLkZyLnplcm8gOiB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCk7XG4gICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoY3VycmVudFZhbHVlLCB2YWx1ZSksIDApO1xuICAgIH1cblxuICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgcG9seW5vbWlhbCBieSB0aGUgcG9seW5vbWlhbCAoWCAtIHZhbHVlKVxuICAgIGJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgcmVzaXplID0gIUZyLmVxKEZyLnplcm8sIHRoaXMuZ2V0Q29lZih0aGlzLmxlbmd0aCgpIC0gMSkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyAxIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChsZW5ndGggLSAxKSAqIEZyLm44KSwgMzIpO1xuXG4gICAgICAgIC8vIFN0ZXAgMTogbXVsdGlwbHkgZWFjaCBjb2VmZmljaWVudCBieSAoLXZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcihGci5uZWcodmFsdWUpKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFhebiArIHZhbHVlKVxuICAgIGJ5WE5TdWJWYWx1ZShuLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICEodGhpcy5sZW5ndGgoKSAtIG4gLSAxID49IHRoaXMuZGVncmVlKCkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyBuIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsICh0aGlzLmRlZ3JlZSgpICsgMSkgKiAzMiwgKSwgbiAqIDMyKTtcblxuICAgICAgICAvLyBTdGVwIDE6IG11bHRpcGx5IGVhY2ggY29lZmZpY2llbnQgYnkgKC0gdmFsdWUpXG4gICAgICAgIHRoaXMubXVsU2NhbGFyKHZhbHVlKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBFdWNsaWRlYW4gZGl2aXNpb25cbiAgICBkaXZCeShwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgZGVncmVlQSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUIgPSBwb2x5bm9taWFsLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBwb2xSID0gbmV3IFBvbHlub21pYWwodGhpcy5jb2VmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gZGVncmVlQSAtIGRlZ3JlZUI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSwgRnIuZGl2KHBvbFIuZ2V0Q29lZihpICsgZGVncmVlQiksIHBvbHlub21pYWwuZ2V0Q29lZihkZWdyZWVCKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gZGVncmVlQjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGkgKyBqLCBGci5zdWIocG9sUi5nZXRDb2VmKGkgKyBqKSwgRnIubXVsKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGopKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgLy8gRGl2aXNpb24gYnkgYSBQb2x5bm9taWFsIG9mIHRoZSBmb3JtICh4Xm0gLSBiZXRhKVxuICAgIGRpdkJ5TW9uaWMobSwgYmV0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IGQgPSB0aGlzLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuICAgICAgICBsZXQgcXVvdGllbnQgPSBuZXcgUG9seW5vbWlhbChidWZmZXIsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBsZXQgYkFyciA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbSBsZWFkaW5nIGNvZWZmaWNpZW50cyBvZiB0aGlzIHRvIHF1b3RpZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKChkIC0gaSkgLSBtLCB0aGlzLmdldENvZWYoZCAtIGkpKTtcbiAgICAgICAgICAgIGJBcnJbaV0gPSB0aGlzLmdldENvZWYoZCAtIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gbTtcblxuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGQgLSAyICogbSAtIGs7IGkgPj0gMDsgaSA9IGkgLSBuVGhyZWFkcykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IGs7XG4gICAgICAgICAgICAgICAgYkFycltpZHhdID0gRnIuYWRkKHRoaXMuZ2V0Q29lZihpICsgbSksIEZyLm11bChiQXJyW2lkeF0sIGJldGEpKTtcblxuICAgICAgICAgICAgICAgIHF1b3RpZW50LnNldENvZWYoaSwgYkFycltpZHhdKTtcbiAgICAgICAgICAgICAgICBqID0gKGogKyAxKSAlIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvZWYgPSBxdW90aWVudC5jb2VmO1xuICAgIH1cblxuICAgIGRpdkJ5VmFuaXNoaW5nKG4sIGJldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAxOyBpID49IG47IGktLSkge1xuICAgICAgICAgICAgbGV0IGxlYWRpbmdDb2VmID0gcG9sUi5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgaWYgKEZyLmVxKEZyLnplcm8sIGxlYWRpbmdDb2VmKSkgY29udGludWU7XG5cbiAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpLCBGci56ZXJvKTtcbiAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpIC0gbiwgRnIuYWRkKHBvbFIuZ2V0Q29lZihpIC0gbiksIEZyLm11bChiZXRhLCBsZWFkaW5nQ29lZikpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpIC0gbiwgRnIuYWRkKHRoaXMuZ2V0Q29lZihpIC0gbiksIGxlYWRpbmdDb2VmKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZzIobSwgYmV0YSkge1xuICAgICAgICBpZiAodGhpcy5kZWdyZWUoKSA8IG0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpdkJ5VmFuaXNoaW5nIHBvbHlub21pYWwgZGl2aXNvciBtdXN0IGJlIG9mIGRlZ3JlZSBsb3dlciB0aGFuIHRoZSBkaXZpZGVuZCBwb2x5bm9taWFsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuXG4gICAgICAgIGxldCBwb2xSID0gbmV3IFBvbHlub21pYWwodGhpcy5jb2VmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBsZXQgblRocmVhZHMgPSAzO1xuICAgICAgICBsZXQgblRvdGFsID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgIGxldCBuRWxlbWVudHNDaHVuayA9IE1hdGguZmxvb3IoblRvdGFsIC8gblRocmVhZHMpO1xuICAgICAgICBsZXQgbkVsZW1lbnRzTGFzdCA9IG5Ub3RhbCAtIChuVGhyZWFkcyAtIDEpICogbkVsZW1lbnRzQ2h1bms7XG5cbiAgICAgICAgY29uc29sZS5sb2coblRvdGFsKTtcbiAgICAgICAgY29uc29sZS5sb2cobkVsZW1lbnRzQ2h1bmsgKyBcIiAgXCIgKyBuRWxlbWVudHNMYXN0KTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuVGhyZWFkczsgaysrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIj4gVGhyZWFkIFwiICsgayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gKGsgPT09IDAgPyBuRWxlbWVudHNMYXN0IDogbkVsZW1lbnRzQ2h1bmspOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeERzdCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChrICE9PSAwKSBpZHhEc3QgKz0gKGsgLSAxKSAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgaWR4U3JjID0gaWR4RHN0ICsgbTtcblxuICAgICAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpZHhTcmMpO1xuICAgICAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeFNyYywgRnIuemVybyk7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHBvbFIuZ2V0Q29lZihpZHhEc3QpLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHRoaXMuZ2V0Q29lZihpZHhEc3QpLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGlkeERzdCArIFwiIDwtLSBcIiArIGlkeFNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIGZhc3REaXZCeVZhbmlzaGluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgbGV0IG0gPSBkYXRhW2ldWzBdO1xuICAgICAgICAgICAgbGV0IGJldGEgPSBkYXRhW2ldWzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kZWdyZWUoKSA8IG0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG5UaHJlYWRzID0gNTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHMgPSB0aGlzLmxlbmd0aCgpIC0gbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNCdWNrZXQgPSBNYXRoLmZsb29yKG5FbGVtZW50cyAvIG5UaHJlYWRzIC8gbSk7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBuRWxlbWVudHNCdWNrZXQgKiBtO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuRWxlbWVudHMgLSBuVGhyZWFkcyAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgICAgICAvL0luIEMrKyBpbXBsZW1lbnRhdGlvbiB0aGlzIGJ1ZmZlciB3aWxsIGJlIGFsbG9jYXRlZCBvbmx5IG9uY2Ugb3V0c2lkZSB0aGUgbG9vcFxuICAgICAgICAgICAgbGV0IHBvbFRtcCA9IG5ldyBQb2x5bm9taWFsKHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgICAgIGxldCBwdHIgPSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2xUbXAuY29lZjtcbiAgICAgICAgICAgIHBvbFRtcC5jb2VmID0gcHRyO1xuXG4gICAgICAgICAgICAvLyBTVEVQIDE6IFNldGVqYXIgZWxzIG0gdmFsb3JzIGRlbCBzZWfDvGVudCBidWNrZXQgYWwgY2h1bmsgYWN0dWFsLCBQQVJBTEVMwrdMSVRaQVJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gKGsgKyAxKSAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCArIGkgLSBtLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgaSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkVsZW1lbnRzQ2h1bmsgLSBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCAtIG0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NURVAgMjogU2V0ZWphciBlbHMgdmFsb3JzIGRlbCBlbGVtZW50cyBsYXN0IE5PIFBBUkFMwrdMRUxJVFpBUlxuICAgICAgICAgICAgbGV0IGlkeDAgPSBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtICYmIHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpZHgwIC0gaSAtIDEsIHBvbFRtcC5nZXRDb2VmKGlkeDAgKyBtIC0gaSAtIDEpKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gRnIuYWRkKHBvbFRtcC5nZXRDb2VmKG9mZnNldCksIEZyLm11bChiZXRhLCB0aGlzLmdldENvZWYob2Zmc2V0KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1N0ZXAgMzogY2FsY3VsYXIgYWN1bXVsYXRzIE5PICBQQVJBTEVMwrdMSVRaQVJcblxuICAgICAgICAgICAgbGV0IGFjYyA9IFtdO1xuICAgICAgICAgICAgbGV0IGJldGFQb3cgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0J1Y2tldDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmV0YVBvdyA9IEZyLm11bChiZXRhUG93LCBiZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50QmV0YSA9IEZyLm9uZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IG5UaHJlYWRzOyBrID4gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkVGhyZWFkID0gayAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGlkeDAgPSBpZFRocmVhZCAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gdGhpcy5nZXRDb2VmKGlkeDAgKyBpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoayAhPT0gblRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tpZFRocmVhZF1baV0gPSBGci5hZGQoYWNjW2lkVGhyZWFkXVtpXSwgRnIubXVsKGJldGFQb3csIGFjY1tpZFRocmVhZCArIDFdW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudEJldGEgPSBGci5tdWwoY3VycmVudEJldGEsIGJldGFQb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NURVAgNCByZWNhbGN1bGFyICBQQVJBTEVMwrdMSVRaQVJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGlkeDAgPSBrICogbkVsZW1lbnRzQ2h1bmsgKyBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QmV0YSA9IGJldGE7IC8vUXVhbiBob3Bhc3NlbSBhIEMrKyBpIGhvIHBhcmFsZWxpdHplbSBhcXVlc3RhIHZhcmlhYmxlIGhhIGRlIHNlciBwcml2YWRhXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRNID0gbSAtIDE7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBrID09PSAwID8gbkVsZW1lbnRzTGFzdCA6IG5FbGVtZW50c0NodW5rO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaWR4MCAtIGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gRnIuYWRkKHRoaXMuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoY3VycmVudEJldGEsIGFjY1trXVtjdXJyZW50TV0pKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0LCB2YWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1vZHVsYXIgb3BlcmF0aW9ucyBpbiBlYWNoIGxvb3AuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TSA9IG0gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJldGEgPSBGci5tdWwoY3VycmVudEJldGEsIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gRGl2aWRlIHBvbHlub21pYWwgYnkgWCAtIHZhbHVlXG4gICAgZGl2QnlYU3ViVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29lZnMgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KTtcblxuICAgICAgICBjb2Vmcy5zZXQodGhpcy5Gci56ZXJvLCAodGhpcy5sZW5ndGgoKSAtIDEpICogdGhpcy5Gci5uOCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYuc2xpY2UoKHRoaXMubGVuZ3RoKCkgLSAxKSAqIHRoaXMuRnIubjgsIHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KSwgKHRoaXMubGVuZ3RoKCkgLSAyKSAqIHRoaXMuRnIubjgpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgY29lZnMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCArIHRoaXMuRnIubjgsIGlfbjggKyAyICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRnIubXVsKHZhbHVlLCBjb2Vmcy5zbGljZShpX244ICsgdGhpcy5Gci5uOCwgaV9uOCArIDIgKiB0aGlzLkZyLm44KSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiB0aGlzLkZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5Gci5lcShcbiAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKHRoaXMuRnIubmVnKHZhbHVlKSwgY29lZnMuc2xpY2UoMCwgdGhpcy5Gci5uOCkpXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgZG9lcyBub3QgZGl2aWRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gY29lZnM7XG4gICAgfVxuXG4gICAgZGl2WmgoZG9tYWluU2l6ZSwgZXh0ZW5zaW9ucyA9IDQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5uZWcodGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSksIGlfbjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGRvbWFpblNpemU7IGkgPCBkb21haW5TaXplICogZXh0ZW5zaW9uczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoKGkgLSBkb21haW5TaXplKSAqIHRoaXMuRnIubjgsIChpIC0gZG9tYWluU2l6ZSkgKiB0aGlzLkZyLm44ICsgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoYSwgaV9uOCk7XG4gICAgICAgICAgICBpZiAoaSA+IChkb21haW5TaXplICogKGV4dGVuc2lvbnMtMSkgLSBleHRlbnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdkJ5WmVyb2ZpZXIobiwgYmV0YSkge1xuICAgICAgICBsZXQgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCBpbnZCZXRhID0gRnIuaW52KGJldGEpO1xuICAgICAgICBjb25zdCBpbnZCZXRhTmVnID0gRnIubmVnKGludkJldGEpO1xuXG4gICAgICAgIGxldCBpc09uZSA9IEZyLmVxKEZyLm9uZSwgaW52QmV0YU5lZyk7XG4gICAgICAgIGxldCBpc05lZ09uZSA9IEZyLmVxKEZyLm5lZ29uZSwgaW52QmV0YU5lZyk7XG5cbiAgICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpbnZCZXRhTmVnID09PSAtMSB3ZSdsbCBzYXZlIGEgbXVsdGlwbGljYXRpb24gY2hhbmdpbmcgaXQgYnkgYSBuZWcgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgIGlmIChpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YU5lZywgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldChlbGVtZW50LCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzT25lID0gRnIuZXEoRnIub25lLCBpbnZCZXRhKTtcbiAgICAgICAgaXNOZWdPbmUgPSBGci5lcShGci5uZWdvbmUsIGludkJldGEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBuOyBpIDwgdGhpcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBpX3ByZXZfbjggPSAoaSAtIG4pICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9wcmV2X244LCBpX3ByZXZfbjggKyB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiBpbnZCZXRhID09PSAxIHdlJ2xsIG5vdCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgaWYoIWlzT25lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW52QmV0YSA9PT0gLTEgd2UnbGwgc2F2ZSBhIG11bHRpcGxpY2F0aW9uIGNoYW5naW5nIGl0IGJ5IGEgbmVnIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICBpZihpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGVsZW1lbnQsIGlfbjgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwb2x5bm9taWFsIGlzIGRpdmlzaWJsZSBieSBjaGVja2luZyBpZiBuIGhpZ2ggY29lZmZpY2llbnRzIGFyZSB6ZXJvXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMubGVuZ3RoKCkgLSBuIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gZnVuY3Rpb24gZGl2aWRlQnlWYW5pc2hpbmcoZiwgbiwgcCkge1xuLy8gICAgIC8vIHBvbHlub21pYWwgZGl2aXNpb24gZihYKSAvIChYXm4gLSAxKSB3aXRoIHJlbWFpbmRlclxuLy8gICAgIC8vIHZlcnkgY2hlYXAsIDAgbXVsdGlwbGljYXRpb25zXG4vLyAgICAgLy8gc3RyYXRlZ3k6XG4vLyAgICAgLy8gc3RhcnQgd2l0aCBxKFgpID0gMCwgcihYKSA9IGYoWClcbi8vICAgICAvLyB0aGVuIHN0YXJ0IGNoYW5naW5nIHEsIHIgd2hpbGUgcHJlc2VydmluZyB0aGUgaWRlbnRpdHk6XG4vLyAgICAgLy8gZihYKSA9IHEoWCkgKiAoWF5uIC0gMSkgKyByKFgpXG4vLyAgICAgLy8gaW4gZXZlcnkgc3RlcCwgbW92ZSBoaWdoZXN0LWRlZ3JlZSB0ZXJtIG9mIHIgaW50byB0aGUgcHJvZHVjdFxuLy8gICAgIC8vID0+IHIgZXZlbnR1YWxseSBoYXMgZGVncmVlIDwgbiBhbmQgd2UncmUgZG9uZVxuLy8gICAgIGxldCBxID0gQXJyYXkoZi5sZW5ndGgpLmZpbGwoMG4pO1xuLy8gICAgIGxldCByID0gWy4uLmZdO1xuLy8gICAgIGZvciAobGV0IGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gbjsgaS0tKSB7XG4vLyAgICAgICAgIGxldCBsZWFkaW5nQ29lZmYgPSByW2ldO1xuLy8gICAgICAgICBpZiAobGVhZGluZ0NvZWZmID09PSAwbikgY29udGludWU7XG4vLyAgICAgICAgIHJbaV0gPSAwbjtcbi8vICAgICAgICAgcltpIC0gbl0gPSBtb2QocltpIC0gbl0gKyBsZWFkaW5nQ29lZmYsIHApO1xuLy8gICAgICAgICBxW2kgLSBuXSA9IG1vZChxW2kgLSBuXSArIGxlYWRpbmdDb2VmZiwgcCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBbcSwgcl07XG4vLyB9XG5cbiAgICBieVgoKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gKHRoaXMubGVuZ3RoKCkgKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5jb2VmLmJ5dGVMZW5ndGggKyB0aGlzLkZyLm44KTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgMCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYsIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuLy8gQ29tcHV0ZSBhIG5ldyBwb2x5bm9taWFsIGYoeF5uKSBmcm9tIGYoeClcbi8vIGYoeCkgICA9IGFfMCArIGFfMcK3eCArIGFfMsK3eF4yICsgLi4uICsgYV9qwrd4Xmpcbi8vIGYoeF5uKSA9IGFfMCArIGFfMcK3eF5uICsgYV8ywrd4XjJuICsgLi4uICsgYV9qwrd4XmpuXG4gICAgc3RhdGljXG4gICAgYXN5bmMgZXhwWChwb2x5bm9taWFsLCBuLCB0cnVuY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gcG9seW5vbWlhbC5GcjtcblxuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIC8vIG4gPT0gMCBub3QgYWxsb3dlZCBiZWNhdXNlIGl0IGhhcyBubyBzZW5zZSwgYnV0IGlmIGl0J3MgbmVjZXNzYXJ5IHdlIGhhdmUgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBhIHplcm8gZGVncmVlIHBvbHlub21pYWwgd2l0aCBhIGNvbnN0YW50IGNvZWZmaWNpZW50IGVxdWFscyB0byB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWwgY29lZmZpY2llbnRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgdG8gYSB6ZXJvIG9yIG5lZ2F0aXZlIG51bWJlciBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICgxID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMocG9seW5vbWlhbC5jb2VmLCBjdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIGlzIHRoZSBsZW5ndGggb2Ygbm9uLWNvbnN0YW50IGNvZWZmaWNpZW50c1xuICAgICAgICAvLyBpZiB0cnVuY2F0ZSA9PT0gdHJ1ZSwgdGhlIGhpZ2hlc3QgemVybyBjb2VmZmljaWVudHMgKGlmIGV4aXN0KSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ1bmNhdGUgPyBwb2x5bm9taWFsLmRlZ3JlZSgpIDogKHBvbHlub21pYWwubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRHN0ID0gKGxlbmd0aCAqIG4gKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigobGVuZ3RoICogbiArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIG4gKyAxKSAqIEZyLm44KTtcblxuICAgICAgICAvLyBDb3B5IGNvbnN0YW50IGNvZWZmaWNpZW50IGFzIGlzIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8geFxuICAgICAgICBidWZmZXJEc3Quc2V0KHBvbHlub21pYWwuZ2V0Q29lZigwKSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBjb2VmID0gcG9seW5vbWlhbC5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgYnVmZmVyRHN0LnNldChjb2VmLCBpX3NGciAqIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmZlckRzdCwgcG9seW5vbWlhbC5jdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgIH1cblxuICAgIHNwbGl0KG51bVBvbHMsIGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBpZiAobnVtUG9scyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbHMgY2FuJ3QgYmUgc3BsaXQgaW4gJHtudW1Qb2xzfSBwYXJ0c2ApO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG51bVBvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4gICAgICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1Qb2xzIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtUG9scyAtIDF9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbiAgICAgICAgY29uc3QgbnVtUmVhbFBvbHMgPSBNYXRoLmNlaWwoKHRoaXMuZGVncmVlKCkgKyAxKSAqIHRoaXMuRnIubjggLyBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobnVtUmVhbFBvbHMgPCBudW1Qb2xzKSB7XG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtUmVhbFBvbHM7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgVWludDhBcnJheSh0aGlzLkZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtUG9scyA9IE1hdGgubWluKG51bVBvbHMsIG51bVJlYWxQb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1Qb2xzIC0gMSkgPT09IGk7XG4gICAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLSAoKG51bVBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgYnVmZiA9IChieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkgPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzW2ldID0gbmV3IFBvbHlub21pYWwoYnVmZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmciA9IGkgKiBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IHRoaXMuY29lZi5ieXRlTGVuZ3RoIDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldCh0aGlzLmNvZWYuc2xpY2UoZnIsIHRvKSwgMCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4gICAgICAgICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChibGluZGluZ0ZhY3RvcnNbaV0sIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YiBibGluZGluZyBmYWN0b3IgdG8gdGhlIGxvd2VzdCBkZWdyZWVcbiAgICAgICAgICAgIGlmICgwICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ZXN0RGVncmVlID0gdGhpcy5Gci5zdWIocmVzW2ldLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksIGJsaW5kaW5nRmFjdG9yc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChsb3dlc3REZWdyZWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldLnRydW5jYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9sb3coWClcbiAgICAgICAgLy8gbGV0IHBvbFRMb3cgPSBuZXcgQmlnQnVmZmVyKChjaHVua1NpemUgKyAxKSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KHQuc2xpY2UoMCwgemtleS5kb21haW5TaXplICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KGNoLmJbMTBdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAvLyBjb21wdXRlIHRfbWlkKFgpXG4gICAgICAgIC8vIGxldCBwb2xUTWlkID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUTWlkLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIG44ciwgemtleS5kb21haW5TaXplICogMiAqIG44ciksIDApO1xuICAgICAgICAvLyAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2xUTWlkLnNsaWNlKDAsIG44ciksIGNoLmJbMTBdKTtcbiAgICAgICAgLy8gcG9sVE1pZC5zZXQobG93ZXN0TWlkLCAwKTtcbiAgICAgICAgLy8gLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzExIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgLy8gcG9sVE1pZC5zZXQoY2guYlsxMV0sIHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9oaWdoKFgpXG4gICAgICAgIC8vIGxldCBwb2xUSGlnaCA9IG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVEhpZ2guc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogMiAqIG44ciwgKHprZXkuZG9tYWluU2l6ZSAqIDMgKyA2KSAqIG44ciksIDApO1xuICAgICAgICAvLyAvL1N1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzExIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9oaWdoXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdEhpZ2ggPSBGci5zdWIocG9sVEhpZ2guc2xpY2UoMCwgbjhyKSwgY2guYlsxMV0pO1xuICAgICAgICAvLyBwb2xUSGlnaC5zZXQobG93ZXN0SGlnaCwgMCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHByb29mLlQxID0gYXdhaXQgZXhwVGF1KHBvbFRMb3csIFwibXVsdGlleHAgVDFcIik7XG4gICAgICAgIC8vIHByb29mLlQyID0gYXdhaXQgZXhwVGF1KHBvbFRNaWQsIFwibXVsdGlleHAgVDJcIik7XG4gICAgICAgIC8vIHByb29mLlQzID0gYXdhaXQgZXhwVGF1KHBvbFRIaWdoLCBcIm11bHRpZXhwIFQzXCIpO1xuICAgIH1cblxuLy8gc3BsaXQyKGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuLy8gICAgIGxldCBjdXJyZW50RGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbi8vICAgICBjb25zdCBudW1GaWxsZWRQb2xzID0gTWF0aC5jZWlsKChjdXJyZW50RGVncmVlICsgMSkgLyAoZGVnUG9scyArIDEpKTtcbi8vXG4vLyAgICAgLy9ibGluZGluZyBmYWN0b3JzIGNhbiBiZSB2b2lkIG9yIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiBudW1Qb2xzIC0gMVxuLy8gICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1GaWxsZWRQb2xzIC0gMSkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsaW5kaW5nIGZhY3RvcnMgbGVuZ3RoIG11c3QgYmUgJHtudW1GaWxsZWRQb2xzIC0gMX1gKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IChkZWdQb2xzICsgMSkgKiB0aGlzLkZyLm44O1xuLy9cbi8vICAgICAvLyBDaGVjayBwb2x5bm9taWFsIGNhbiBiZSBzcGxpdCBpbiBudW1DaHVua3MgcGFydHMgb2YgY2h1bmtTaXplIGJ5dGVzLi4uXG4vLyAgICAgaWYgKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gY2h1bmtCeXRlTGVuZ3RoIDw9IG51bUZpbGxlZFBvbHMgLSAxKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bUZpbGxlZFBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBsZXQgcmVzID0gW107XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GaWxsZWRQb2xzOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaXNMYXN0ID0gKG51bUZpbGxlZFBvbHMgLSAxKSA9PT0gaTtcbi8vICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IC0gKChudW1GaWxsZWRQb2xzIC0gMSkgKiBjaHVua0J5dGVMZW5ndGgpIDogY2h1bmtCeXRlTGVuZ3RoICsgdGhpcy5Gci5uODtcbi8vXG4vLyAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoYnl0ZUxlbmd0aCksIHRoaXMuRnIsIHRoaXMubG9nZ2VyKTtcbi8vICAgICAgICAgY29uc3QgZnIgPSBpICogY2h1bmtCeXRlTGVuZ3RoO1xuLy8gICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbi8vICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZShmciwgdG8pLCAwKTtcbi8vXG4vLyAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4vLyAgICAgICAgIGlmICghaXNMYXN0KSB7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQoYmxpbmRpbmdGYWN0b3JzW2ldLCBjaHVua0J5dGVMZW5ndGgpO1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBTdWIgYmxpbmRpbmcgZmFjdG9yIHRvIHRoZSBsb3dlc3QgZGVncmVlXG4vLyAgICAgICAgIGlmICgwICE9PSBpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBsb3dlc3REZWdyZWUgPSB0aGlzLkZyLnN1YihyZXNbaV0uY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSwgYmxpbmRpbmdGYWN0b3JzW2kgLSAxXSk7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQobG93ZXN0RGVncmVlLCAwKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgcmV0dXJuIHJlcztcbi8vIH1cblxuLy8gbWVyZ2UocG9scywgb3ZlcmxhcCA9IHRydWUpIHtcbi8vICAgICBsZXQgbGVuZ3RoID0gMDtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgbGVuZ3RoICs9IHBvbHNbaV0ubGVuZ3RoKCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBpZiAob3ZlcmxhcCkge1xuLy8gICAgICAgICBsZW5ndGggLT0gcG9scy5sZW5ndGggLSAxO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgbGV0IHJlcyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoICogdGhpcy5Gci5uOCkpO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9scy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gcG9sc1tpXS5jb2VmLmJ5dGVMZW5ndGg7XG4vLyAgICAgICAgIGlmICgwID09PSBpKSB7XG4vLyAgICAgICAgICAgICByZXMuY29lZi5zZXQocG9sc1tpXS5jb2VmLCAwKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIHJldHVybiByZXM7XG4vLyB9XG5cbiAgICB0cnVuY2F0ZSgpIHtcbiAgICAgICAgY29uc3QgZGVnID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgaWYgKGRlZyArIDEgPCB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvZWZzID0gKGRlZyArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZGVnICsgMSkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KChkZWcgKyAxKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgICAgICBuZXdDb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChkZWcgKyAxKSAqIHRoaXMuRnIubjgpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IG5ld0NvZWZzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oeEFyciwgeUFyciwgY3VydmUpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlub21pYWwuYWRkKGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSB7XG4gICAgICAgICAgICBsZXQgcG9seW5vbWlhbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHhBcnIubGVuZ3RoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCkgKiBGci5uOCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFycltqXSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcG9seW5vbWlhbC5ldmFsdWF0ZSh4QXJyW2ldKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gRnIuaW52KGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG11bEZhY3RvciA9IEZyLm11bCh5QXJyW2ldLCBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWwubXVsU2NhbGFyKG11bEZhY3Rvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHplcm9maWVyUG9seW5vbWlhbCh4QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKCh4QXJyLmxlbmd0aCArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKHhBcnIubGVuZ3RoICsgMSkgKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUpO1xuXG4gICAgICAgIC8vIEJ1aWxkIGEgemVyb2ZpZXIgcG9seW5vbWlhbCB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgLy8gemVyb2ZpZXIoWCkgPSAoWC14QXJyWzBdKShYLXhBcnJbMV0pLi4uKFgteEFycltuXSlcbiAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDAsIEZyLm5lZyh4QXJyWzBdKSk7XG4gICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigxLCBGci5vbmUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5ieVhTdWJWYWx1ZSh4QXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIHByaW50KCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZWYgPSB0aGlzLmdldENvZWYoaSk7XG4gICAgICAgICAgICBpZiAoIUZyLmVxKEZyLnplcm8sIGNvZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmlzTmVnYXRpdmUoY29lZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIC0gXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICE9PSB0aGlzLmRlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiArIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMgKz0gRnIudG9TdHJpbmcoY29lZik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBpID4gMSA/IFwieF5cIiArIGkgOiBcInhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkodGhpcy5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/polynomial/polynomial.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   challengeContribute: () => (/* reexport safe */ _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   convert: () => (/* reexport safe */ _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   exportChallenge: () => (/* reexport safe */ _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   importResponse: () => (/* reexport safe */ _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newAccumulator: () => (/* reexport safe */ _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   preparePhase2: () => (/* reexport safe */ _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   truncate: () => (/* reexport safe */ _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_new.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_new.js\");\n/* harmony import */ var _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_export_challenge.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_challenge.js\");\n/* harmony import */ var _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_import.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_import.js\");\n/* harmony import */ var _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./powersoftau_verify.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_verify.js\");\n/* harmony import */ var _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./powersoftau_challenge_contribute.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_challenge_contribute.js\");\n/* harmony import */ var _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./powersoftau_beacon.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_beacon.js\");\n/* harmony import */ var _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./powersoftau_contribute.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_contribute.js\");\n/* harmony import */ var _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./powersoftau_preparephase2.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_preparephase2.js\");\n/* harmony import */ var _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./powersoftau_truncate.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_truncate.js\");\n/* harmony import */ var _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./powersoftau_convert.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_convert.js\");\n/* harmony import */ var _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./powersoftau_export_json.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStEO0FBQ2M7QUFDWDtBQUNSO0FBQzJCO0FBQzNCO0FBQ1E7QUFDTTtBQUNWO0FBQ0Y7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1LmpzPzBhMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIG5ld0FjY3VtdWxhdG9yfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9uZXcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRDaGFsbGVuZ2V9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2V4cG9ydF9jaGFsbGVuZ2UuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbXBvcnRSZXNwb25zZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfaW1wb3J0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdmVyaWZ5fSBmcm9tIFwiLi9wb3dlcnNvZnRhdV92ZXJpZnkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjaGFsbGVuZ2VDb250cmlidXRlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9jaGFsbGVuZ2VfY29udHJpYnV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJlYWNvbn0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfYmVhY29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY29udHJpYnV0ZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfY29udHJpYnV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHByZXBhcmVQaGFzZTJ9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X3ByZXBhcmVwaGFzZTIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cnVuY2F0ZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjb252ZXJ0fSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9jb252ZXJ0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0SnNvbn0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfZXhwb3J0X2pzb24uanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_beacon.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_beacon.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_2__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum lenght of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDYTtBQUNkO0FBQ2tCOztBQUVyQztBQUNmLHVCQUF1QixtREFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBVSwrQ0FBYTs7QUFFdkIsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUEsMEJBQTBCLGdFQUFtQjs7QUFFN0MsK0JBQStCLHlDQUFPO0FBQ3RDOztBQUVBLHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSSxrRUFBcUI7O0FBRXpCO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQyxvQ0FBb0MseUNBQU87QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDOztBQUVBLFVBQVUscUVBQXdCOztBQUVsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGtFQUE4Qjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLG9EQUFvRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOztBQUUxQztBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxnREFBZ0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQzdFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzP2NjY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGJlYWNvbihvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgIGJlYWNvbkhhc2hTdHIsbnVtSXRlcmF0aW9uc0V4cCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgYmVhY29uSGFzaCA9IG1pc2MuaGV4MkJ5dGVBcnJheShiZWFjb25IYXNoU3RyKTtcbiAgICBpZiAoICAgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCA9PSAwKVxuICAgICAgICB8fCAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoKjIgIT1iZWFjb25IYXNoU3RyLmxlbmd0aCkpXG4gICAge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIEJlYWNvbiBIYXNoLiAoSXQgbXVzdCBiZSBhIHZhbGlkIGhleGFkZWNpbWFsIHNlcXVlbmNlKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmVhY29uSGFzaC5sZW5ndGg+PTI1Nikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJNYXhpbXVtIGxlbmdodCBvZiBiZWFjb24gaGFzaCBpcyAyNTUgYnl0ZXNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1JdGVyYXRpb25zRXhwID0gcGFyc2VJbnQobnVtSXRlcmF0aW9uc0V4cCk7XG4gICAgaWYgKChudW1JdGVyYXRpb25zRXhwPDEwKXx8KG51bUl0ZXJhdGlvbnNFeHA+NjMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtSXRlcmF0aW9uc0V4cC4gKE11c3QgYmUgYmV0d2VlbiAxMCBhbmQgNjMpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGlmIChwb3dlciAhPSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25zWzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIud2FybihcIkNvbnRyaWJ1dGluZyBpbnRvIGEgZmlsZSB0aGF0IGhhcyBwaGFzZTIgY2FsY3VsYXRlZC4gWW91IHdpbGwgaGF2ZSB0byBwcmVwYXJlIHBoYXNlMiBhZ2Fpbi5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IDEsIC8vIEJlYWNvblxuICAgICAgICBudW1JdGVyYXRpb25zRXhwOiBudW1JdGVyYXRpb25zRXhwLFxuICAgICAgICBiZWFjb25IYXNoOiBiZWFjb25IYXNoXG4gICAgfTtcblxuICAgIGxldCBsYXN0Q2hhbGxlbmdlSGFzaDtcblxuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBjdXJDb250cmlidXRpb24ua2V5ID0gdXRpbHMua2V5RnJvbUJlYWNvbihjdXJ2ZSwgbGFzdENoYWxsZW5nZUhhc2gsIGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBuZXcgQmxha2UyYig2NCk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGxhc3RDaGFsbGVuZ2VIYXNoKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgNyk7XG4gICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuXG4gICAgbGV0IGZpcnN0UG9pbnRzO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICogMiAtMSwgY3VydmUuRnIuZSgxKSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcInRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMSA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgXCJHMlwiLCAgKDIgKiogcG93ZXIpICwgY3VydmUuRnIuZSgxKSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcInRhdUcyXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMiA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5hbHBoYS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5hbHBoYUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzEgPSBmaXJzdFBvaW50c1swXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDYsIFwiRzJcIiwgIDEsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYmV0YS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJiZXRhVGF1RzJcIiwgbG9nZ2VyICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMiA9IGZpcnN0UG9pbnRzWzBdO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnBhcnRpYWxIYXNoID0gcmVzcG9uc2VIYXNoZXIuZ2V0UGFydGlhbEhhc2goKTtcblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcblxuICAgIHV0aWxzLnRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmtleSwgZmFsc2UpO1xuXG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gbmV3IEJsYWtlMmIoNjQpO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIiwgbG9nZ2VyKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSwgXCJOZXh0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB1dGlscy53cml0ZUNvbnRyaWJ1dGlvbnMoZmROZXcsIGN1cnZlLCBjb250cmlidXRpb25zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIHJldHVybiBoYXNoUmVzcG9uc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgTlBvaW50cywgZmlyc3QsIGluYywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZmRPbGQucG9zID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5wO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBhcHBseWluZyBrZXkke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_beacon.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_challenge_contribute.js":
/*!*******************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_challenge_contribute.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ challengeContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\nasync function challengeContribute(curve, challengeFilename, responesFileName, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responesFileName);\n\n    // Calculate the hash\n    const challengeHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_5__.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY2hhbGxlbmdlX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDRjtBQUNhO0FBQ2Q7QUFDNkI7QUFDdkI7O0FBRXpCO0FBQ2YsVUFBVSwrQ0FBYTs7QUFFdkIseUJBQXlCLGtEQUFxQjs7O0FBRzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixrREFBaUI7O0FBRXZDLHVCQUF1QixvREFBdUI7O0FBRTlDO0FBQ0EsNEJBQTRCLHlDQUFPO0FBQ25DLGtCQUFrQixvQkFBb0I7QUFDdEMsc0RBQXNELEVBQUUsR0FBRyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0EsNEJBQTRCLGdEQUFlOztBQUUzQyxnQkFBZ0Isc0RBQXFCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwyQkFBMkIseUNBQU87O0FBRWxDO0FBQ0E7O0FBRUEsVUFBVSw0RUFBMEI7QUFDcEMsVUFBVSw0RUFBMEI7QUFDcEMsVUFBVSw0RUFBMEI7QUFDcEMsVUFBVSw0RUFBMEI7QUFDcEMsVUFBVSw0RUFBMEI7O0FBRXBDO0FBQ0E7QUFDQSxJQUFJLGtFQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzP2JlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRm9ybWF0IG9mIHRoZSBvdXRwdXRcbi8vICAgICAgSGFzaCBvZiB0aGUgbGFzdCBjb250cmlidXRpb24gIDY0IEJ5dGVzXG4vLyAgICAgIDJeTioyLTEgVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gVGF1RzIgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQWxwaGFUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBCZXRhVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICBQdWJsaWMgS2V5XG4vLyAgICAgICAgICBCZXRhRzIgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSpzIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqcyp0YXUgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp0IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdCphbHBoYSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnUgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp1KmJldGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMipzcCp0YXUgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMip0cCphbHBoYSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnVwKmJldGEgKGNvbXByZXNzZWQpXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24gfSBmcm9tIFwiLi9tcGNfYXBwbHlrZXkuanNcIjtcbmltcG9ydCAqIGFzIGtleVBhaXIgZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjaGFsbGVuZ2VDb250cmlidXRlKGN1cnZlLCBjaGFsbGVuZ2VGaWxlbmFtZSwgcmVzcG9uZXNGaWxlTmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3QgZmRGcm9tID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKGNoYWxsZW5nZUZpbGVuYW1lKTtcblxuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRjEubjY0KjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5GMi5uNjQqOCoyO1xuICAgIGNvbnN0IGRvbWFpblNpemUgPSAoZmRGcm9tLnRvdGFsU2l6ZSArIHNHMSAtIDY0IC0gc0cyKSAvICg0KnNHMSArIHNHMik7XG4gICAgbGV0IGUgPSBkb21haW5TaXplO1xuICAgIGxldCBwb3dlciA9IDA7XG4gICAgd2hpbGUgKGU+MSkge1xuICAgICAgICBlID0gZSAvMjtcbiAgICAgICAgcG93ZXIgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoMiAqKiBwb3dlciAhPSBkb21haW5TaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpbGUgc2l6ZVwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJQb3dlciB0byB0YXUgc2l6ZTogXCIrcG93ZXIpO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5nZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCBmZFRvID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUocmVzcG9uZXNGaWxlTmFtZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhhc2hcbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoZXIgPSBCbGFrZTJiKDY0KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8ZmRGcm9tLnRvdGFsU2l6ZTsgaSs9IGZkRnJvbS5wYWdlU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgY2hhbGxlbmdlICR7aX0vJHtmZEZyb20udG90YWxTaXplfWApO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5taW4oZmRGcm9tLnRvdGFsU2l6ZSAtIGksIGZkRnJvbS5wYWdlU2l6ZSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChzKTtcbiAgICAgICAgY2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFpbWVkSGFzaCA9IGF3YWl0IGZkRnJvbS5yZWFkKDY0LCAwKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY2xhaW1lZEhhc2gsIFwiQ2xhaW1lZCBQcmV2aW91cyBSZXNwb25zZSBIYXNoOiBcIikpO1xuXG4gICAgY29uc3QgY2hhbGxlbmdlSGFzaCA9IGNoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY2hhbGxlbmdlSGFzaCwgXCJDdXJyZW50IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgY29uc3Qga2V5ID0ga2V5UGFpci5jcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBbXCJ0YXVcIiwgXCJhbHBoYVwiLCBcImJldGFcIl0uZm9yRWFjaCggKGspID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzFfczogXCIgKyBjdXJ2ZS5HMS50b1N0cmluZyhrZXlba10uZzFfcywgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzFfc3g6IFwiICsgY3VydmUuRzEudG9TdHJpbmcoa2V5W2tdLmcxX3N4LCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMl9zcDogXCIgKyBjdXJ2ZS5HMi50b1N0cmluZyhrZXlba10uZzJfc3AsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcyX3NweDogXCIgKyBjdXJ2ZS5HMi50b1N0cmluZyhrZXlba10uZzJfc3B4LCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IEJsYWtlMmIoNjQpO1xuXG4gICAgYXdhaXQgZmRUby53cml0ZShjaGFsbGVuZ2VIYXNoKTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoY2hhbGxlbmdlSGFzaCk7XG5cbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikqMi0xLCBjdXJ2ZS5Gci5vbmUgICAgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwidGF1RzFcIiAgICAgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMlwiLCAoMiAqKiBwb3dlcikgICAgLCBjdXJ2ZS5Gci5vbmUgICAgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwidGF1RzJcIiAgICAgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgLCBrZXkuYWxwaGEucHJ2S2V5LCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgLCBrZXkuYmV0YS5wcnZLZXkgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYmV0YVRhdUcxXCIgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMlwiLCAxICAgICAgICAgICAgICwga2V5LmJldGEucHJ2S2V5ICwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcImJldGFUYXVHMlwiICwgbG9nZ2VyICk7XG5cbiAgICAvLyBXcml0ZSBhbmQgaGFzaCBrZXlcbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG4gICAgdXRpbHMudG9QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBrZXksIGZhbHNlKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmZLZXkpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmS2V5KTtcbiAgICBjb25zdCByZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gocmVzcG9uc2VIYXNoLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_challenge_contribute.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_contribute.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_contribute.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contribute)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\n\n\n\n\n\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = _keypair_js__WEBPACK_IMPORTED_MODULE_2__.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDYTtBQUNSO0FBQ1k7QUFDbEI7O0FBRW5CO0FBQ2YsVUFBVSwrQ0FBYTs7QUFFdkIsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixrREFBaUI7O0FBRXZDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCLDhFQUFpQztBQUM3RDs7QUFFQTs7O0FBR0EsMEJBQTBCLHNEQUFxQjs7O0FBRy9DLCtCQUErQix5Q0FBTztBQUN0Qzs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUksa0VBQXFCOztBQUV6QjtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0Msb0NBQW9DLHlDQUFPO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQSxVQUFVLHFFQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxvREFBb0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7QUFFMUM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMscURBQXFELFlBQVk7QUFDakU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NvbnRyaWJ1dGUuanM/ZTg0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGb3JtYXQgb2YgdGhlIG91dHB1dFxuLy8gICAgICBIYXNoIG9mIHRoZSBsYXN0IGNvbnRyaWJ1dGlvbiAgNjQgQnl0ZXNcbi8vICAgICAgMl5OKjItMSBUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAgMl5OIFRhdUcyIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQWxwaGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEJldGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcblxuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGtleVBhaXIgZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udHJpYnV0ZShvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAocG93ZXIgIT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJUaGlzIGZpbGUgaGFzIGJlZW4gcmVkdWNlZC4gWW91IGNhbm5vdCBjb250cmlidXRlIGludG8gYSByZWR1Y2VkIGZpbGUuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGZpbGUgaGFzIGJlZW4gcmVkdWNlZC4gWW91IGNhbm5vdCBjb250cmlidXRlIGludG8gYSByZWR1Y2VkIGZpbGUuXCIpO1xuICAgIH1cbiAgICBpZiAoc2VjdGlvbnNbMTJdKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFwiV0FSTklORzogQ29udHJpYnV0aW5nIGludG8gYSBmaWxlIHRoYXQgaGFzIHBoYXNlMiBjYWxjdWxhdGVkLiBZb3Ugd2lsbCBoYXZlIHRvIHByZXBhcmUgcGhhc2UyIGFnYWluLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogMCwgLy8gQmVhY29uXG4gICAgfTtcblxuICAgIGxldCBsYXN0Q2hhbGxlbmdlSGFzaDtcblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2MuZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoPjApIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSB1dGlscy5jYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGtleVxuXG5cbiAgICBjdXJDb250cmlidXRpb24ua2V5ID0ga2V5UGFpci5jcmVhdGVQVGF1S2V5KGN1cnZlLCBsYXN0Q2hhbGxlbmdlSGFzaCwgcm5nKTtcblxuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBuZXcgQmxha2UyYig2NCk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGxhc3RDaGFsbGVuZ2VIYXNoKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgNyk7XG4gICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuXG4gICAgbGV0IGZpcnN0UG9pbnRzO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICogMiAtMSwgY3VydmUuRnIuZSgxKSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcInRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcyID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig0LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmFscGhhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImFscGhhVGF1RzFcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5hbHBoYUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcyID0gZmlyc3RQb2ludHNbMF07XG5cbiAgICBjdXJDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSByZXNwb25zZUhhc2hlci5nZXRQYXJ0aWFsSGFzaCgpO1xuXG4gICAgY29uc3QgYnVmZktleSA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgdXRpbHMudG9QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBjdXJDb250cmlidXRpb24ua2V5LCBmYWxzZSk7XG5cbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZktleSkpO1xuICAgIGNvbnN0IGhhc2hSZXNwb25zZSA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGhhc2hSZXNwb25zZSwgXCJDb250cmlidXRpb24gUmVzcG9uc2UgSGFzaCBpbXBvcnRlZDogXCIpKTtcblxuICAgIGNvbnN0IG5leHRDaGFsbGVuZ2VIYXNoZXIgPSBuZXcgQmxha2UyYig2NCk7XG4gICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIik7XG5cbiAgICBjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgdXRpbHMud3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmZE9sZC5wb3MgPSBzZWN0aW9uc1tzZWN0aW9uSWRdWzBdLnA7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBzZWN0aW9uSWQpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkTmV3LnBvcztcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgICAgICBsZXQgdCA9IGZpcnN0O1xuICAgICAgICBmb3IgKGxldCBpPTAgOyBpPE5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHByb2Nlc3Npbmc6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7TlBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKE5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgICAgICBjb25zdCBidWZmSW4gPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0TEVNID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmZJbiwgdCwgaW5jKTtcblxuICAgICAgICAgICAgLyogQ29kZSB0byB0ZXN0IHRoZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmUgdGhlIDJebS0yIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKHNlY3Rpb25OYW1lPT0gXCJ0YXVHMVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnogPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgICAgICAgICAgYnVmZk91dExFTS5zZXQoYnosIDY0KigoMiAqKiBwb3dlcikgLSAxICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVdyaXRlID0gZmROZXcud3JpdGUoYnVmZk91dExFTSk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0QyA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmT3V0Qyk7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlV3JpdGU7XG4gICAgICAgICAgICBpZiAoaT09MCkgICAvLyBSZXR1cm4gdGhlIDIgZmlyc3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxNYXRoLm1pbigyLCBOUG9pbnRzKTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZk91dExFTSwgaipzRykpO1xuICAgICAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24oZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmaSkgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiBgICsgaSk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxuXG5cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_contribute.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_convert.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_convert.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ convert)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udmVydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0o7QUFDWDtBQUNFOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDO0FBQ0E7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQTJCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDLDZFQUE2RSxZQUFZLElBQUksRUFBRSxHQUFHLE9BQU87QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NvbnZlcnQuanM/ZjI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnQob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIC8vIGNvbnN0IGZkVG1wID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIDEyLCBcIkcxXCIsIFwidGF1RzFcIiApO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE0KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTUpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgLy8gYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgcmV0dXJuO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24ob2xkU2VjdGlvbklkLCBuZXdTZWN0aW9uSWQsIEdzdHIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIHNlY3Rpb246IFwiK3NlY3Rpb25OYW1lKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIG5ld1NlY3Rpb25JZCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNlY3Rpb25zW25ld1NlY3Rpb25JZF1bMF0uc2l6ZTtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gZmRPbGQucGFnZVNpemU7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgbmV3U2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPHNpemU7IHArPWNodW5rU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgbCA9IE1hdGgubWluKHNpemUgLXAsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRPbGQucmVhZChsKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCk7XG5cbiAgICAgICAgaWYgKG9sZFNlY3Rpb25JZCA9PSAyKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHBvd2VyKzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25Qb3dlcihwKSB7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgY29uc3QgRyA9IGN1cnZlW0dzdHJdO1xuICAgICAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuXG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dpbik7XG5cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgb2xkU2VjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICgob2xkU2VjdGlvbklkID09IDIpJiYocD09cG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICAgICAgYnVmZi5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCxuUG9pbnRzKnNHaW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmxhZ3JhbmdlRXZhbHVhdGlvbnMoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcblxuLypcbiAgICAgICAgICAgIGlmIChwIDw9IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgICAgICBidWZmID0gYXdhaXQgRy5pZmZ0KGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09IGN1cnZlLkZyLnMrMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNtYWxsTSA9IDE8PGN1cnZlLkZyLnM7XG4gICAgICAgICAgICAgICAgbGV0IHQwID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxNKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmVfb3Zlcl9kZW5vbSA9IEZyLmludihGci5zdWIoc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc0ludkFjYyA9IEZyLm9uZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8c21hbGxNOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGklMTAwMDApIGxvZ2dlci5kZWJ1Zyhgc2VjdGlvbk5hbWUgcHJlcGFyZSBMIGNhbGM6ICR7c2VjdGlvbk5hbWV9LCAke2l9LyR7c21hbGxNfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aSA9ICBidWZmLnNsaWNlKGkqc0dpbiwgKGkrMSkqc0dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtaSA9IGJ1ZmYuc2xpY2UoKGkrc21hbGxNKSpzR2luLCAoaStzbWFsbE0rMSkqc0dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdDAuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIodGkgLCBzaGlmdF90b19zbWFsbF9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVfb3Zlcl9kZW5vbVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdDEuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKCB0bWksIHRpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGci5tdWwoc0ludkFjYywgb25lX292ZXJfZGVub20pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgc0ludkFjYyA9IEZyLm11bChzSW52QWNjLCBGci5zaGlmdEludik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQwID0gYXdhaXQgRy5pZmZ0KHQwLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MCk7XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHQxID0gYXdhaXQgRy5pZmZ0KHQxLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MVwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXIgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlciB0byBiaWdcIik7XG4gICAgICAgICAgICB9XG4qL1xuICAgICAgICB9XG5cblxuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_convert.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_challenge.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_export_challenge.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportChallenge)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\n\n\n\n\n\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n    const {fd: fdFrom, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readPTauHeader(fdFrom, sections);\n\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64).digest();\n        curChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(challengeFilename);\n\n    const toHash = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endReadSection(fdFrom);\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDRjtBQUNhO0FBQ0k7QUFDbEI7O0FBRW5CO0FBQ2YsVUFBVSwrQ0FBYTtBQUN2QixXQUFXLHNCQUFzQixRQUFRLDREQUF3Qjs7QUFFakUsV0FBVyxjQUFjLFFBQVEsaUVBQW9COztBQUVyRCxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU87QUFDbEMsMkJBQTJCLDhFQUFpQztBQUM1RCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0MsNEJBQTRCLGdEQUFlOzs7QUFHM0MsdUJBQXVCLG9EQUF1Qjs7QUFFOUMsbUJBQW1CLHlDQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCLGdDQUFnQyxnREFBZTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUVBQW1DO0FBQ2pELHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6Qzs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9leHBvcnRfY2hhbGxlbmdlLmpzPzBjYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IG9mIHRoZSBvdXRwdVxuLy8gICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NEJ5dGVzXG4vLyAgICAgMl5OICogMiAtMSAgVGF1RzEgcG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgMl5OICBUYXVHMiBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAyXk4gIEFscGhhVGF1RzEgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgMl5OICBCZXRhVGF1RzEgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgQmV0YUcyICh1bmNvbXByZXNzZWQpXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydENoYWxsZW5nZShwVGF1RmlsZW5hbWUsIGNoYWxsZW5nZUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG4gICAgY29uc3Qge2ZkOiBmZEZyb20sIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRGcm9tLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRGcm9tLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGxldCBsYXN0UmVzcG9uc2VIYXNoLCBjdXJDaGFsbGVuZ2VIYXNoO1xuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxhc3RSZXNwb25zZUhhc2ggPSBCbGFrZTJiKDY0KS5kaWdlc3QoKTtcbiAgICAgICAgY3VyQ2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSZXNwb25zZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLnJlc3BvbnNlSGFzaDtcbiAgICAgICAgY3VyQ2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gobGFzdFJlc3BvbnNlSGFzaCwgXCJMYXN0IFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VyQ2hhbGxlbmdlSGFzaCwgXCJOZXcgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cblxuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShjaGFsbGVuZ2VGaWxlbmFtZSk7XG5cbiAgICBjb25zdCB0b0hhc2ggPSBCbGFrZTJiKDY0KTtcbiAgICBhd2FpdCBmZFRvLndyaXRlKGxhc3RSZXNwb25zZUhhc2gpO1xuICAgIHRvSGFzaC51cGRhdGUobGFzdFJlc3BvbnNlSGFzaCk7XG5cbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDIsIFwiRzFcIiwgKDIgKiogcG93ZXIpICogMiAtMSwgXCJ0YXVHMVwiKTtcbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDMsIFwiRzJcIiwgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiKTtcbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDQsIFwiRzFcIiwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNSwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcImJldGFUYXVHMVwiKTtcbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDYsIFwiRzJcIiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIik7XG5cbiAgICBhd2FpdCBmZEZyb20uY2xvc2UoKTtcbiAgICBhd2FpdCBmZFRvLmNsb3NlKCk7XG5cbiAgICBjb25zdCBjYWxjQ3VyQ2hhbGxlbmdlSGFzaCA9IHRvSGFzaC5kaWdlc3QoKTtcblxuICAgIGlmICghbWlzYy5oYXNoSXNFcXVhbCAoY3VyQ2hhbGxlbmdlSGFzaCwgY2FsY0N1ckNoYWxsZW5nZUhhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjYWxjQ3VyQ2hhbGxlbmdlSGFzaCwgXCJDYWxjIEN1cnJldCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQVGF1IGZpbGUgaXMgY29ycnVwdGVkLiBDYWxjdWxhdGVkIG5ldyBjaGFsbGVuZ2UgaGFzaCBkb2VzIG5vdCBtYXRjaCB3aXRoIHRoZSBlY2xhcmVkIG9uZVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUFRhdSBmaWxlIGlzIGNvcnJ1cHRlZC4gQ2FsY3VsYXRlZCBuZXcgY2hhbGxlbmdlIGhhc2ggZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgZWNsYXJlZCBvbmVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1ckNoYWxsZW5nZUhhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRTZWN0aW9uKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZEZyb20sIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkrPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgRXhwb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmYpO1xuICAgICAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICAgICAgICAgIHRvSGFzaC51cGRhdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkRnJvbSk7XG4gICAgfVxuXG5cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_challenge.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_json.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_export_json.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportJson)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.stringifyBigIntsWithField)(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ0k7QUFDRTs7QUFFdkM7QUFDZixXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9FQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLG1FQUF5Qjs7OztBQUlwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsWUFBWTtBQUNsQyw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsVUFBVTtBQUNoQyx3Q0FBd0MsWUFBWSxXQUFXLEVBQUU7QUFDakU7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLGlFQUFpRSxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6QztBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2V4cG9ydF9qc29uLmpzP2FjYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHsgc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZCB9IGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0SnNvbihwVGF1RmlsZW5hbWUsIHZlcmJvc2UpIHtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IHBUYXUgPSB7fTtcbiAgICBwVGF1LnEgPSBjdXJ2ZS5xO1xuICAgIHBUYXUucG93ZXIgPSBwb3dlcjtcbiAgICBwVGF1LmNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIHBUYXUudGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDIsIFwiRzFcIiwgKDIgKiogcG93ZXIpKjIgLTEsIFwidGF1RzFcIik7XG4gICAgcFRhdS50YXVHMiA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oMywgXCJHMlwiLCAoMiAqKiBwb3dlciksIFwidGF1RzJcIik7XG4gICAgcFRhdS5hbHBoYVRhdUcxID0gYXdhaXQgZXhwb3J0U2VjdGlvbig0LCBcIkcxXCIsICgyICoqIHBvd2VyKSwgXCJhbHBoYVRhdUcxXCIpO1xuICAgIHBUYXUuYmV0YVRhdUcxID0gYXdhaXQgZXhwb3J0U2VjdGlvbig1LCBcIkcxXCIsICgyICoqIHBvd2VyKSwgXCJiZXRhVGF1RzFcIik7XG4gICAgcFRhdS5iZXRhRzIgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDYsIFwiRzJcIiwgMSwgXCJiZXRhRzJcIik7XG5cbiAgICBwVGF1LmxUYXVHMSA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDEyLCBcIkcxXCIsIFwibFRhdUcxXCIpO1xuICAgIHBUYXUubFRhdUcyID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTMsIFwiRzJcIiwgXCJsVGF1RzJcIik7XG4gICAgcFRhdS5sQWxwaGFUYXVHMSA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDE0LCBcIkcxXCIsIFwibEFscGhhVGF1RzJcIik7XG4gICAgcFRhdS5sQmV0YVRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTUsIFwiRzFcIiwgXCJsQmV0YVRhdUcyXCIpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKGN1cnZlLkZyLCBwVGF1KTtcblxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRTZWN0aW9uKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCh2ZXJib3NlKSYmaSYmKGklMTAwMDAgPT0gMCkpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogYCArIGkpO1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmYsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TGFncmFuZ2Uoc2VjdGlvbklkLCBncm91cE5hbWUsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IHA9MDsgcDw9cG93ZXI7IHArKykge1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogUG93ZXI6ICR7cH1gKTtcbiAgICAgICAgICAgIHJlc1twXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9ICgyICoqIHApO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgodmVyYm9zZSkmJmkmJihpJTEwMDAwID09IDApKSBjb25zb2xlLmxvZyhgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKTtcbiAgICAgICAgICAgICAgICByZXNbcF0ucHVzaChHLmZyb21ScHJMRU0oYnVmZiwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_export_json.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_import.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_import.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ importResponse)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readPTauHeader(fdOld, sections);\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compresed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compresed size\n\n    const fdResponse = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. this contribution is not based on the previus hash\");\n\n    const hasherResponse = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = hasherResponse.getPartialHash();\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfaW1wb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0Y7QUFDYTtBQUNJO0FBQ2xCOztBQUVuQjs7QUFFZixVQUFVLCtDQUFhOztBQUV2QjtBQUNBLGtCQUFrQixNQUFNOztBQUV4QixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7QUFDckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4Qjs7QUFFOUIsNkJBQTZCLGtEQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCLDhFQUFpQztBQUM3RDs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQSxRQUFRLGlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpREFBZ0I7QUFDeEI7O0FBRUEsK0JBQStCLHlDQUFPO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsOEJBQThCLG9FQUF1Qjs7QUFFckQ7QUFDQTs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0Esd0NBQXdDLHlDQUFPO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLGdEQUFlO0FBQy9DLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBLFVBQVUscUVBQXdCOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxrRUFBOEI7QUFDNUM7O0FBRUE7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMsa0RBQWtELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUMvRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7QUFFMUM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxnREFBZ0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQzdFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2ltcG9ydC5qcz83YmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydFJlc3BvbnNlKG9sZFB0YXVGaWxlbmFtZSwgY29udHJpYnV0aW9uRmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgaW1wb3J0UG9pbnRzLCBsb2dnZXIpIHtcblxuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcblxuICAgIGNvbnN0IG5vSGFzaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8NjQ7IGkrKykgbm9IYXNoW2ldID0gMHhGRjtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1cnJlbnRDb250cmlidXRpb24gPSB7fTtcblxuICAgIGlmIChuYW1lKSBjdXJyZW50Q29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRjEubjgqMjtcbiAgICBjb25zdCBzY0cxID0gY3VydmUuRjEubjg7IC8vIENvbXByZXNlZCBzaXplXG4gICAgY29uc3Qgc0cyID0gY3VydmUuRjIubjgqMjtcbiAgICBjb25zdCBzY0cyID0gY3VydmUuRjIubjg7IC8vIENvbXByZXNlZCBzaXplXG5cbiAgICBjb25zdCBmZFJlc3BvbnNlID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKGNvbnRyaWJ1dGlvbkZpbGVuYW1lKTtcblxuICAgIGlmICAoZmRSZXNwb25zZS50b3RhbFNpemUgIT1cbiAgICAgICAgNjQgKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbGQgSGFzaFxuICAgICAgICAoKDIgKiogcG93ZXIpKjItMSkqc2NHMSArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cyICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzEgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMSArXG4gICAgICAgIHNjRzIgK1xuICAgICAgICBzRzEqNiArIHNHMiozKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG9mIHRoZSBjb250cmlidXRpb24gaXMgaW52YWxpZFwiKTtcblxuICAgIGxldCBsYXN0Q2hhbGxlbmdlSGFzaDtcblxuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIGltcG9ydFBvaW50cyA/IDc6IDIpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCA9IGF3YWl0IGZkUmVzcG9uc2UucmVhZCg2NCk7XG5cbiAgICBpZiAobWlzYy5oYXNoSXNFcXVhbChub0hhc2gsbGFzdENoYWxsZW5nZUhhc2gpKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uUHJldmlvdXNIYXNoO1xuICAgICAgICBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2UgPSBsYXN0Q2hhbGxlbmdlSGFzaDtcbiAgICB9XG5cbiAgICBpZighbWlzYy5oYXNoSXNFcXVhbChjb250cmlidXRpb25QcmV2aW91c0hhc2gsbGFzdENoYWxsZW5nZUhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBjb250cmlidXRpb24uIHRoaXMgY29udHJpYnV0aW9uIGlzIG5vdCBiYXNlZCBvbiB0aGUgcHJldml1cyBoYXNoXCIpO1xuXG4gICAgY29uc3QgaGFzaGVyUmVzcG9uc2UgPSBuZXcgQmxha2UyYig2NCk7XG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCk7XG5cbiAgICBjb25zdCBzdGFydFNlY3Rpb25zID0gW107XG4gICAgbGV0IHJlcztcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBbMV0sIFwidGF1RzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi50YXVHMSA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMlwiLCAzLCAoMiAqKiBwb3dlcikgICAgICAgLCBbMV0sIFwidGF1RzJcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi50YXVHMiA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBbMF0sIFwiYWxwaGFHMVwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmFscGhhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImJldGFHMVwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMSA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMlwiLCA2LCAxICAgICAgICAgICAgICAgICAgLCBbMF0sIFwiYmV0YUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24uYmV0YUcyID0gcmVzWzBdO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IGhhc2hlclJlc3BvbnNlLmdldFBhcnRpYWxIYXNoKCk7XG5cblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBhd2FpdCBmZFJlc3BvbnNlLnJlYWQoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG5cbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmtleSA9IHV0aWxzLmZyb21QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBmYWxzZSk7XG5cbiAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZktleSkpO1xuICAgIGNvbnN0IGhhc2hSZXNwb25zZSA9IGhhc2hlclJlc3BvbnNlLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGhhc2hSZXNwb25zZSwgXCJDb250cmlidXRpb24gUmVzcG9uc2UgSGFzaCBpbXBvcnRlZDogXCIpKTtcblxuICAgIGlmIChpbXBvcnRQb2ludHMpIHtcbiAgICAgICAgY29uc3QgbmV4dENoYWxsZW5nZUhhc2hlciA9IG5ldyBCbGFrZTJiKDY0KTtcbiAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIiwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIsIGxvZ2dlcik7XG5cbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlLCBcIk5leHQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbm9IYXNoO1xuICAgIH1cblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJyZW50Q29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHV0aWxzLndyaXRlQ29udHJpYnV0aW9ucyhmZE5ldywgY3VydmUsIGNvbnRyaWJ1dGlvbnMpO1xuXG4gICAgYXdhaXQgZmRSZXNwb25zZS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiBjdXJyZW50Q29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGltcG9ydFBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NTZWN0aW9uSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc1NlY3Rpb25Ob0ltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFRvLCBzZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkVG8ucG9zO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgRy5iYXRjaEN0b0xFTShidWZmQyk7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZkxFTSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZkxFTSwgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkVG8pO1xuXG4gICAgICAgIHJldHVybiBzaW5ndWxhclBvaW50cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zY0cpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJDb21wcmVzc2VkKGJ1ZmZDLCAoc3AtaSkqc2NHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luZ3VsYXJQb2ludHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_import.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_new.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_new.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newAccumulator)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\n\n\n\n\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__.ready();\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__(64).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfbmV3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFdBQVc7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDQTtBQUNqQjtBQUNEOztBQUVuQjs7QUFFZixVQUFVLCtDQUFhOztBQUV2QixxQkFBcUIsOERBQTBCOztBQUUvQyxVQUFVLGtFQUF5Qjs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4Qyw0QkFBNEI7QUFDNUIsVUFBVSxnRUFBNEI7O0FBRXRDOztBQUVBLCtCQUErQiw4RUFBcUM7O0FBRXBFLDZCQUE2QixnREFBZSxDQUFDLHlDQUFPOztBQUVwRCw0QkFBNEIsZ0RBQWU7O0FBRTNDOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfbmV3LmpzPzE2OTciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLypcbkhlYWRlcigxKVxuICAgIG44XG4gICAgcHJpbWVcbiAgICBwb3dlclxudGF1RzEoMilcbiAgICB7KDIgKiogcG93ZXIpKjItMX0gW1xuICAgICAgICBHMSwgdGF1KkcxLCB0YXVeMiAqIEcxLCAuLi4uXG4gICAgXVxudGF1RzIoMylcbiAgICB7MiAqKiBwb3dlcn1bXG4gICAgICAgIEcyLCB0YXUqRzIsIHRhdV4yICogRzIsIC4uLlxuICAgIF1cbmFscGhhVGF1RzEoNClcbiAgICB7MiAqKiBwb3dlcn1bXG4gICAgICAgIGFscGhhKkcxLCBhbHBoYSp0YXUqRzEsIGFscGhhKnRhdV4yKkcxLC4uLi5cbiAgICBdXG5iZXRhVGF1RzEoNSlcbiAgICB7MiAqKiBwb3dlcn0gW11cbiAgICAgICAgYmV0YSpHMSwgYmV0YSp0YXUqRzEsIGJldGEqdGF1XjIqRzEsIC4uLi5cbiAgICBdXG5iZXRhRzIoNilcbiAgICB7MX1bXG4gICAgICAgIGJldGEqRzJcbiAgICBdXG5jb250cmlidXRpb25zKDcpXG4gICAgTkNvbnRyaWJ1dGlvbnNcbiAgICB7TkNvbnRyaWJ1dGlvbnN9W1xuICAgICAgICB0YXUqRzFcbiAgICAgICAgdGF1KkcyXG4gICAgICAgIGFscGhhKkcxXG4gICAgICAgIGJldGEqRzFcbiAgICAgICAgYmV0YSpHMlxuICAgICAgICBwdWJLZXlcbiAgICAgICAgICAgIHRhdV9nMXNcbiAgICAgICAgICAgIHRhdV9nMXN4XG4gICAgICAgICAgICB0YXVfZzJzcHhcbiAgICAgICAgICAgIGFscGhhX2cxc1xuICAgICAgICAgICAgYWxwaGFfZzFzeFxuICAgICAgICAgICAgYWxwaGFfZzFzcHhcbiAgICAgICAgICAgIGJldGFfZzFzXG4gICAgICAgICAgICBiZXRhX2cxc3hcbiAgICAgICAgICAgIGJldGFfZzFzcHhcbiAgICAgICAgcGFydGlhbEhhc2ggKDIxNiBieXRlcykgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvYmxha2UyYi13YXNtL2Jsb2IvMjNiZWUwNjk0NTgwNjMwOTk3N2FmODAyYmMzNzQ3Mjc1NDI2MTdjNy9ibGFrZTJiLndhdCNMOVxuICAgICAgICBoYXNoTmV3Q2hhbGxlbmdlXG4gICAgXVxuICovXG5cbmltcG9ydCAqIGFzIHB0YXVVdGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbmV3QWNjdW11bGF0b3IoY3VydmUsIHBvd2VyLCBmaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKGZpbGVOYW1lLCBcInB0YXVcIiwgMSwgNyk7XG5cbiAgICBhd2FpdCBwdGF1VXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIDApO1xuXG4gICAgY29uc3QgYnVmZkcxID0gY3VydmUuRzEub25lQWZmaW5lO1xuICAgIGNvbnN0IGJ1ZmZHMiA9IGN1cnZlLkcyLm9uZUFmZmluZTtcblxuICAgIC8vIFdyaXRlIHRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGNvbnN0IG5UYXVHMSA9ICgyICoqIHBvd2VyKSAqIDIgLTE7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwidGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgdGF1RzJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMyk7XG4gICAgY29uc3QgblRhdUcyID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgblRhdUcyOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcInRhdUcyOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGFscGhhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNCk7XG4gICAgY29uc3QgbkFsZmFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5BbGZhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYWxwaGFUYXVHMTogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNSk7XG4gICAgY29uc3QgbkJldGFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5CZXRhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYmV0YVRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGJldGFHMlxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA2KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gQ29udHJpYnV0aW9uc1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA3KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDApOyAvLyAwIENvbnRyaWJ1dGlvbnNcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBjb25zdCBmaXJzdENoYWxsZW5nZUhhc2ggPSBwdGF1VXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhtaXNjLmZvcm1hdEhhc2goQmxha2UyYig2NCkuZGlnZXN0KCksIFwiQmxhbmsgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChmaXJzdENoYWxsZW5nZUhhc2gsIFwiRmlyc3QgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIHJldHVybiBmaXJzdENoYWxsZW5nZUhhc2g7XG5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_new.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_preparephase2.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_preparephase2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ preparePhase2)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfcHJlcGFyZXBoYXNlMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjtBQUNUOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9CLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7O0FBRzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3ByZXBhcmVwaGFzZTIuanM/MWZjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlUGhhc2UyKG9sZFB0YXVGaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDExKTtcbiAgICBhd2FpdCB1dGlscy53cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIDEyLCBcIkcxXCIsIFwidGF1RzFcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIDEzLCBcIkcyXCIsIFwidGF1RzJcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIDE0LCBcIkcxXCIsIFwiYWxwaGFUYXVHMVwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgMTUsIFwiRzFcIiwgXCJiZXRhVGF1RzFcIiApO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgLy8gYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgcmV0dXJuO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24ob2xkU2VjdGlvbklkLCBuZXdTZWN0aW9uSWQsIEdzdHIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIHNlY3Rpb246IFwiK3NlY3Rpb25OYW1lKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIG5ld1NlY3Rpb25JZCk7XG5cbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD1wb3dlcjsgcCsrKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFNlY3Rpb25JZCA9PSAyKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHBvd2VyKzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvblBvd2VyKHApIHtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAyICoqIHA7XG4gICAgICAgICAgICBjb25zdCBHID0gY3VydmVbR3N0cl07XG4gICAgICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgY29uc3Qgc0dtaWQgPSBHLkYubjgqMztcblxuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICBidWZmID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHaW4pO1xuXG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG9sZFNlY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoKG9sZFNlY3Rpb25JZCA9PSAyKSYmKHA9PXBvd2VyKzEpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgICAgIGJ1ZmYuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsblBvaW50cypzR2luICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRPbGQsIHRydWUpO1xuXG5cbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmxhZ3JhbmdlRXZhbHVhdGlvbnMoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcblxuLypcbiAgICAgICAgICAgIGlmIChwIDw9IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgICAgICBidWZmID0gYXdhaXQgRy5pZmZ0KGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09IGN1cnZlLkZyLnMrMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNtYWxsTSA9IDE8PGN1cnZlLkZyLnM7XG4gICAgICAgICAgICAgICAgbGV0IHQwID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxNKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmVfb3Zlcl9kZW5vbSA9IEZyLmludihGci5zdWIoc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc0ludkFjYyA9IEZyLm9uZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8c21hbGxNOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGkgPSAgYnVmZi5zbGljZShpKnNHaW4sIChpKzEpKnNHaW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bWkgPSBidWZmLnNsaWNlKChpK3NtYWxsTSkqc0dpbiwgKGkrc21hbGxNKzEpKnNHaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIHQwLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnN1YihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKHRpICwgc2hpZnRfdG9fc21hbGxfbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lX292ZXJfZGVub21cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHQxLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnN1YiggdG1pLCB0aSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRnIubXVsKHNJbnZBY2MsIG9uZV9vdmVyX2Rlbm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHNJbnZBY2MgPSBGci5tdWwoc0ludkFjYywgRnIuc2hpZnRJbnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0MCA9IGF3YWl0IEcuaWZmdCh0MCwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lICsgXCIgdDBcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUodDApO1xuICAgICAgICAgICAgICAgIHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0MSA9IGF3YWl0IEcuaWZmdCh0MSwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lICsgXCIgdDBcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUodDEpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBvd2VyIHRvbyBiaWdcIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXIgdG8gYmlnXCIpO1xuICAgICAgICAgICAgfVxuKi9cbiAgICAgICAgfVxuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_preparephase2.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_truncate.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_truncate.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ truncate)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7); // contributions\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjs7QUFFakM7O0FBRWYsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7O0FBRXBFO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qiw4REFBMEI7QUFDdEQsY0FBYyxrRUFBcUI7O0FBRW5DLGNBQWMsNERBQXdCLG9EQUFvRDtBQUMxRixjQUFjLDREQUF3Qiw2Q0FBNkM7QUFDbkYsY0FBYyw0REFBd0IsNkNBQTZDO0FBQ25GLGNBQWMsNERBQXdCLDZDQUE2QztBQUNuRixjQUFjLDREQUF3QixtQ0FBbUM7QUFDekUsY0FBYyw0REFBd0IsNkJBQTZCO0FBQ25FLGNBQWMsNERBQXdCLHlEQUF5RDtBQUMvRixjQUFjLDREQUF3QixxREFBcUQ7QUFDM0YsY0FBYyw0REFBd0IscURBQXFEO0FBQzNGLGNBQWMsNERBQXdCLHFEQUFxRDs7QUFFM0Y7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV90cnVuY2F0ZS5qcz85MzRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gdHJ1bmNhdGUocHRhdUZpbGVuYW1lLCB0ZW1wbGF0ZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGZvciAobGV0IHA9MTsgcDxwb3dlcjsgcCsrKSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ1bmNhdGUocCk7XG4gICAgfVxuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUcnVuY2F0ZShwKSB7XG5cbiAgICAgICAgbGV0IHNQID0gcC50b1N0cmluZygpO1xuICAgICAgICB3aGlsZSAoc1AubGVuZ3RoPDIpIHNQID0gXCIwXCIgKyBzUDtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJXcml0aW5nIFBvd2VyOiBcIitzUCk7XG5cbiAgICAgICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh0ZW1wbGF0ZSArIHNQICsgXCIucHRhdVwiLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgICAgICBhd2FpdCB1dGlscy53cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwLCBjZXJlbW9ueVBvd2VyKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMiwgKCgyICoqIHApKjItMSkgKiBzRzEgKTsgLy8gdGFnRzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMsICgyICoqIHApICogc0cyKTsgLy8gdGF1RzJcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQsICgyICoqIHApICogc0cxKTsgLy8gYWxmYVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1LCAoMiAqKiBwKSAqIHNHMSk7IC8vIGJldGFUYXVHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNiwgIHNHMik7IC8vIGJldGFUYXVHMlxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7IC8vIGNvbnRyaWJ1dGlvbnNcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEyLCAoKDIgKiogKHArMSkpKjIgLTEpICogc0cxKTsgLy8gTF90YXVHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTMsICgoMiAqKiBwKSoyIC0xKSAqIHNHMik7IC8vIExfdGF1RzJcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE0LCAoKDIgKiogcCkqMiAtMSkgKiBzRzEpOyAvLyBMX2FsZmFUYXVHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTUsICgoMiAqKiBwKSoyIC0xKSAqIHNHMSk7IC8vIExfYmV0YVRhdUcxXG5cbiAgICAgICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcbiAgICB9XG5cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_truncate.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFirstChallengeHash: () => (/* binding */ calculateFirstChallengeHash),\n/* harmony export */   fromPtauPubKeyRpr: () => (/* binding */ fromPtauPubKeyRpr),\n/* harmony export */   keyFromBeacon: () => (/* binding */ keyFromBeacon),\n/* harmony export */   readContributions: () => (/* binding */ readContributions),\n/* harmony export */   readPTauHeader: () => (/* binding */ readPTauHeader),\n/* harmony export */   readPtauPubKey: () => (/* binding */ readPtauPubKey),\n/* harmony export */   toPtauPubKeyRpr: () => (/* binding */ toPtauPubKeyRpr),\n/* harmony export */   writeContributions: () => (/* binding */ writeContributions),\n/* harmony export */   writePTauHeader: () => (/* binding */ writePTauHeader),\n/* harmony export */   writePtauPubKey: () => (/* binding */ writePtauPubKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromQ)(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    responseHasher.setPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parametes do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nfunction keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_2__.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDSDtBQUNLO0FBQ047QUFDVTs7QUFFckM7QUFDUDtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBLG1EQUFtRDtBQUNuRCxzREFBc0Q7O0FBRXREOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQU07O0FBRXBCLHdCQUF3Qix5REFBYTs7QUFFckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdPOztBQUVQOztBQUVBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQix5Q0FBTztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTzs7QUFFUCw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsdUJBQXVCLHlDQUFPOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IseUNBQU87O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdPOztBQUVQLGdCQUFnQix5REFBd0I7O0FBRXhDLGdCQUFnQixzREFBcUI7O0FBRXJDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV91dGlscy5qcz8xYTFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIGtleVBhaXIgZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVBUYXVIZWFkZXIoZmQsIGN1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcikge1xuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgaWYgKCEgY2VyZW1vbnlQb3dlcikgY2VyZW1vbnlQb3dlciA9IHBvd2VyO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMSk7IC8vIEhlYWRlciB0eXBlXG4gICAgY29uc3QgcEhlYWRlclNpemUgPSBmZC5wb3M7XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY3VydmUuRjEubjY0KjgpO1xuXG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KTtcbiAgICBTY2FsYXIudG9ScHJMRShidWZmLCAwLCBjdXJ2ZS5xLCBjdXJ2ZS5GMS5uOCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihwb3dlcik7ICAgICAgICAgICAgICAgICAgICAvLyBwb3dlclxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY2VyZW1vbnlQb3dlcik7ICAgICAgICAgICAgICAgLy8gcG93ZXJcblxuICAgIGNvbnN0IGhlYWRlclNpemUgPSBmZC5wb3MgLSBwSGVhZGVyU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGhlYWRlclNpemUsIHBIZWFkZXJTaXplKTtcblxuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRQVGF1SGVhZGVyKGZkLCBzZWN0aW9ucykge1xuICAgIGlmICghc2VjdGlvbnNbMV0pICB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgKyBcIjogRmlsZSBoYXMgbm8gIGhlYWRlclwiKTtcbiAgICBpZiAoc2VjdGlvbnNbMV0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgaGVhZGVyXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbMV1bMF0ucDtcbiAgICBjb25zdCBuOCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKG44KTtcbiAgICBjb25zdCBxID0gU2NhbGFyLmZyb21ScHJMRShidWZmKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUShxKTtcblxuICAgIGlmIChjdXJ2ZS5GMS5uNjQqOCAhPSBuOCkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogSW52YWxpZCBzaXplXCIpO1xuXG4gICAgY29uc3QgcG93ZXIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjZXJlbW9ueVBvd2VyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBpZiAoZmQucG9zLXNlY3Rpb25zWzFdWzBdLnAgIT0gc2VjdGlvbnNbMV1bMF0uc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQVGF1IGhlYWRlciBzaXplXCIpO1xuXG4gICAgcmV0dXJuIHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9O1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUHRhdVB1YktleShmZCwgY3VydmUsIG1vbnRnb21lcnkpIHtcblxuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkYxLm44KjIqNiArIGN1cnZlLkYyLm44KjIqMyk7XG5cbiAgICByZXR1cm4gZnJvbVB0YXVQdWJLZXlScHIoYnVmZiwgMCwgY3VydmUsIG1vbnRnb21lcnkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVB0YXVQdWJLZXlScHIoYnVmZiwgcG9zLCBjdXJ2ZSwgbW9udGdvbWVyeSkge1xuXG4gICAgY29uc3Qga2V5ID0ge1xuICAgICAgICB0YXU6IHt9LFxuICAgICAgICBhbHBoYToge30sXG4gICAgICAgIGJldGE6IHt9XG4gICAgfTtcblxuICAgIGtleS50YXUuZzFfcyA9IHJlYWRHMSgpO1xuICAgIGtleS50YXUuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfcyA9IHJlYWRHMSgpO1xuICAgIGtleS5hbHBoYS5nMV9zeCA9IHJlYWRHMSgpO1xuICAgIGtleS5iZXRhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zeCA9IHJlYWRHMSgpO1xuICAgIGtleS50YXUuZzJfc3B4ID0gcmVhZEcyKCk7XG4gICAga2V5LmFscGhhLmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5iZXRhLmcyX3NweCA9IHJlYWRHMigpO1xuXG4gICAgcmV0dXJuIGtleTtcblxuICAgIGZ1bmN0aW9uIHJlYWRHMSgpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzEuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIHAgPSBjdXJ2ZS5HMi5mcm9tUnByTEVNKCBidWZmLCBwb3MgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBjdXJ2ZS5HMi5mcm9tUnByVW5jb21wcmVzc2VkKCBidWZmLCBwb3MgKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY3VydmUuRzIuRi5uOCoyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1B0YXVQdWJLZXlScHIoYnVmZiwgcG9zLCBjdXJ2ZSwga2V5LCBtb250Z29tZXJ5KSB7XG5cbiAgICB3cml0ZUcxKGtleS50YXUuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkudGF1LmcxX3N4KTtcbiAgICB3cml0ZUcxKGtleS5hbHBoYS5nMV9zKTtcbiAgICB3cml0ZUcxKGtleS5hbHBoYS5nMV9zeCk7XG4gICAgd3JpdGVHMShrZXkuYmV0YS5nMV9zKTtcbiAgICB3cml0ZUcxKGtleS5iZXRhLmcxX3N4KTtcbiAgICB3cml0ZUcyKGtleS50YXUuZzJfc3B4KTtcbiAgICB3cml0ZUcyKGtleS5hbHBoYS5nMl9zcHgpO1xuICAgIHdyaXRlRzIoa2V5LmJldGEuZzJfc3B4KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgY3VydmUuRzEudG9ScHJMRU0oYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkYxLm44KjI7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihwKSB7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmLCBwb3MsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY3VydmUuRjIubjgqMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlUHRhdVB1YktleShmZCwgY3VydmUsIGtleSwgbW9udGdvbWVyeSkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYgKyBjdXJ2ZS5GMi5uOCoyKjMpO1xuICAgIHRvUHRhdVB1YktleVJwcihidWZmLCAwLCBjdXJ2ZSwga2V5LCBtb250Z29tZXJ5KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpIHtcbiAgICBjb25zdCBjID0ge307XG5cbiAgICBjLnRhdUcxID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgYy50YXVHMiA9IGF3YWl0IHJlYWRHMigpO1xuICAgIGMuYWxwaGFHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMuYmV0YUcxID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgYy5iZXRhRzIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjLmtleSA9IGF3YWl0IHJlYWRQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgdHJ1ZSk7XG4gICAgYy5wYXJ0aWFsSGFzaCA9IGF3YWl0IGZkLnJlYWQoMjE2KTtcbiAgICBjLm5leHRDaGFsbGVuZ2UgPSBhd2FpdCBmZC5yZWFkKDY0KTtcbiAgICBjLnR5cGUgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIGNvbnN0IGJ1ZmZWICA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMio2K2N1cnZlLkcyLkYubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjLmtleSwgZmFsc2UpO1xuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBCbGFrZTJiKDY0KTtcbiAgICByZXNwb25zZUhhc2hlci5zZXRQYXJ0aWFsSGFzaChjLnBhcnRpYWxIYXNoKTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZlYpO1xuICAgIGMucmVzcG9uc2VIYXNoID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBwYXJhbUxlbmd0aCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGN1clBvcyA9IGZkLnBvcztcbiAgICBsZXQgbGFzdFR5cGUgPTA7XG4gICAgd2hpbGUgKGZkLnBvcy1jdXJQb3MgPCBwYXJhbUxlbmd0aCkge1xuICAgICAgICBjb25zdCBidWZmVHlwZSA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPD0gbGFzdFR5cGUpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgaW4gdGhlIGNvbnRyaWJ1dGlvbiBtdXN0IGJlIHNvcnRlZFwiKTtcbiAgICAgICAgbGFzdFR5cGUgPSBidWZmVHlwZVswXTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPT0xKSB7ICAgICAvLyBOYW1lXG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IHJlYWREVihidWZmTGVuWzBdKTtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmU3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mikge1xuICAgICAgICAgICAgY29uc3QgYnVmZkV4cCA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGMubnVtSXRlcmF0aW9uc0V4cCA9IGJ1ZmZFeHBbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCByZWFkRFYoYnVmZkxlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZkLnBvcyAhPSBjdXJQb3MgKyBwYXJhbUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXMgZG8gbm90IG1hdGNoXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZERWKG4pIHtcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IGZkLnJlYWQobik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1s3XSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgY29udHJpYnV0aW9uc1wiKTtcbiAgICBpZiAoc2VjdGlvbnNbN11bMF0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgY29udHJpYnV0aW9ucyBzZWN0aW9uXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbN11bMF0ucDtcbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICBjLmlkID0gaSsxO1xuICAgICAgICBjb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1s3XVswXS5wICE9IHNlY3Rpb25zWzddWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udHJpYnV0aW9uIHNlY3Rpb24gc2l6ZVwiKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25zO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbikge1xuXG4gICAgY29uc3QgYnVmZkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMik7XG4gICAgY29uc3QgYnVmZkcyID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjIubjgqMik7XG4gICAgYXdhaXQgd3JpdGVHMShjb250cmlidXRpb24udGF1RzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLnRhdUcyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5hbHBoYUcxKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5iZXRhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLmJldGFHMik7XG4gICAgYXdhaXQgd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uLmtleSwgdHJ1ZSk7XG4gICAgYXdhaXQgZmQud3JpdGUoY29udHJpYnV0aW9uLnBhcnRpYWxIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ubmV4dENoYWxsZW5nZSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb24udHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjb250cmlidXRpb24ubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGNvbnRyaWJ1dGlvbi5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjb250cmlidXRpb24udHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjb250cmlidXRpb24uYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmRzEsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmRzIsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIH1cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9ucykge1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMig3KTsgLy8gSGVhZGVyIHR5cGVcbiAgICBjb25zdCBwQ29udHJpYnV0aW9uc1NpemUgPSBmZC5wb3M7XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcyAtIHBDb250cmlidXRpb25zU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGNvbnRyaWJ1dGlvbnNTaXplLCBwQ29udHJpYnV0aW9uc1NpemUpO1xuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0aW5nIEZpcnN0IENoYWxsZW5nZSBIYXNoXCIpO1xuXG4gICAgY29uc3QgaGFzaGVyID0gbmV3IEJsYWtlMmIoNjQpO1xuXG4gICAgY29uc3QgdkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjb25zdCB2RzIgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKHZHMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQodkcyLCAwLCBjdXJ2ZS5HMi5nKTtcblxuICAgIGhhc2hlci51cGRhdGUoQmxha2UyYig2NCkuZGlnZXN0KCkpO1xuXG4gICAgbGV0IG47XG5cbiAgICBuPSgyICoqIHBvd2VyKSoyIC0xO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IHRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIG49IDIgKiogcG93ZXI7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzJcIik7XG4gICAgaGFzaEJsb2NrKHZHMiwgbik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogYWxwaGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBiZXRhVGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgaGFzaGVyLnVwZGF0ZSh2RzIpO1xuXG4gICAgcmV0dXJuIGhhc2hlci5kaWdlc3QoKTtcblxuICAgIGZ1bmN0aW9uIGhhc2hCbG9jayhidWZmLCBuKSB7XG4gICAgICAgIC8vIHRoaXMgYmxvY2sgc2l6ZSBpcyBhIGdvb2QgY29tcHJvbWlzZSBiZXR3ZWVuIHNwZWVkIGFuZCB0aGUgbWF4aW11bVxuICAgICAgICAvLyBpbnB1dCBzaXplIG9mIHRoZSBCbGFrZTJiIHVwZGF0ZSBtZXRob2QgKDY1LDUzNSw3MjAgYnl0ZXMpLlxuICAgICAgICBjb25zdCBibG9ja1NpemUgPSAzNDEwMDA7XG4gICAgICAgIGNvbnN0IG5CbG9ja3MgPSBNYXRoLmZsb29yKG4gLyBibG9ja1NpemUpO1xuICAgICAgICBjb25zdCByZW0gPSBuICUgYmxvY2tTaXplO1xuICAgICAgICBjb25zdCBiaWdCdWZmID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBiaWdCdWZmLnNldChidWZmLCBpKmJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShiaWdCdWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkluaXRpYWwgaGFzaDogXCIgK2kqYmxvY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVtOyBpKyspIHtcbiAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGtleUZyb21CZWFjb24oY3VydmUsIGNoYWxsZW5nZUhhc2gsIGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApIHtcblxuICAgIGNvbnN0IHJuZyA9IG1pc2Mucm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IGtleSA9IGtleVBhaXIuY3JlYXRlUFRhdUtleShjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcblxuICAgIHJldHVybiBrZXk7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/powersoftau_verify.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/powersoftau_verify.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_6__.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fd, sections);\n    const contrs = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_6__.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_6__.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_6__.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n        responseHasher.setPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_6__.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_6__.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_6__.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = new Uint8Array(4*(n-1));\n            crypto__WEBPACK_IMPORTED_MODULE_3__.randomFillSync(scalars);\n\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = crypto__WEBPACK_IMPORTED_MODULE_3__.randomBytes(4).readUInt32BE(0, true);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = crypto__WEBPACK_IMPORTED_MODULE_3__.randomBytes(4).readUInt32BE(0, true);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_4__.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDYTtBQUNSO0FBQ1o7QUFDd0I7QUFDSDtBQUNmO0FBQ2xDLGtCQUFrQiwrQ0FBYzs7QUFFaEM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEIsZ0VBQW1COztBQUU3QztBQUNBLHNHQUFzRyxTQUFTLEVBQUUsZUFBZTtBQUNoSTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsU0FBUyxFQUFFLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFNBQVMsRUFBRSxlQUFlO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csU0FBUyxFQUFFLGVBQWU7QUFDbEk7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFNBQVMsRUFBRSxlQUFlO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxTQUFTLEVBQUUsZUFBZTtBQUNwSTtBQUNBOztBQUVBO0FBQ0EsdUdBQXVHLFNBQVMsRUFBRSxlQUFlO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxTQUFTLEVBQUUsZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsU0FBUyxFQUFFLGVBQWU7QUFDbkk7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnREFBZTtBQUN6RCw0Q0FBNEMsZ0RBQWU7QUFDM0QsMkNBQTJDLGdEQUFlOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSxVQUFVLCtDQUFhOztBQUV2QixXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEUseUJBQXlCLG9FQUF1Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBaUM7QUFDeEQsc0JBQXNCLHlDQUFPO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1DQUFtQyx5Q0FBTztBQUMxQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaURBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7O0FBRUE7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLElBQUksbUJBQW1COztBQUV4RSxvQkFBb0IsZ0RBQWU7O0FBRW5DO0FBQ0EsUUFBUSxrRUFBcUI7O0FBRTdCLCtCQUErQix5Q0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdEQUFlOztBQUVuQyxvQkFBb0IsZ0RBQWU7O0FBRW5DO0FBQ0EsNkNBQTZDLG1EQUFrQixzQkFBc0I7QUFDckYsa0RBQWtELDBCQUEwQjtBQUM1RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUFtQzs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQywwREFBMEQsWUFBWSxJQUFJLEVBQUUsR0FBRyxTQUFTO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0RBQXFCOzs7QUFHakM7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBa0I7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLCtDQUFrQjtBQUN4Qzs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZ0RBQU07O0FBRWhDLHNFQUFzRSxFQUFFO0FBQ3hFLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZEQUE2RCxFQUFFO0FBQy9ELGtCQUFrQix1RUFBbUM7QUFDckQsd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUEseUJBQXlCLG1EQUFTOztBQUVsQyxzQkFBc0IsZ0RBQU07O0FBRTVCO0FBQ0E7O0FBRUEsc0VBQXNFLEVBQUU7QUFDeEUsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0EsNERBQTRELEVBQUU7QUFDOUQ7O0FBRUEsK0RBQStELEVBQUU7QUFDakUsa0JBQWtCLHVFQUFtQztBQUNyRDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV92ZXJpZnkuanM/ZDBiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMga2V5UGFpciBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5pbXBvcnQgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHsgQ2hhQ2hhLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ciwgcHJldiwgbG9nZ2VyKSB7XG4gICAgbGV0IHNyO1xuICAgIGlmIChjdXIudHlwZSA9PSAxKSB7ICAgIC8vIFZlcmlmeSB0aGUgYmVhY29uLlxuICAgICAgICBjb25zdCBiZWFjb25LZXkgPSB1dGlscy5rZXlGcm9tQmVhY29uKGN1cnZlLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5iZWFjb25IYXNoLCBjdXIubnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LnRhdS5nMV9zLCBiZWFjb25LZXkudGF1LmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfc3gsIGJlYWNvbktleS50YXUuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkudGF1LmcyX3NweCwgYmVhY29uS2V5LnRhdS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYWxwaGEuZzFfcywgYmVhY29uS2V5LmFscGhhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3N4LCBiZWFjb25LZXkuYWxwaGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5hbHBoYS5nMl9zcHgsIGJlYWNvbktleS5hbHBoYS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5iZXRhLmcxX3MsIGJlYWNvbktleS5iZXRhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zeCwgYmVhY29uS2V5LmJldGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LmJldGEuZzJfc3B4LCBiZWFjb25LZXkuYmV0YS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3VyLmtleS50YXUuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShrZXlQYWlyLmdldEcyc3AoY3VydmUsIDAsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gpKTtcbiAgICBjdXIua2V5LmFscGhhLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoa2V5UGFpci5nZXRHMnNwKGN1cnZlLCAxLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCkpO1xuICAgIGN1ci5rZXkuYmV0YS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGtleVBhaXIuZ2V0RzJzcChjdXJ2ZSwgMiwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4KSk7XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIGN1ci5rZXkudGF1LmcyX3NwLCBjdXIua2V5LnRhdS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAodGF1KSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgY3VyLmtleS5hbHBoYS5nMV9zLCBjdXIua2V5LmFscGhhLmcxX3N4LCBjdXIua2V5LmFscGhhLmcyX3NwLCBjdXIua2V5LmFscGhhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5IChhbHBoYSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkuYmV0YS5nMV9zLCBjdXIua2V5LmJldGEuZzFfc3gsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5IChiZXRhKSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgcHJldi50YXVHMSwgY3VyLnRhdUcxLCBjdXIua2V5LnRhdS5nMl9zcCwgY3VyLmtleS50YXUuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCB0YXUqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsICBjdXIua2V5LnRhdS5nMV9zLCBjdXIua2V5LnRhdS5nMV9zeCwgcHJldi50YXVHMiwgY3VyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCB0YXUqRzIuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYuYWxwaGFHMSwgY3VyLmFscGhhRzEsIGN1ci5rZXkuYWxwaGEuZzJfc3AsIGN1ci5rZXkuYWxwaGEuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBhbHBoYSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgcHJldi5iZXRhRzEsIGN1ci5iZXRhRzEsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgIGN1ci5rZXkuYmV0YS5nMV9zLCBjdXIua2V5LmJldGEuZzFfc3gsIHByZXYuYmV0YUcyLCBjdXIuYmV0YUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBiZXRhKkcyLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIkl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQb3dlcnMgT2YgdGF1IGZpbGUgT0shXCIpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB2ZXJpZnkodGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGxldCBzcjtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBvd2VyOiAyKipcIiArIHBvd2VyKTtcbiAgICAvLyBWZXJpZnkgTGFzdCBjb250cmlidXRpb25cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNvbXB1dGluZyBpbml0aWFsIGNvbnRyaWJ1dGlvbiBoYXNoXCIpO1xuICAgIGNvbnN0IGluaXRpYWxDb250cmlidXRpb24gPSB7XG4gICAgICAgIHRhdUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICB0YXVHMjogY3VydmUuRzIuZyxcbiAgICAgICAgYWxwaGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICBiZXRhRzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIG5leHRDaGFsbGVuZ2U6IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgY2VyZW1vbnlQb3dlciwgbG9nZ2VyKSxcbiAgICAgICAgcmVzcG9uc2VIYXNoOiBCbGFrZTJiKDY0KS5kaWdlc3QoKVxuICAgIH07XG5cbiAgICBpZiAoY29udHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgbm8gY29udHJpYnV0aW9uISBJdCBjYW5ub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZDb250cjtcbiAgICBpZiAoY29udHJzLmxlbmd0aD4xKSB7XG4gICAgICAgIHByZXZDb250ciA9IGNvbnRyc1tjb250cnMubGVuZ3RoLTJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDb250ciA9IGluaXRpYWxDb250cmlidXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ckNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMV07XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGluZyBjb250cmlidXRpb24gI1wiK2NvbnRyc1tjb250cnMubGVuZ3RoLTFdLmlkKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcblxuXG4gICAgY29uc3QgbmV4dENvbnRyaWJ1dGlvbkhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgclRhdTEuUjEsIHJUYXUxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcxIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJ2ZS5HMS5nLCByVGF1MS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzEgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJDb250ci50YXVHMSwgclRhdTEuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXdhaXQgdGVzdCgpO1xuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gdGF1KkcyXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiB0YXUqRzIgc2VjdGlvblwiKTtcbiAgICBjb25zdCByVGF1MiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgXCJ0YXVHMlwiLCAyICoqIHBvd2VyLCBbMCwgMV0sICBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJDb250ci50YXVHMSwgclRhdTIuUjEsIHJUYXUyLlIyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzIgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1cnZlLkcyLmcsIHJUYXUyLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ckNvbnRyLnRhdUcyLCByVGF1Mi5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiBhbHBoYSp0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIGFscGhhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJBbHBoYVRhdUcxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCBcImFscGhhdGF1RzFcIiwgMiAqKiBwb3dlciwgWzBdLCBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgckJldGFUYXVHMS5SMSwgckJldGFUYXVHMS5SMiwgY3VydmUuRzIuZywgY3VyQ29udHIudGF1RzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJiZXRhVGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLmJldGFHMSwgckJldGFUYXVHMS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiBiZXRhKnRhdSpHMSBzZWN0aW9uIChiZXRhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vVmVyaWZ5IEJldGEgRzJcbiAgICBjb25zdCBiZXRhRzIgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpO1xuICAgIGlmICghY3VydmUuRzIuZXEoY3VyQ29udHIuYmV0YUcyLCBiZXRhRzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFHMiBlbGVtZW50IGluIGJldGFHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCBuZXh0Q29udHJpYnV0aW9uSGFzaCA9IG5leHRDb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAvLyBDaGVjayB0aGUgbmV4dENoYWxsZW5nZUhhc2hcbiAgICBpZiAocG93ZXIgPT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChuZXh0Q29udHJpYnV0aW9uSGFzaCwgXCJOZXh0IGNoYWxsZW5nZSBoYXNoOiBcIikpO1xuXG4gICAgLy8gVmVyaWZ5IFByZXZpb3VzIGNvbnRyaWJ1dGlvbnNcblxuICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpO1xuICAgIGZvciAobGV0IGkgPSBjb250cnMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjdXJDb250ciA9IGNvbnRyc1tpXTtcbiAgICAgICAgY29uc3QgcHJldkNvbnRyID0gIChpPjApID8gY29udHJzW2ktMV0gOiBpbml0aWFsQ29udHJpYnV0aW9uO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAoKCFzZWN0aW9uc1sxMl0pIHx8ICghc2VjdGlvbnNbMTNdKSB8fCAoIXNlY3Rpb25zWzE0XSkgfHwgKCFzZWN0aW9uc1sxNV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJ0aGlzIGZpbGUgZG9lcyBub3QgY29udGFpbiBwaGFzZTIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuIFBsZWFzZSBydW46IFxcblwiICtcbiAgICAgICAgICAgIFwiICAgc25hcmtqcyBcXFwicG93ZXJzb2Z0YXUgcHJlcGFyZXBoYXNlMlxcXCIgdG8gcHJlcGFyZSB0aGlzIGZpbGUgdG8gYmUgdXNlZCBpbiB0aGUgcGhhc2UyIGNlcmVtb255LlwiXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcxXCIsIDIsIDEyLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMlwiLCAzLCAxMywgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNCwgMTQsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNSwgMTUsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIG9mIFRhdSBPayFcIik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpIHtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYENvbnRyaWJ1dGlvbiAjJHtjdXJDb250ci5pZH06ICR7Y3VyQ29udHIubmFtZSB8fFwiXCJ9YCk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgICAgICByZXNwb25zZUhhc2hlci5zZXRQYXJ0aWFsSGFzaChjdXJDb250ci5wYXJ0aWFsSGFzaCk7XG4gICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiUmVzcG9uc2UgSGFzaDpcIikpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7bWlzYy5ieXRlQXJyYXkyaGV4KGN1ckNvbnRyLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjdXJDb250ci5udW1JdGVyYXRpb25zRXhwfWApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBidWZmVXYgPSBuZXcgVWludDhBcnJheShzRyk7XG5cbiAgICAgICAgaWYgKCFzZWN0aW9uc1s2XSkgIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25zWzZdLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgR2V0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmQucG9zID0gc2VjdGlvbnNbNl1bMF0ucDtcblxuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZik7XG5cbiAgICAgICAgRy50b1JwclVuY29tcHJlc3NlZChidWZmVXYsIDAsIFApO1xuICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShidWZmVXYpO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKGlkU2VjdGlvbiwgZ3JvdXBOYW1lLCBzZWN0aW9uTmFtZSwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDE2O1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbmV3IFVpbnQ4QXJyYXkoNCoobi0xKSk7XG4gICAgICAgICAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoc2NhbGFycyk7XG5cblxuICAgICAgICAgICAgaWYgKGk+MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0QmFzZSA9IEcuZnJvbVJwckxFTShiYXNlcywgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkVUludDMyQkUoMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBSMSA9IEcuYWRkKFIxLCBHLnRpbWVzU2NhbGFyKGxhc3RCYXNlLCByKSk7XG4gICAgICAgICAgICAgICAgUjIgPSBHLmFkZChSMiwgRy50aW1lc1NjYWxhcihmaXJzdEJhc2UsIHIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcjEgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKDAsIChuLTEpKnNHKSwgc2NhbGFycyk7XG4gICAgICAgICAgICBjb25zdCByMiA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMuc2xpY2Uoc0cpLCBzY2FsYXJzKTtcblxuICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgcjEpO1xuICAgICAgICAgICAgUjIgPSBHLmFkZChSMiwgcjIpO1xuXG4gICAgICAgICAgICBsYXN0QmFzZSA9IEcuZnJvbVJwckxFTSggYmFzZXMsIChuLTEpKnNHKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHNpbmd1bGFyUG9pbnRJbmRleGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3AgPSBzaW5ndWxhclBvaW50SW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwID49aSkgJiYgKHNwIDwgaStuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByTEVNKGJhc2VzLCAoc3AtaSkqc0cpO1xuICAgICAgICAgICAgICAgICAgICBzaW5ndWxhclBvaW50cy5wdXNoKFApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFIxOiBSMSxcbiAgICAgICAgICAgIFIyOiBSMixcbiAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzOiBzaW5ndWxhclBvaW50c1xuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhnTmFtZSwgdGF1U2VjdGlvbiwgbGFncmFuZ2VTZWN0aW9uLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBWZXJpZnlpbmcgcGhhc2UyIGNhbGN1bGF0ZWQgdmFsdWVzICR7c2VjdGlvbk5hbWV9Li4uYCk7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtnTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRVSW50MzJCRSgwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHA9MDsgcDw9IHBvd2VyOyBwICsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGF1U2VjdGlvbiA9PSAyKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwb3dlcisxKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQb3dlcihwKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFBvd2VyICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGxldCBidWZmX3IgPSBuZXcgVWludDMyQXJyYXkoblBvaW50cyk7XG4gICAgICAgICAgICBsZXQgYnVmZkc7XG5cbiAgICAgICAgICAgIGxldCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYENyZWF0aW5nIHJhbmRvbSBudW1iZXJzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHAgPT0gcG93ZXIrMSkmJihpID09IG5Qb2ludHMtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmX3JbaV0gPSBybmcubmV4dFUzMigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZl9yID0gbmV3IFVpbnQ4QXJyYXkoYnVmZl9yLmJ1ZmZlciwgYnVmZl9yLmJ5dGVPZmZzZXQsIGJ1ZmZfci5ieXRlTGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGByZWFkaW5nIHBvaW50cyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIHRhdVNlY3Rpb24pO1xuICAgICAgICAgICAgYnVmZkcgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0cpO1xuICAgICAgICAgICAgaWYgKHAgPT0gcG93ZXIrMSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmRywgMCwgKG5Qb2ludHMtMSkqc0cpO1xuICAgICAgICAgICAgICAgIGJ1ZmZHLnNldChjdXJ2ZS5HMS56ZXJvQWZmaW5lLCAoblBvaW50cy0xKSpzRyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmRywgMCwgblBvaW50cypzRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNUYXUgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZHLCBidWZmX3IsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIl9cIiArIHApO1xuXG4gICAgICAgICAgICBidWZmX3IgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMgKiBuOHIpO1xuXG4gICAgICAgICAgICBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmNCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgY29uc3QgYnVmZjRWID0gbmV3IERhdGFWaWV3KGJ1ZmY0LmJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgcmFuZG9tIG51bWJlcnMgUG93ZXJzJHtwfS4uLmApO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoaSAhPSBuUG9pbnRzLTEpIHx8IChwICE9IHBvd2VyKzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmY0Vi5zZXRVaW50MzIoMCwgcm5nLm5leHRVMzIoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZfci5zZXQoYnVmZjQsIGkqbjhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgYmF0Y2hUb01vbnRnb21lcnkgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZl9yKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgZmZ0ICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGJ1ZmZfciA9IGF3YWl0IGN1cnZlLkZyLmZmdChidWZmX3IpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBiYXRjaEZyb21Nb250Z29tZXJ5ICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGJ1ZmZfciA9IGF3YWl0IGN1cnZlLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkoYnVmZl9yKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGByZWFkaW5nIHBvaW50cyBMYWdyYW5nZSR7cH0uLi5gKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgbGFncmFuZ2VTZWN0aW9uKTtcbiAgICAgICAgICAgIGZkLnBvcyArPSBzRyooKDIgKiogcCktMSk7XG4gICAgICAgICAgICBhd2FpdCBmZC5yZWFkVG9CdWZmZXIoYnVmZkcsIDAsIG5Qb2ludHMqc0cpO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzTGFncmFuZ2UgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZHLCBidWZmX3IsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIl9cIiArIHAgKyBcIl90cmFuc2Zvcm1lZFwiKTtcblxuICAgICAgICAgICAgaWYgKCFHLmVxKHJlc1RhdSwgcmVzTGFncmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUGhhc2UyIGNhY2x1dGF0aW9uIGRvZXMgbm90IG1hdGNoIHdpdGggcG93ZXJzIG9mIHRhdVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/powersoftau_verify.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/proof.js":
/*!****************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/proof.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Proof: () => (/* binding */ Proof)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof() {\n        let res = {polynomials: {}, evaluations: {}};\n\n        Object.keys(this.polynomials).forEach(key => {\n            res.polynomials[key] = this.curve.G1.toObject(this.polynomials[key]);\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            res.evaluations[key] = this.curve.Fr.toObject(this.evaluations[key]);\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcHJvb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7O0FBRWxDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wcm9vZi5qcz83NTBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBjbGFzcyBQcm9vZiB7XG4gICAgY29uc3RydWN0b3IoY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuICAgIH1cblxuICAgIHJlc2V0UHJvb2YoKSB7XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwoa2V5LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5wb2x5bm9taWFscykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwuJHtrZXl9IGFscmVhZHkgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9seW5vbWlhbHNba2V5XTtcbiAgICB9XG5cbiAgICBhZGRFdmFsdWF0aW9uKGtleSwgZXZhbHVhdGlvbikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9ucy4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IGV2YWx1YXRpb247XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogZXZhbHVhdGlvbiAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHRvT2JqZWN0UHJvb2YoKSB7XG4gICAgICAgIGxldCByZXMgPSB7cG9seW5vbWlhbHM6IHt9LCBldmFsdWF0aW9uczoge319O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucG9seW5vbWlhbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJlcy5wb2x5bm9taWFsc1trZXldID0gdGhpcy5jdXJ2ZS5HMS50b09iamVjdCh0aGlzLnBvbHlub21pYWxzW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICByZXMuZXZhbHVhdGlvbnNba2V5XSA9IHRoaXMuY3VydmUuRnIudG9PYmplY3QodGhpcy5ldmFsdWF0aW9uc1trZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0UHJvb2Yob2JqZWN0UHJvb2YpIHtcbiAgICAgICAgdGhpcy5yZXNldFByb29mKCk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0UHJvb2YucG9seW5vbWlhbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9seW5vbWlhbHNba2V5XSA9IHRoaXMuY3VydmUuRzEuZnJvbU9iamVjdChvYmplY3RQcm9vZi5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IHRoaXMuY3VydmUuRnIuZnJvbU9iamVjdChvYmplY3RQcm9vZi5ldmFsdWF0aW9uc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/proof.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/r1cs.js":
/*!***************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/r1cs.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportJson: () => (/* reexport safe */ _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   info: () => (/* reexport safe */ _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   print: () => (/* reexport safe */ _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./r1cs_print.js */ \"(rsc)/../backend/node_modules/snarkjs/src/r1cs_print.js\");\n/* harmony import */ var _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./r1cs_info.js */ \"(rsc)/../backend/node_modules/snarkjs/src/r1cs_info.js\");\n/* harmony import */ var _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./r1cs_export_json.js */ \"(rsc)/../backend/node_modules/snarkjs/src/r1cs_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVpRDtBQUNGO0FBQ2EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzLmpzP2I3MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIHByaW50fSBmcm9tIFwiLi9yMWNzX3ByaW50LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW5mb30gZnJvbSBcIi4vcjFjc19pbmZvLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0SnNvbn0gZnJvbSBcIi4vcjFjc19leHBvcnRfanNvbi5qc1wiO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/r1cs.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/r1cs_constraint_processor.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/r1cs_constraint_processor.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r1csConstraintProcessor: () => (/* binding */ r1csConstraintProcessor)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        // for (let s in linCom1) {\n        //     const val = this.Fr.mul(k, linCom1[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n        //\n        // for (let s in linCom2) {\n        //     const val = this.Fr.mul(k, linCom2[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = linCom2[s];\n            } else {\n                res[s] = this.Fr.add(res[s], linCom2[s]);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfY29uc3RyYWludF9wcm9jZXNzb3IuanM/ZGI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUgPSAwO1xuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UID0gMTtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRSA9IDI7XG5cbmV4cG9ydCBjbGFzcyByMWNzQ29uc3RyYWludFByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoRnIsIGZuR2V0Q29uc3RhbnRDb25zdHJhaW50LCBmbkdldEFkZGl0aW9uQ29uc3RyYWludCwgZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLkZyID0gRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50ID0gZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQ7XG4gICAgICAgIHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQgPSBmbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludDtcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc0NvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNDKTtcblxuICAgICAgICBjb25zdCBsY3RBID0gdGhpcy5nZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgY29uc3QgbGN0QiA9IHRoaXMuZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQik7XG5cbiAgICAgICAgaWYgKChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpIHx8IChsY3RCID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDKTtcbiAgICAgICAgfSBlbHNlIGlmIChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSB0aGlzLmpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGNCLCBsY0MsIGxjQVswXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDQyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICBjb25zdCBsY0NDID0gdGhpcy5qb2luTGluZWFyQ29tYmluYXRpb25zKGxjQSwgbGNDLCBsY0JbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQ0MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxpbkNvbSkge1xuICAgICAgICAvLyBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3Qgc2lnbmFsSWRzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYWxJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGlmIChzaWduYWxJZHNbaV0gPT09IFwiMFwiKSB7XG4gICAgICAgIC8vICAgICAgICAgayA9IHRoaXMuRnIuYWRkKGssIGxpbkNvbVtzaWduYWxJZHNbaV1dKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoIXRoaXMuRnIuZXEoaywgdGhpcy5Gci56ZXJvKSkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVDtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRTtcblxuICAgICAgICBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5Db21bc3NbaV1dID09IDBuKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbkNvbVtzc1tpXV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICBrID0gdGhpcy5Gci5hZGQoaywgbGluQ29tW3NzW2ldXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEU7XG4gICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oaykpIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQ7XG4gICAgICAgIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEU7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGluQ29tKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbElkcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmFsSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5Gci5pc1plcm8obGluQ29tW3NpZ25hbElkc1tpXV0pKSBkZWxldGUgbGluQ29tW3NpZ25hbElkc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluQ29tO1xuICAgIH1cblxuICAgIGpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGluQ29tMSwgbGluQ29tMiwgaykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICAvLyBmb3IgKGxldCBzIGluIGxpbkNvbTEpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHZhbCA9IHRoaXMuRnIubXVsKGssIGxpbkNvbTFbc10pO1xuICAgICAgICAvLyAgICAgcmVzW3NdID0gIShzIGluIHJlcykgPyB2YWwgOiB0aGlzLkZyLmFkZCh2YWwsIHJlc1tzXSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZm9yIChsZXQgcyBpbiBsaW5Db20yKSB7XG4gICAgICAgIC8vICAgICBjb25zdCB2YWwgPSB0aGlzLkZyLm11bChrLCBsaW5Db20yW3NdKTtcbiAgICAgICAgLy8gICAgIHJlc1tzXSA9ICEocyBpbiByZXMpID8gdmFsIDogdGhpcy5Gci5hZGQodmFsLCByZXNbc10pO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5Db20xKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5tdWwoaywgbGluQ29tMVtzXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHRoaXMuRnIuYWRkKHJlc1tzXSwgdGhpcy5Gci5tdWwoaywgbGluQ29tMVtzXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5Db20yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gbGluQ29tMltzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCBsaW5Db20yW3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKHJlcyk7XG4gICAgfVxuXG4gICAgcmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxpbkNvbSwgbWF4Qykge1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBrOiB0aGlzLkZyLnplcm8sXG4gICAgICAgICAgICBzaWduYWxzOiBbXSxcbiAgICAgICAgICAgIGNvZWZzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHNpZ25hbElkIGluIGxpbkNvbSkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbElkID09IDApIHtcbiAgICAgICAgICAgICAgICByZXMuayA9IHRoaXMuRnIuYWRkKHJlcy5rLCBsaW5Db21bc2lnbmFsSWRdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluQ29tW3NpZ25hbElkXSAhPSAwbikge1xuICAgICAgICAgICAgICAgIGNzLnB1c2goW051bWJlcihzaWduYWxJZCksIGxpbkNvbVtzaWduYWxJZF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChjcy5sZW5ndGggPiBtYXhDKSB7XG4gICAgICAgICAgICBjb25zdCBjMSA9IGNzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGNzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBzbyA9IHNldHRpbmdzLm5WYXJzKys7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5mbkdldEFkZGl0aW9uQ29uc3RyYWludChcbiAgICAgICAgICAgICAgICBjMVswXSwgYzJbMF0sIHNvLFxuICAgICAgICAgICAgICAgIHRoaXMuRnIubmVnKGMxWzFdKSwgdGhpcy5Gci5uZWcoYzJbMV0pLCB0aGlzLkZyLnplcm8sIHRoaXMuRnIub25lLCB0aGlzLkZyLnplcm8pO1xuXG4gICAgICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIGFkZGl0aW9uc0Fyci5wdXNoKFtjMVswXSwgYzJbMF0sIGMxWzFdLCBjMlsxXV0pO1xuXG4gICAgICAgICAgICBjcy5wdXNoKFtzbywgdGhpcy5Gci5vbmVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5zaWduYWxzW2ldID0gY3NbaV1bMF07XG4gICAgICAgICAgICByZXMuY29lZnNbaV0gPSBjc1tpXVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZXMuY29lZnMubGVuZ3RoIDwgbWF4Qykge1xuICAgICAgICAgICAgcmVzLnNpZ25hbHMucHVzaCgwKTtcbiAgICAgICAgICAgIHJlcy5jb2Vmcy5wdXNoKHRoaXMuRnIuemVybyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHByb2Nlc3NSMWNzQWRkaXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsaW5Db20pIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQXJyID0gW107XG5cbiAgICAgICAgY29uc3QgQyA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxpbkNvbSwgMyk7XG5cbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgQy5zaWduYWxzWzBdLCBDLnNpZ25hbHNbMV0sIEMuc2lnbmFsc1syXSxcbiAgICAgICAgICAgIEMuY29lZnNbMF0sIEMuY29lZnNbMV0sIHRoaXMuRnIuemVybywgQy5jb2Vmc1syXSwgQy5rKTtcblxuICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcblxuICAgICAgICByZXR1cm4gW2NvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnJdO1xuICAgIH1cblxuICAgIHByb2Nlc3NSMWNzTXVsdGlwbGljYXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsY0EsIGxjQiwgbGNDKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzQXJyID0gW107XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0FyciA9IFtdO1xuXG4gICAgICAgIGNvbnN0IEEgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0EsIDEpO1xuICAgICAgICBjb25zdCBCID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNCLCAxKTtcbiAgICAgICAgY29uc3QgQyA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQywgMSk7XG5cbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0TXVsdGlwbGljYXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgQS5zaWduYWxzWzBdLCBCLnNpZ25hbHNbMF0sIEMuc2lnbmFsc1swXSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuY29lZnNbMF0sIEIuayksXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmssIEIuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5jb2Vmc1swXSwgQi5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLm5lZyhDLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIuc3ViKHRoaXMuRnIubXVsKEEuaywgQi5rKSwgQy5rKSk7XG5cbiAgICAgICAgY29uc3RyYWludHNBcnIucHVzaChjb25zdHJhaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIFtjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyXTtcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/r1cs_constraint_processor.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/r1cs_export_json.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/r1cs_export_json.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csExportJson)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1cs)(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.stringifyBigIntsWithField)(Fr, cir);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVtQztBQUNtQjs7O0FBR3ZDOztBQUVmLHNCQUFzQixrREFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBeUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzX2V4cG9ydF9qc29uLmpzP2FkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtyZWFkUjFjc30gIGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0IHsgc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZCB9IGZyb20gXCIuL21pc2MuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiByMWNzRXhwb3J0SnNvbihyMWNzRmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgY2lyID0gYXdhaXQgcmVhZFIxY3MocjFjc0ZpbGVOYW1lLCB0cnVlLCB0cnVlLCB0cnVlLCBsb2dnZXIpO1xuICAgIGNvbnN0IEZyPWNpci5jdXJ2ZS5GcjtcbiAgICBkZWxldGUgY2lyLmN1cnZlO1xuICAgIGRlbGV0ZSBjaXIuRjtcblxuICAgIHJldHVybiBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBjaXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/r1cs_export_json.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/r1cs_info.js":
/*!********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/r1cs_info.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csInfo)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_1__.readR1cs)(r1csName);\n\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0Q7O0FBRXJDLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVOOztBQUVmLHNCQUFzQixrREFBUTs7QUFFOUIsUUFBUSxnREFBTTtBQUNkO0FBQ0EsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOLHlEQUF5RCxnREFBTSxxQkFBcUI7QUFDcEY7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxpREFBaUQsaUJBQWlCO0FBQ2xFLG9EQUFvRCxlQUFlO0FBQ25FLG1EQUFtRCxlQUFlO0FBQ2xFLDRDQUE0QyxZQUFZO0FBQ3hELDZDQUE2QyxhQUFhOztBQUUxRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19pbmZvLmpzPzIzMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IHsgcmVhZFIxY3MgfSAgZnJvbSBcInIxY3NmaWxlXCI7XG5cbmNvbnN0IGJsczEyMzgxciA9IFNjYWxhci5lKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiByMWNzSW5mbyhyMWNzTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBjaXIgPSBhd2FpdCByZWFkUjFjcyhyMWNzTmFtZSk7XG5cbiAgICBpZiAoU2NhbGFyLmVxKGNpci5wcmltZSwgYm4xMjhyKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkN1cnZlOiBibi0xMjhcIik7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoY2lyLnByaW1lLCBibHMxMjM4MXIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiQ3VydmU6IGJsczEyLTM4MVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgVW5rbm93biBDdXJ2ZS4gUHJpbWU6ICR7U2NhbGFyLnRvU3RyaW5nKGNpci5wcmltZSl9YCk7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFdpcmVzOiAke2Npci5uVmFyc31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBDb25zdHJhaW50czogJHtjaXIubkNvbnN0cmFpbnRzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFByaXZhdGUgSW5wdXRzOiAke2Npci5uUHJ2SW5wdXRzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFB1YmxpYyBJbnB1dHM6ICR7Y2lyLm5QdWJJbnB1dHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgTGFiZWxzOiAke2Npci5uTGFiZWxzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIE91dHB1dHM6ICR7Y2lyLm5PdXRwdXRzfWApO1xuXG4gICAgcmV0dXJuIGNpcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/r1cs_info.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/r1cs_print.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/r1cs_print.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csPrint)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19wcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixjQUFjLFFBQVEsY0FBYyxRQUFRLGNBQWM7QUFDakY7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfcHJpbnQuanM/OTkxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByMWNzUHJpbnQocjFjcywgc3ltcywgbG9nZ2VyKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpPHIxY3MuY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJpbnRDb3N0cmFpbnQocjFjcy5jb25zdHJhaW50c1tpXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByaW50Q29zdHJhaW50KGMpIHtcbiAgICAgICAgY29uc3QgbGMyc3RyID0gKGxjKSA9PiB7XG4gICAgICAgICAgICBsZXQgUyA9IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gc3ltcy52YXJJZHgyTmFtZVtrXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIm9uZVwiKSBuYW1lID0gXCIxXCI7XG5cbiAgICAgICAgICAgICAgICBsZXQgdnMgPSByMWNzLmN1cnZlLkZyLnRvU3RyaW5nKGxjW2tdKTtcbiAgICAgICAgICAgICAgICBpZiAodnMgPT0gXCIxXCIpIHZzID0gXCJcIjsgIC8vIERvIG5vdCBzaG93IG9uZXNcbiAgICAgICAgICAgICAgICBpZiAodnMgPT0gXCItMVwiKSB2cyA9IFwiLVwiOyAgLy8gRG8gbm90IHNob3cgb25lc1xuICAgICAgICAgICAgICAgIGlmICgoUyE9XCJcIikmJih2c1swXSE9XCItXCIpKSB2cyA9IFwiK1wiK3ZzO1xuICAgICAgICAgICAgICAgIGlmIChTIT1cIlwiKSB2cyA9IFwiIFwiK3ZzO1xuICAgICAgICAgICAgICAgIFM9IFMgKyB2cyAgICsgbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFMgPSBgWyAke2xjMnN0cihjWzBdKX0gXSAqIFsgJHtsYzJzdHIoY1sxXSl9IF0gLSBbICR7bGMyc3RyKGNbMl0pfSBdID0gMGA7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFMpO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/r1cs_print.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns.js":
/*!***************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculate: () => (/* reexport safe */ _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   check: () => (/* reexport safe */ _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   debug: () => (/* reexport safe */ _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_debug.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_debug.js\");\n/* harmony import */ var _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_export_json.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_export_json.js\");\n/* harmony import */ var _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wtns_check.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_check.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Rucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXlEO0FBQ1I7QUFDVyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnMuanM/Y2VhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgY2FsY3VsYXRlfSBmcm9tIFwiLi93dG5zX2NhbGN1bGF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlYnVnfSBmcm9tIFwiLi93dG5zX2RlYnVnLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0SnNvbn0gZnJvbSBcIi4vd3Ruc19leHBvcnRfanNvbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNoZWNrfSBmcm9tIFwiLi93dG5zX2NoZWNrLmpzXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns_calculate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCalculate)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(rsc)/../backend/node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm);\n    if (wc.circom_version() == 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jYWxjdWxhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ1o7QUFDeEMsUUFBUSxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFcEI7QUFDZjs7QUFFQSx5QkFBeUIsa0RBQXFCO0FBQzlDO0FBQ0E7O0FBRUEscUJBQXFCLHdFQUF3QjtBQUM3QztBQUNBOztBQUVBLDZCQUE2Qiw4REFBMEI7O0FBRXZELGNBQWMsb0RBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixvREFBdUI7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jYWxjdWxhdGUuanM/YjhlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IFdpdG5lc3NDYWxjdWxhdG9yQnVpbGRlciB9IGZyb20gXCJjaXJjb21fcnVudGltZVwiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHsgIHV0aWxzIH0gICBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd3Ruc0NhbGN1bGF0ZShfaW5wdXQsIHdhc21GaWxlTmFtZSwgd3Ruc0ZpbGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXQgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX2lucHV0KTtcblxuICAgIGNvbnN0IGZkV2FzbSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyh3YXNtRmlsZU5hbWUpO1xuICAgIGNvbnN0IHdhc20gPSBhd2FpdCBmZFdhc20ucmVhZChmZFdhc20udG90YWxTaXplKTtcbiAgICBhd2FpdCBmZFdhc20uY2xvc2UoKTtcblxuICAgIGNvbnN0IHdjID0gYXdhaXQgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyKHdhc20pO1xuICAgIGlmICh3Yy5jaXJjb21fdmVyc2lvbigpID09IDEpIHtcbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgICAgIGF3YWl0IHd0bnNVdGlscy53cml0ZUJpbihmZFd0bnMsIHcsIHdjLnByaW1lKTtcbiAgICAgICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmRXdG5zID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUod3Ruc0ZpbGVOYW1lKTtcblxuICAgICAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV1ROU0JpbihpbnB1dCk7XG5cbiAgICAgICAgYXdhaXQgZmRXdG5zLndyaXRlKHcpO1xuICAgICAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns_calculate.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns_check.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns_check.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCheck)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_2__.readR1csFd)(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Ouputs:         ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jaGVjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1A7QUFDQTtBQUNBOztBQUV2Qjs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLDREQUF3QjtBQUN0Qyx1QkFBdUIsb0RBQVUseUJBQXlCLGdEQUFnRDs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsNkJBQTZCLHNEQUFvQjs7QUFFakQsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUEsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQSx3QkFBd0IscURBQW9CO0FBQzVDO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUF3Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RCx5Q0FBeUMsV0FBVztBQUNwRCx5Q0FBeUMsY0FBYztBQUN2RCx5Q0FBeUMsZ0JBQWdCO0FBQ3pELHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLGFBQWE7QUFDdEQseUNBQXlDLGtCQUFrQjtBQUMzRCx5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSwyREFBMkQsRUFBRSxHQUFHLGtCQUFrQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jaGVjay5qcz82MGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCB7IHJlYWRSMWNzRmQgfSBmcm9tIFwicjFjc2ZpbGVcIjtcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd3Ruc0NoZWNrKHIxY3NGaWxlbmFtZSwgd3Ruc0ZpbGVuYW1lLCBsb2dnZXIpIHtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBDSEVDS0lORyBTVEFSVEVEXCIpO1xuXG4gICAgLy8gUmVhZCByMWNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyByMWNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRSMWNzLFxuICAgICAgICBzZWN0aW9uczogc2VjdGlvbnNSMWNzXG4gICAgfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywgeyBsb2FkQ29uc3RyYWludHM6IGZhbHNlLCBsb2FkQ3VzdG9tR2F0ZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3dG5zRmlsZW5hbWUsIFwid3Ruc1wiLCAyLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBjb25zdCB3dG5zSGVhZGVyID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCB3dG5zU2VjdGlvbnMpO1xuXG4gICAgaWYgKCFTY2FsYXIuZXEocjFjcy5wcmltZSwgd3Ruc0hlYWRlci5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZXaXRuZXNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkV3Rucywgd3Ruc1NlY3Rpb25zLCAyKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgY3VydmVzLmdldEN1cnZlRnJvbVIocjFjcy5wcmltZSk7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBzRnIgPSBGci5uODtcblxuICAgIGNvbnN0IGJSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgV0lUTkVTUyBDSEVDS1wiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VydmU6ICAgICAgICAgICR7cjFjcy5jdXJ2ZS5uYW1lfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzICh3aXJlcyk6ICAgJHtyMWNzLm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBPdXB1dHM6ICAgICAgICAgJHtyMWNzLm5PdXRwdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgSW5wdXRzOiAgJHtyMWNzLm5QdWJJbnB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFByaXZhdGUgSW5wdXRzOiAke3IxY3MublBydklucHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgTGFiZWxzOiAgICAgICAgICR7cjFjcy5uTGFiZWxzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAgJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VzdG9tIEdhdGVzOiAgICR7cjFjcy51c2VDdXN0b21HYXRlc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDaGVja2luZyB3aXRuZXNzIGNvcnJlY3RuZXNzXCIpO1xuXG4gICAgbGV0IGJSMWNzUG9zID0gMDtcbiAgICBsZXQgcmVzID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHIxY3MubkNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGDCt8K3wrcgcHJvY2Vzc2luZyByMWNzIGNvbnN0cmFpbnRzICR7aX0vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vUmVhZCB0aGUgdGhyZWUgbGluZWFyIGNvbWJpbmF0aW9ucyBvZiB0aGUgY29uc3RyYWludCB3aGVyZSBBICogQiAtIEMgPSAwXG4gICAgICAgIGNvbnN0IGxjQSA9IHJlYWRMQygpO1xuICAgICAgICBjb25zdCBsY0IgPSByZWFkTEMoKTtcbiAgICAgICAgY29uc3QgbGNDID0gcmVhZExDKCk7XG5cbiAgICAgICAgLy8gRXZhbHVhdGUgdGhlIGxpbmVhciBjb21iaW5hdGlvbnNcbiAgICAgICAgY29uc3QgZXZhbEEgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQSk7XG4gICAgICAgIGNvbnN0IGV2YWxCID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0IpO1xuICAgICAgICBjb25zdCBldmFsQyA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNDKTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IEEgKiBCIC0gQyA9PSAwXG4gICAgICAgIGlmICghRnIuZXEoRnIuc3ViKEZyLm11bChldmFsQSwgZXZhbEIpLCBldmFsQyksIEZyLnplcm8pKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIsK3wrfCtyBhYm9ydGluZyBjaGVja2luZyBwcm9jZXNzIGF0IGNvbnN0cmFpbnQgXCIgKyBpKTtcbiAgICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmZFIxY3MuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJXSVRORVNTIElTIENPUlJFQ1RcIik7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIldJVE5FU1MgQ0hFQ0tJTkcgRklOSVNIRUQgU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJXSVRORVNTIElTIE5PVCBDT1JSRUNUXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJXSVRORVNTIENIRUNLSU5HIEZJTklTSEVEIFVOU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcblxuICAgIGZ1bmN0aW9uIEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGMpIHtcbiAgICAgICAgbGV0IHJlcyA9IEZyLnplcm87XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxjKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChzaWduYWxJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsVmFsdWUgPSBnZXRXaXRuZXNzVmFsdWUoc2lnbmFsSWQpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsRmFjdG9yID0gbGNbc2lnbmFsSWRdO1xuXG4gICAgICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoc2lnbmFsVmFsdWUsIHNpZ25hbEZhY3RvcikpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRMQygpIHtcbiAgICAgICAgY29uc3QgbGMgPSB7fTtcblxuICAgICAgICBjb25zdCBidWZmVUwzMiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArIDQpO1xuICAgICAgICBiUjFjc1BvcyArPSA0O1xuICAgICAgICBjb25zdCBidWZmVUwzMlYgPSBuZXcgRGF0YVZpZXcoYnVmZlVMMzIuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgbklkeCA9IGJ1ZmZVTDMyVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgYnVmZiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArICg0ICsgcjFjcy5uOCkgKiBuSWR4KTtcbiAgICAgICAgYlIxY3NQb3MgKz0gKDQgKyByMWNzLm44KSAqIG5JZHg7XG4gICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuSWR4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGJ1ZmZWLmdldFVpbnQzMihpICogKDQgKyByMWNzLm44KSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSByMWNzLkYuZnJvbVJwckxFKGJ1ZmYsIGkgKiAoNCArIHIxY3MubjgpICsgNCk7XG4gICAgICAgICAgICBsY1tpZHhdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzVmFsdWUoc2lnbmFsSWQpIHtcbiAgICAgICAgcmV0dXJuIEZyLmZyb21ScHJMRShidWZmV2l0bmVzcy5zbGljZShzaWduYWxJZCAqIHNGciwgc2lnbmFsSWQgKiBzRnIgKyBzRnIpKTtcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns_check.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns_debug.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns_debug.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsDebug)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(rsc)/../backend/node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _loadsyms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadsyms.js */ \"(rsc)/../backend/node_modules/snarkjs/src/loadsyms.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n\n    let wcOps = {\n        sanityCheck: true\n    };\n    let sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n    if (options.set) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, wcOps);\n    const w = await wc.calculateWitness(input);\n\n    const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ2Y7QUFDRztBQUN4QyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOzs7QUFHbkI7O0FBRWY7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVE7QUFDNUI7QUFDQSw4QkFBOEIsd0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3RUFBd0I7QUFDN0M7O0FBRUEseUJBQXlCLDhEQUEwQjs7QUFFbkQsVUFBVSxpREFBZTs7QUFFekI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfZGVidWcuanM/MzE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IFdpdG5lc3NDYWxjdWxhdG9yQnVpbGRlciB9IGZyb20gXCJjaXJjb21fcnVudGltZVwiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IGxvYWRTeW1zIGZyb20gXCIuL2xvYWRzeW1zLmpzXCI7XG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd3Ruc0RlYnVnKF9pbnB1dCwgd2FzbUZpbGVOYW1lLCB3dG5zRmlsZU5hbWUsIHN5bU5hbWUsIG9wdGlvbnMsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgaW5wdXQgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX2lucHV0KTtcblxuICAgIGNvbnN0IGZkV2FzbSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyh3YXNtRmlsZU5hbWUpO1xuICAgIGNvbnN0IHdhc20gPSBhd2FpdCBmZFdhc20ucmVhZChmZFdhc20udG90YWxTaXplKTtcbiAgICBhd2FpdCBmZFdhc20uY2xvc2UoKTtcblxuXG4gICAgbGV0IHdjT3BzID0ge1xuICAgICAgICBzYW5pdHlDaGVjazogdHJ1ZVxuICAgIH07XG4gICAgbGV0IHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1NldFNpZ25hbD0gZnVuY3Rpb24obGFiZWxJZHgsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGluZSBiZWxvdyBzcGxpdHMgdGhlIGFycm93IGxvZyBpbnRvIDIgc3RyaW5ncyB0byBhdm9pZCBzb21lIFNlY3VyZSBFQ01BU2NyaXB0IGlzc3Vlc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTRVQgXCIgKyBzeW0ubGFiZWxJZHgyTmFtZVtsYWJlbElkeF0gKyBcIiA8XCIgKyBcIi0tIFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ0dldFNpZ25hbD0gZnVuY3Rpb24odmFySWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiR0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbdmFySWR4XSArIFwiIC0tXCIgKyBcIj4gXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlcikge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1N0YXJ0Q29tcG9uZW50PSBmdW5jdGlvbihjSWR4KSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNUQVJUOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgICAgIHdjT3BzLmxvZ0ZpbmlzaENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGSU5JU0g6IFwiICsgc3ltLmNvbXBvbmVudElkeDJOYW1lW2NJZHhdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd2NPcHMuc3ltID0gc3ltO1xuXG4gICAgY29uc3Qgd2MgPSBhd2FpdCBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIod2FzbSwgd2NPcHMpO1xuICAgIGNvbnN0IHcgPSBhd2FpdCB3Yy5jYWxjdWxhdGVXaXRuZXNzKGlucHV0KTtcblxuICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgYXdhaXQgd3Ruc1V0aWxzLndyaXRlKGZkV3Rucywgdywgd2MucHJpbWUpO1xuXG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns_debug.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns_export_json.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns_export_json.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsExportJson)\n/* harmony export */ });\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await (0,_wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__.read)(wtnsFileName);\n\n    return w;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDOztBQUV0Qjs7QUFFZixvQkFBb0Isb0RBQUk7O0FBRXhCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX2V4cG9ydF9qc29uLmpzP2VmYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtyZWFkfSBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHd0bnNFeHBvcnRKc29uKHd0bnNGaWxlTmFtZSkge1xuXG4gICAgY29uc3QgdyA9IGF3YWl0IHJlYWQod3Ruc0ZpbGVOYW1lKTtcblxuICAgIHJldHVybiB3O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns_export_json.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/wtns_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   write: () => (/* binding */ write),\n/* harmony export */   writeBin: () => (/* binding */ writeBin)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function write(fd, witness, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, witness[i], n8);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd, 2);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVzQzs7QUFFYzs7O0FBRzdDOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEMsY0FBYyw0REFBd0I7QUFDdEM7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDOztBQUVPOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7OztBQUd0QyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0Qzs7QUFFTzs7QUFFUCxVQUFVLHVFQUFtQztBQUM3QztBQUNBLG9CQUFvQiwyREFBdUI7QUFDM0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsWUFBWTs7QUFFWjs7QUFFTzs7QUFFUCxXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYzs7QUFFekIsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qix3QkFBd0IsMkRBQXVCO0FBQy9DO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfdXRpbHMuanM/N2JhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZShmZCwgd2l0bmVzcywgcHJpbWUpIHtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMSk7XG4gICAgY29uc3QgbjggPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWUpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzcy5sZW5ndGgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8d2l0bmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHdpdG5lc3NbaV0sIG44KTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCwgMik7XG5cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVCaW4oZmQsIHdpdG5lc3NCaW4sIHByaW1lKSB7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGNvbnN0IG44ID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgcHJpbWUsIG44KTtcbiAgICBpZiAod2l0bmVzc0Jpbi5ieXRlTGVuZ3RoICUgbjggIT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHdpdG5lc3NCaW4uYnl0ZUxlbmd0aCAvIG44KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBhd2FpdCBmZC53cml0ZSh3aXRuZXNzQmluKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpIHtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMSk7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBxID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44KTtcbiAgICBjb25zdCBuV2l0bmVzcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4ge244LCBxLCBuV2l0bmVzc307XG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWQoZmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKGZpbGVOYW1lLCBcInd0bnNcIiwgMik7XG5cbiAgICBjb25zdCB7bjgsIG5XaXRuZXNzfSA9IGF3YWl0IHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5XaXRuZXNzOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOCk7XG4gICAgICAgIHJlcy5wdXNoKHYpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/wtns_utils.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey.js":
/*!***************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   bellmanContribute: () => (/* reexport safe */ _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportBellman: () => (/* reexport safe */ _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   exportVerificationKey: () => (/* reexport safe */ _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   importBellman: () => (/* reexport safe */ _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newZKey: () => (/* reexport safe */ _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verifyFromInit: () => (/* reexport safe */ _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   verifyFromR1cs: () => (/* reexport safe */ _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_bellman.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_export_bellman.js\");\n/* harmony import */ var _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_import_bellman.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_import_bellman.js\");\n/* harmony import */ var _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zkey_verify_fromr1cs.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_fromr1cs.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/* harmony import */ var _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zkey_contribute.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_contribute.js\");\n/* harmony import */ var _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zkey_beacon.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_beacon.js\");\n/* harmony import */ var _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_export_json.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_export_json.js\");\n/* harmony import */ var _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zkey_bellman_contribute.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_bellman_contribute.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./zkey_export_solidityverifier.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_export_solidityverifier.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR2lEO0FBQ2lCO0FBQ0E7QUFDRTtBQUNBO0FBQ1Q7QUFDUjtBQUNTO0FBQ2M7QUFDUTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleS5qcz8xYzQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuZXhwb3J0IHtkZWZhdWx0IGFzIG5ld1pLZXl9IGZyb20gXCIuL3prZXlfbmV3LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0QmVsbG1hbn0gZnJvbSBcIi4vemtleV9leHBvcnRfYmVsbG1hbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGltcG9ydEJlbGxtYW59IGZyb20gXCIuL3prZXlfaW1wb3J0X2JlbGxtYW4uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnlGcm9tUjFjc30gZnJvbSBcIi4vemtleV92ZXJpZnlfZnJvbXIxY3MuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnlGcm9tSW5pdH0gZnJvbSBcIi4vemtleV92ZXJpZnlfZnJvbWluaXQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjb250cmlidXRlfSBmcm9tIFwiLi96a2V5X2NvbnRyaWJ1dGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiZWFjb259IGZyb20gXCIuL3prZXlfYmVhY29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0SnNvbn0gZnJvbSBcIi4vemtleV9leHBvcnRfanNvbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJlbGxtYW5Db250cmlidXRlfSBmcm9tIFwiLi96a2V5X2JlbGxtYW5fY29udHJpYnV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydFZlcmlmaWNhdGlvbktleX0gZnJvbSBcIi4vemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlWZXJpZmllcn0gZnJvbSBcIi4vemtleV9leHBvcnRfc29saWRpdHl2ZXJpZmllci5qc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_beacon.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_beacon.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__.ready();\n\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum lenght of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contribuionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contribuionHash, \"Contribution Hash: \"));\n\n    return contribuionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWFjb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1c7QUFDdEI7QUFDQztBQUNNO0FBQ1c7QUFDRTs7O0FBR3ZDO0FBQ2YsVUFBVSwrQ0FBYTs7QUFFdkIsdUJBQXVCLG1EQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLCtCQUErQixRQUFRLDREQUF3QjtBQUMxRSx1QkFBdUIsc0RBQW9COztBQUUzQztBQUNBO0FBQ0E7OztBQUdBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7QUFFbEQsc0JBQXNCLHlEQUF3Qjs7QUFFOUMsNkJBQTZCLHlDQUFPO0FBQ3BDO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxRQUFRLHNEQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0Esa0NBQWtDLHFEQUFRO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsdURBQXFCOztBQUUvQjtBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsbUVBQWlCO0FBQzNCLFVBQVUsbUVBQWlCOztBQUUzQixVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQSwrQkFBK0IseUNBQU87QUFDdEMsSUFBSSxzREFBZ0I7O0FBRXBCOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfYmVhY29uLmpzPzAxYWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9TZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYmVhY29uKHprZXlOYW1lT2xkLCB6a2V5TmFtZU5ldywgbmFtZSwgYmVhY29uSGFzaFN0ciwgbnVtSXRlcmF0aW9uc0V4cCwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3QgYmVhY29uSGFzaCA9IG1pc2MuaGV4MkJ5dGVBcnJheShiZWFjb25IYXNoU3RyKTtcbiAgICBpZiAoICAgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCA9PSAwKVxuICAgICAgICB8fCAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoKjIgIT1iZWFjb25IYXNoU3RyLmxlbmd0aCkpXG4gICAge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIEJlYWNvbiBIYXNoLiAoSXQgbXVzdCBiZSBhIHZhbGlkIGhleGFkZWNpbWFsIHNlcXVlbmNlKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmVhY29uSGFzaC5sZW5ndGg+PTI1Nikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJNYXhpbXVtIGxlbmdodCBvZiBiZWFjb24gaGFzaCBpcyAyNTUgYnl0ZXNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1JdGVyYXRpb25zRXhwID0gcGFyc2VJbnQobnVtSXRlcmF0aW9uc0V4cCk7XG4gICAgaWYgKChudW1JdGVyYXRpb25zRXhwPDEwKXx8KG51bUl0ZXJhdGlvbnNFeHA+NjMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtSXRlcmF0aW9uc0V4cC4gKE11c3QgYmUgYmV0d2VlbiAxMCBhbmQgNjMpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uczogc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlOYW1lT2xkLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLnJuZ0Zyb21CZWFjb25QYXJhbXMoYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICBjb25zdCB0cmFuc2NyaXB0SGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgdHJhbnNjcmlwdEhhc2hlci51cGRhdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxzLmhhc2hQdWJLZXkodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuXG4gICAgemtleS52a19kZWx0YV8xID0gY3VydmUuRzEudGltZXNGcih6a2V5LnZrX2RlbHRhXzEsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGN1cnZlLkcyLnRpbWVzRnIoemtleS52a19kZWx0YV8yLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YUFmdGVyID0gemtleS52a19kZWx0YV8xO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAxO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5udW1JdGVyYXRpb25zRXhwID0gbnVtSXRlcmF0aW9uc0V4cDtcbiAgICBjdXJDb250cmlidXRpb24uYmVhY29uSGFzaCA9IGJlYWNvbkhhc2g7XG5cbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkTmV3LCB6a2V5KTtcblxuICAgIC8vIElDXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmROZXcsIGN1cnZlLCBtcGNQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgdXRpbHMuaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnVpb25IYXNoID0gY29udHJpYnV0aW9uSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNvbnRyaWJ1aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidWlvbkhhc2g7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_beacon.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_bellman_contribute.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_bellman_contribute.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bellmanContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\n\nasync function bellmanContribute(curve, challengeFilename, responesFileName, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responesFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nConttributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nConttributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashPubKey)(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write COntribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashPubKey)(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWxsbWFuX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDRjtBQUNNO0FBQ1A7QUFDNkI7QUFDbEI7QUFDTzs7QUFFckM7QUFDZixVQUFVLCtDQUFhOztBQUV2QixzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5Qyx1QkFBdUIsb0RBQXVCOzs7QUFHOUMscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRFQUEwQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0RUFBMEI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQU87O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFVO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQSxrQ0FBa0MscURBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHlDQUFPO0FBQ3RDLElBQUksMERBQVU7O0FBRWQ7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2JlbGxtYW5fY29udHJpYnV0ZS5qcz9mNDBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIFRhdUcyIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEFscGhhVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgUHVibGljIEtleVxuLy8gICAgICAgICAgQmV0YUcyIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqcyAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdCAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSpiZXRhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqc3AqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdHAqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMip1cCpiZXRhIChjb21wcmVzc2VkKVxuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24gfSBmcm9tIFwiLi9tcGNfYXBwbHlrZXkuanNcIjtcbmltcG9ydCB7IGhhc2hQdWJLZXkgfSBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYmVsbG1hbkNvbnRyaWJ1dGUoY3VydmUsIGNoYWxsZW5nZUZpbGVuYW1lLCByZXNwb25lc0ZpbGVOYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IGRlbHRhID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGRlbHRhKTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBmZEZyb20gPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShyZXNwb25lc0ZpbGVOYW1lKTtcblxuXG4gICAgYXdhaXQgY29weShzRzEpOyAvLyBhbHBoYTFcbiAgICBhd2FpdCBjb3B5KHNHMSk7IC8vIGJldGExXG4gICAgYXdhaXQgY29weShzRzIpOyAvLyBiZXRhMlxuICAgIGF3YWl0IGNvcHkoc0cyKTsgLy8gZ2FtbWEyXG4gICAgY29uc3Qgb2xkRGVsdGExID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgY29uc3QgZGVsdGExID0gY3VydmUuRzEudGltZXNGcihvbGREZWx0YTEsIGRlbHRhKTtcbiAgICBhd2FpdCB3cml0ZUcxKGRlbHRhMSk7XG4gICAgY29uc3Qgb2xkRGVsdGEyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgY29uc3QgZGVsdGEyID0gY3VydmUuRzIudGltZXNGcihvbGREZWx0YTIsIGRlbHRhKTtcbiAgICBhd2FpdCB3cml0ZUcyKGRlbHRhMik7XG5cbiAgICAvLyBJQ1xuICAgIGNvbnN0IG5JQyA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobklDKTtcbiAgICBhd2FpdCBjb3B5KG5JQypzRzEpO1xuXG4gICAgLy8gSFxuICAgIGNvbnN0IG5IID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuSCk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCBudWxsLCBjdXJ2ZSwgXCJHMVwiLCBuSCwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiVU5DT01QUkVTU0VEXCIsIFwiSFwiLCBsb2dnZXIpO1xuXG4gICAgLy8gTFxuICAgIGNvbnN0IG5MID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuTCk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCBudWxsLCBjdXJ2ZSwgXCJHMVwiLCBuTCwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiVU5DT01QUkVTU0VEXCIsIFwiTFwiLCBsb2dnZXIpO1xuXG4gICAgLy8gQVxuICAgIGNvbnN0IG5BID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuQSk7XG4gICAgYXdhaXQgY29weShuQSpzRzEpO1xuXG4gICAgLy8gQjFcbiAgICBjb25zdCBuQjEgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5CMSk7XG4gICAgYXdhaXQgY29weShuQjEqc0cxKTtcblxuICAgIC8vIEIyXG4gICAgY29uc3QgbkIyID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuQjIpO1xuICAgIGF3YWl0IGNvcHkobkIyKnNHMik7XG5cblxuICAgIC8vLy8vLy8vLy9cbiAgICAvLy8gUmVhZCBjb250cmlidXRpb25zXG4gICAgLy8vLy8vLy8vL1xuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBCbGFrZTJiKDY0KTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IHt9O1xuICAgIC8vIGNzSGFzaFxuICAgIG1wY1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuXG4gICAgY29uc3QgbkNvbnR0cmlidXRpb25zID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250dHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSB7IGRlbHRhOnt9IH07XG4gICAgICAgIGMuZGVsdGFBZnRlciA9IGF3YWl0IHJlYWRHMSgpO1xuICAgICAgICBjLmRlbHRhLmcxX3MgPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zeCA9IGF3YWl0IHJlYWRHMSgpO1xuICAgICAgICBjLmRlbHRhLmcyX3NweCA9IGF3YWl0IHJlYWRHMigpO1xuICAgICAgICBjLnRyYW5zY3JpcHQgPSBhd2FpdCBmZEZyb20ucmVhZCg2NCk7XG4gICAgICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgICAgIGhhc2hQdWJLZXkodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGMpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YSA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkgPSBkZWx0YTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgZGVsdGEpKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQgPSB0cmFuc2NyaXB0SGFzaGVyLmRpZ2VzdCgpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwLCBkZWx0YSkpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YUFmdGVyID0gZGVsdGExO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMDtcbiAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cblxuICAgIC8vLy8vLy8vLy9cbiAgICAvLy8gV3JpdGUgQ09udHJpYnV0aW9uXG4gICAgLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgZmRUby53cml0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YUFmdGVyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3MpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfc3gpO1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgYXdhaXQgZmRUby53cml0ZShjLnRyYW5zY3JpcHQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIGhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcbiAgICBhd2FpdCBmZEZyb20uY2xvc2UoKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29weShuQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRSA9IGZkRnJvbS5wYWdlU2l6ZSoyO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJ5dGVzOyBpKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5CeXRlcyAtaSwgQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQobik7XG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcyKFApIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHMik7XG4gICAgICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIFApO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_bellman_contribute.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFLONK_PROTOCOL_ID: () => (/* binding */ FFLONK_PROTOCOL_ID),\n/* harmony export */   GROTH16_PROTOCOL_ID: () => (/* binding */ GROTH16_PROTOCOL_ID),\n/* harmony export */   HEADER_ZKEY_SECTION: () => (/* binding */ HEADER_ZKEY_SECTION),\n/* harmony export */   PLONK_PROTOCOL_ID: () => (/* binding */ PLONK_PROTOCOL_ID)\n/* harmony export */ });\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29uc3RhbnRzLmpzPzMwZDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEhFQURFUl9aS0VZX1NFQ1RJT04gPSAxO1xuXG5leHBvcnQgY29uc3QgR1JPVEgxNl9QUk9UT0NPTF9JRCA9IDE7XG5leHBvcnQgY29uc3QgUExPTktfUFJPVE9DT0xfSUQgPSAyO1xuZXhwb3J0IGNvbnN0IEZGTE9OS19QUk9UT0NPTF9JRCA9IDEwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_contribute.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_contribute.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2contribute)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__.ready();\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contribuionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contribuionHash, \"Contribution Hash: \"));\n\n    return contribuionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb250cmlidXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3RCO0FBQ0M7QUFDTTtBQUNXO0FBQ0U7O0FBRXZDO0FBQ2YsVUFBVSwrQ0FBYTs7QUFFdkIsV0FBVywrQkFBK0IsUUFBUSw0REFBd0I7QUFDMUUsdUJBQXVCLHNEQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFROztBQUVoQyw0QkFBNEIseURBQXVCOztBQUVuRCx3QkFBd0IsOERBQTBCOzs7QUFHbEQsc0JBQXNCLGtEQUFpQjs7QUFFdkMsNkJBQTZCLHlDQUFPO0FBQ3BDO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxRQUFRLHNEQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0Esa0NBQWtDLHFEQUFRO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLHVEQUFxQjs7QUFFL0I7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLG1FQUFpQjtBQUMzQixVQUFVLG1FQUFpQjs7QUFFM0IsVUFBVSwwREFBd0I7O0FBRWxDO0FBQ0E7O0FBRUEsK0JBQStCLHlDQUFPO0FBQ3RDLElBQUksc0RBQWdCOztBQUVwQjs7QUFFQSw0QkFBNEIsZ0RBQWU7QUFDM0MsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb250cmlidXRlLmpzP2JiNjMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9TZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMmNvbnRyaWJ1dGUoemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uczogc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlOYW1lT2xkLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcblxuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5nZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCB0cmFuc2NyaXB0SGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgdHJhbnNjcmlwdEhhc2hlci51cGRhdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxzLmhhc2hQdWJLZXkodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuXG4gICAgemtleS52a19kZWx0YV8xID0gY3VydmUuRzEudGltZXNGcih6a2V5LnZrX2RlbHRhXzEsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGN1cnZlLkcyLnRpbWVzRnIoemtleS52a19kZWx0YV8yLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YUFmdGVyID0gemtleS52a19kZWx0YV8xO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAwO1xuICAgIGlmIChuYW1lKSBjdXJDb250cmlidXRpb24ubmFtZSA9IG5hbWU7XG5cbiAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVIZWFkZXIoZmROZXcsIHprZXkpO1xuXG4gICAgLy8gSUNcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG5cbiAgICAvLyBDb2VmZnMgKEtlZXAgb3JpZ2luYWwpXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuXG4gICAgLy8gQSBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUpO1xuXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcblxuICAgIC8vIEIyIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBjb25zdCBpbnZEZWx0YSA9IGN1cnZlLkZyLmludihjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICBhd2FpdCBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA4LCBjdXJ2ZSwgXCJHMVwiLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJMIFNlY3Rpb25cIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA5LCBjdXJ2ZSwgXCJHMVwiLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJIIFNlY3Rpb25cIiwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IHprZXlVdGlscy53cml0ZU1QQ1BhcmFtcyhmZE5ldywgY3VydmUsIG1wY1BhcmFtcyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBCbGFrZTJiKDY0KTtcbiAgICB1dGlscy5oYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBjb25zdCBjb250cmlidWlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNvbnRyaWJ1aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidWlvbkhhc2g7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_contribute.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_export_bellman.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_export_bellman.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2exportMPCParams)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be allways m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDb0Q7QUFDUDtBQUNSO0FBQ21COztBQUV6Qzs7QUFFZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3QjtBQUMvRSx1QkFBdUIsc0RBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTs7QUFFQSw0QkFBNEIseURBQXVCOztBQUVuRCw4QkFBOEIsb0RBQXVCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUF3Qjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfYmVsbG1hbi5qcz8wNjcxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMmV4cG9ydE1QQ1BhcmFtcyh6a2V5TmFtZSwgbXBjcGFyYW1zTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHNlY3Rpb25zWktleX0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRaS2V5LCBzZWN0aW9uc1pLZXkpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkWktleSwgY3VydmUsIHNlY3Rpb25zWktleSk7XG5cbiAgICBjb25zdCBmZE1QQ1BhcmFtcyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKG1wY3BhcmFtc05hbWUpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gVmVyaWZpY2F0aW9uIEtleSBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2FscGhhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19iZXRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoemtleS52a19iZXRhXzIpO1xuICAgIGF3YWl0IHdyaXRlRzIoemtleS52a19nYW1tYV8yKTtcbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfZGVsdGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMih6a2V5LnZrX2RlbHRhXzIpO1xuXG4gICAgLy8gSUNcbiAgICBsZXQgYnVmZkJhc2VzSUM7XG4gICAgYnVmZkJhc2VzSUMgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDMpO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSUMpO1xuXG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzSUMpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gaCBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgY29uc3QgYnVmZkJhc2VzSF9Mb2RkID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA5KTtcblxuICAgIGxldCBidWZmQmFzZXNIX1RhdTtcbiAgICBidWZmQmFzZXNIX1RhdSA9IGF3YWl0IGN1cnZlLkcxLmZmdChidWZmQmFzZXNIX0xvZGQsIFwiYWZmaW5lXCIsIFwiamFjb2JpYW5cIiwgbG9nZ2VyKTtcbiAgICBidWZmQmFzZXNIX1RhdSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoQXBwbHlLZXkoYnVmZkJhc2VzSF9UYXUsIGN1cnZlLkZyLm5lZyhjdXJ2ZS5Gci5lKDIpKSwgY3VydmUuRnIud1t6a2V5LnBvd2VyKzFdLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBSZW1vdmUgbGFzdCBlbGVtZW50LiAgKFRoZSBkZWdyZWUgb2YgSCB3aWxsIGJlIGFsbHdheXMgbS0yKVxuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYnVmZkJhc2VzSF9UYXUuc2xpY2UoMCwgYnVmZkJhc2VzSF9UYXUuYnl0ZUxlbmd0aCAtIHNHMSk7XG4gICAgYnVmZkJhc2VzSF9UYXUgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNIX1RhdSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzSF9UYXUpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTCBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0M7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0MpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0MpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQSBTZWN0aW9uIChDIHNlY3Rpb24pXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0E7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0EpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0EpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNCMTtcbiAgICBidWZmQmFzZXNCMSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNik7XG4gICAgYnVmZkJhc2VzQjEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNCMSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzQjEpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNCMjtcbiAgICBidWZmQmFzZXNCMiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNyk7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBjdXJ2ZS5HMi5iYXRjaExFTXRvVShidWZmQmFzZXNCMik7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzJcIiwgYnVmZkJhc2VzQjIpO1xuXG4gICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgd3JpdGVVMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YUFmdGVyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3MpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfc3gpO1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQb2ludEFycmF5KGdyb3VwTmFtZSwgYnVmZikge1xuICAgICAgICBsZXQgc0c7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBzRyA9IHNHMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNHID0gc0cyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgYnVmZi5ieXRlTGVuZ3RoIC8gc0csIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuXG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmZTaXplKTtcbiAgICB9XG5cblxuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_export_bellman.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_export_json.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_export_json.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportJson)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n\n\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readZKey)(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils.stringifyBigInts(zKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDbEI7O0FBRXRCOztBQUVmLHVCQUF1Qix3REFBUTtBQUMvQjtBQUNBOztBQUVBLFdBQVcsK0NBQUs7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2V4cG9ydF9qc29uLmpzPzI0OGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZFpLZXkgYXMgcmVhZFpLZXkgfSBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyB1dGlscyB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gemtleUV4cG9ydEpzb24oemtleUZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB6S2V5ID0gYXdhaXQgcmVhZFpLZXkoemtleUZpbGVOYW1lLCB0cnVlKTtcbiAgICBkZWxldGUgektleS5jdXJ2ZTtcbiAgICBkZWxldGUgektleS5GO1xuXG4gICAgcmV0dXJuIHV0aWxzLnN0cmluZ2lmeUJpZ0ludHMoektleSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_export_json.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_export_solidityverifier.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_export_solidityverifier.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(rsc)/../backend/node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n\n\n\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await (0,_zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return (0,_fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, verificationKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfc29saWRpdHl2ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNCOztBQUUrQztBQUNjO0FBQ25GO0FBQ0E7O0FBRWU7O0FBRWYsa0NBQWtDLDJFQUFxQjs7QUFFdkQ7QUFDQSxlQUFlLCtFQUErQjtBQUM5Qzs7QUFFQTs7QUFFQSxXQUFXLHVDQUFVO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfc29saWRpdHl2ZXJpZmllci5qcz83OTdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlanMgZnJvbSBcImVqc1wiO1xuXG5pbXBvcnQgZXhwb3J0VmVyaWZpY2F0aW9uS2V5IGZyb20gXCIuL3prZXlfZXhwb3J0X3ZlcmlmaWNhdGlvbmtleS5qc1wiO1xuaW1wb3J0IGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXJDbWQgZnJvbSBcIi4vZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qc1wiO1xuLy8gTm90IHJlYWR5IHlldFxuLy8gbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGVWZXJpZmllcl9raW1sZWVvaCA9IGdlbmVyYXRlVmVyaWZpZXJfa2ltbGVlb2g7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNvbGlkaXR5VmVyaWZpZXIoektleU5hbWUsIHRlbXBsYXRlcywgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB2ZXJpZmljYXRpb25LZXkgPSBhd2FpdCBleHBvcnRWZXJpZmljYXRpb25LZXkoektleU5hbWUsIGxvZ2dlcik7XG5cbiAgICBpZiAoXCJmZmxvbmtcIiA9PT0gdmVyaWZpY2F0aW9uS2V5LnByb3RvY29sKSB7XG4gICAgICAgIHJldHVybiBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyQ21kKHZlcmlmaWNhdGlvbktleSwgdGVtcGxhdGVzLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ZXJpZmljYXRpb25LZXkucHJvdG9jb2xdO1xuXG4gICAgcmV0dXJuIGVqcy5yZW5kZXIodGVtcGxhdGUsIHZlcmlmaWNhdGlvbktleSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_export_solidityverifier.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_export_verificationkey.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_export_verificationkey.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportVerificationKey)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDUztBQUNuQjtBQUNvQjs7QUFFdkQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZjs7QUFFQSxXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsdUJBQXVCLHNEQUFvQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxnREFBZ0Qsa0VBQWtCO0FBQ3hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0IseURBQVE7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3Qix5REFBUTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlEQUFROztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3ZlcmlmaWNhdGlvbmtleS5qcz9kN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7Z2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZX0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQge0ZGTE9OS19QUk9UT0NPTF9JRH0gZnJvbSBcIi4vemtleV9jb25zdGFudHMuanNcIjtcblxuY29uc3Qge3N0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHprZXlFeHBvcnRWZXJpZmljYXRpb25LZXkoemtleU5hbWUsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRVhQT1JUIFZFUklGSUNBVElPTiBLRVkgU1RBUlRFRFwiKTtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkLCBzZWN0aW9ucyk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gRGV0ZWN0ZWQgcHJvdG9jb2w6IFwiICsgemtleS5wcm90b2NvbCk7XG5cbiAgICBsZXQgcmVzO1xuICAgIGlmICh6a2V5LnByb3RvY29sID09PSBcImdyb3RoMTZcIikge1xuICAgICAgICByZXMgPSBhd2FpdCBncm90aDE2VmsoemtleSwgZmQsIHNlY3Rpb25zKTtcbiAgICB9IGVsc2UgaWYgKHprZXkucHJvdG9jb2wgPT09IFwicGxvbmtcIikge1xuICAgICAgICByZXMgPSBhd2FpdCBwbG9ua1ZrKHprZXkpO1xuICAgIH0gZWxzZSBpZiAoemtleS5wcm90b2NvbElkICYmIHprZXkucHJvdG9jb2xJZCA9PT0gRkZMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGV4cG9ydEZGbG9ua1ZrKHprZXksIGxvZ2dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIHByb3RvY29sIHVucmVjb2duaXplZFwiKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJFWFBPUlQgVkVSSUZJQ0FUSU9OIEtFWSBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlZrKHprZXksIGZkLCBzZWN0aW9ucykge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44ICogMjtcblxuICAgIGNvbnN0IGFscGhhQmV0YSA9IGF3YWl0IGN1cnZlLnBhaXJpbmcoemtleS52a19hbHBoYV8xLCB6a2V5LnZrX2JldGFfMik7XG5cbiAgICBsZXQgdktleSA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHprZXkucHJvdG9jb2wsXG4gICAgICAgIGN1cnZlOiBjdXJ2ZS5uYW1lLFxuICAgICAgICBuUHVibGljOiB6a2V5Lm5QdWJsaWMsXG5cbiAgICAgICAgdmtfYWxwaGFfMTogY3VydmUuRzEudG9PYmplY3QoemtleS52a19hbHBoYV8xKSxcblxuICAgICAgICB2a19iZXRhXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfYmV0YV8yKSxcbiAgICAgICAgdmtfZ2FtbWFfMjogY3VydmUuRzIudG9PYmplY3QoemtleS52a19nYW1tYV8yKSxcbiAgICAgICAgdmtfZGVsdGFfMjogY3VydmUuRzIudG9PYmplY3QoemtleS52a19kZWx0YV8yKSxcblxuICAgICAgICB2a19hbHBoYWJldGFfMTI6IGN1cnZlLkd0LnRvT2JqZWN0KGFscGhhQmV0YSlcbiAgICB9O1xuXG4gICAgLy8gUmVhZCBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHZLZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRzEpO1xuICAgICAgICBjb25zdCBQID0gY3VydmUuRzEudG9PYmplY3QoYnVmZik7XG4gICAgICAgIHZLZXkuSUMucHVzaChQKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHZLZXkgPSBzdHJpbmdpZnlCaWdJbnRzKHZLZXkpO1xuXG4gICAgcmV0dXJuIHZLZXk7XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcGxvbmtWayh6a2V5KSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICBRbTogY3VydmUuRzEudG9PYmplY3QoemtleS5RbSksXG4gICAgICAgIFFsOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFsKSxcbiAgICAgICAgUXI6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUXIpLFxuICAgICAgICBRbzogY3VydmUuRzEudG9PYmplY3QoemtleS5RbyksXG4gICAgICAgIFFjOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFjKSxcbiAgICAgICAgUzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzEpLFxuICAgICAgICBTMjogY3VydmUuRzEudG9PYmplY3QoemtleS5TMiksXG4gICAgICAgIFMzOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMzKSxcblxuICAgICAgICBYXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkuWF8yKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKVxuICAgIH07XG5cbiAgICB2S2V5ID0gc3RyaW5naWZ5QmlnSW50cyh2S2V5KTtcblxuICAgIHJldHVybiB2S2V5O1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHBvcnRGRmxvbmtWayh6a2V5LCBsb2dnZXIpIHtcbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBsZXQgdktleSA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHprZXkucHJvdG9jb2wsXG4gICAgICAgIGN1cnZlOiBjdXJ2ZS5uYW1lLFxuICAgICAgICBuUHVibGljOiB6a2V5Lm5QdWJsaWMsXG4gICAgICAgIHBvd2VyOiB6a2V5LnBvd2VyLFxuXG4gICAgICAgIGsxOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsxKSxcbiAgICAgICAgazI6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazIpLFxuXG4gICAgICAgIHc6IGN1cnZlLkZyLnRvT2JqZWN0KGN1cnZlLkZyLndbemtleS5wb3dlcl0pLFxuICAgICAgICAvL3dXOiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXIgKyAxXSksXG4gICAgICAgIHczOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LnczKSxcbiAgICAgICAgdzQ6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzQpLFxuICAgICAgICB3ODogY3VydmUuRnIudG9PYmplY3QoemtleS53OCksXG4gICAgICAgIHdyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LndyKSxcblxuICAgICAgICBYXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkuWF8yKSxcblxuICAgICAgICBDMDogY3VydmUuRzEudG9PYmplY3QoemtleS5DMCksXG4gICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlCaWdJbnRzKHZLZXkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_export_verificationkey.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_import_bellman.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_import_bellman.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2importMPCParams)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/../backend/node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nConttributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nConttributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previos contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new controbutions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // C Secion (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNPO0FBQ2Y7QUFDbUI7QUFDdEI7O0FBRW5COztBQUVmLFdBQVcsMENBQTBDLFFBQVEsNERBQXdCO0FBQ3JGLDZCQUE2QixzREFBb0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTtBQUNoQztBQUNBOztBQUVBLCtCQUErQix5REFBdUI7QUFDdEQ7O0FBRUEsOEJBQThCLGtEQUFxQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0EsNkRBQTZELEdBQUc7QUFDaEU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0RBQXNELHFDQUFxQztBQUMzRjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDhEQUEwQjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSx1REFBcUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQXdCOztBQUVsQyxVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBZ0I7QUFDN0I7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2ltcG9ydF9iZWxsbWFuLmpzPzE5MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGhhc2UyaW1wb3J0TVBDUGFyYW1zKHprZXlOYW1lT2xkLCBtcGNwYXJhbXNOYW1lLCB6a2V5TmFtZU5ldywgbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleU9sZCwgc2VjdGlvbnM6IHNlY3Rpb25zWktleU9sZH0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SGVhZGVyID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZhbHNlKTtcbiAgICBpZiAoemtleUhlYWRlci5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5SGVhZGVyLnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBvbGRNUENQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZFpLZXlPbGQsIGN1cnZlLCBzZWN0aW9uc1pLZXlPbGQpO1xuICAgIGNvbnN0IG5ld01QQ1BhcmFtcyA9IHt9O1xuXG4gICAgY29uc3QgZmRNUENQYXJhbXMgPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3RpbmcobXBjcGFyYW1zTmFtZSk7XG5cbiAgICBmZE1QQ1BhcmFtcy5wb3MgPVxuICAgICAgICBzRzEqMyArIHNHMiozICsgICAgICAgICAgICAgICAgICAgICAvLyB2S2V5XG4gICAgICAgIDggKyBzRzEqemtleUhlYWRlci5uVmFycyArICAgICAgICAgICAgICAvLyBJQyArIENcbiAgICAgICAgNCArIHNHMSooemtleUhlYWRlci5kb21haW5TaXplLTEpICsgICAgIC8vIEhcbiAgICAgICAgNCArIHNHMSp6a2V5SGVhZGVyLm5WYXJzICsgICAgICAgICAgICAgIC8vIEFcbiAgICAgICAgNCArIHNHMSp6a2V5SGVhZGVyLm5WYXJzICsgICAgICAgICAgICAgIC8vIEIxXG4gICAgICAgIDQgKyBzRzIqemtleUhlYWRlci5uVmFyczsgICAgICAgICAgICAgICAvLyBCMlxuXG4gICAgLy8gY3NIYXNoXG4gICAgbmV3TVBDUGFyYW1zLmNzSGFzaCA9ICBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKDY0KTtcblxuICAgIGNvbnN0IG5Db250dHJpYnV0aW9ucyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250dHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSB7IGRlbHRhOnt9IH07XG4gICAgICAgIGMuZGVsdGFBZnRlciA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgICAgICBjLmRlbHRhLmcyX3NweCA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuICAgICAgICBpZiAoaTxvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGMudHlwZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLnR5cGU7XG4gICAgICAgICAgICBpZiAoYy50eXBlPT0xKSB7XG4gICAgICAgICAgICAgICAgYy5iZWFjb25IYXNoID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0uYmVhY29uSGFzaDtcbiAgICAgICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5udW1JdGVyYXRpb25zRXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjLm5hbWUgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG5ld01QQ1BhcmFtcy5jc0hhc2gsIG9sZE1QQ1BhcmFtcy5jc0hhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIG9yaWdpbmFsIGNpcmN1aXQgZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgTVBDIG9uZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGggPiBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhlIGltcG9lcnRlZCBmaWxlIGRvZXMgbm90IGluY2x1ZGUgbmV3IGNvbnRyaWJ1dGlvbnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8b2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjb250cmlidXRpb25Jc0VxdWFsKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLCBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgUHJldmlvcyBjb250cmlidXRpb24gJHtpfSBkb2VzIG5vdCBtYXRjaGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBTZXQgdGhlIHNhbWUgbmFtZSB0byBhbGwgbmV3IGNvbnRyb2J1dGlvbnNcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpPW9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaTxuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmZFpLZXlOZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcbiAgICBmZE1QQ1BhcmFtcy5wb3MgPSAwO1xuXG4gICAgLy8gSGVhZGVyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBhbHBoYTEgKGtlZXAgb3JpZ2luYWwpXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBiZXRhMVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzI7ICAvLyBpZ25vcmUgYmV0YTJcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGdhbW1hMlxuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgemtleUhlYWRlci52a19kZWx0YV8yID0gYXdhaXQgcmVhZEcyKGZkTVBDUGFyYW1zKTtcbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVIZWFkZXIoZmRaS2V5TmV3LCB6a2V5SGVhZGVyKTtcblxuICAgIC8vIElDIChLZWVwIG9yaWdpbmFsKVxuICAgIGNvbnN0IG5JQyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSUMgIT0gemtleUhlYWRlci5uUHVibGljICsxKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBJQ1wiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5QdWJsaWMrMSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA0KTtcblxuICAgIC8vIEggU2VjdGlvblxuICAgIGNvbnN0IG5IID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5IICE9IHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBIXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBidWZmSDtcbiAgICBjb25zdCBidWZmVGF1VSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkpO1xuICAgIGNvbnN0IGJ1ZmZUYXVMRU0gPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaFV0b0xFTShidWZmVGF1VSk7XG4gICAgYnVmZkggPSBuZXcgVWludDhBcnJheSh6a2V5SGVhZGVyLmRvbWFpblNpemUqc0cxKTtcbiAgICBidWZmSC5zZXQoYnVmZlRhdUxFTSk7ICAgLy8gTGV0IHRoZSBsYXN0IG9uZSB0byB6ZXJvLlxuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmZILCBzRzEqKHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSwgY3VydmUuRzEuemVyb0FmZmluZSk7XG4gICAgY29uc3QgbjJJbnYgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICBjb25zdCB3SW52ID0gY3VydmUuRnIuaW52KGN1cnZlLkZyLndbemtleUhlYWRlci5wb3dlcisxXSk7XG4gICAgYnVmZkggPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaEFwcGx5S2V5KGJ1ZmZILCBuMkludiwgd0ludiwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuaWZmdChidWZmSCwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDkpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmSCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXlOZXcpO1xuXG4gICAgLy8gQyBTZWNpb24gKEwgc2VjdGlvbilcbiAgICBjb25zdCBuTCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuTCAhPSAoemtleUhlYWRlci5uVmFycy16a2V5SGVhZGVyLm5QdWJsaWMtMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZMO1xuICAgIGJ1ZmZMID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZChzRzEqKHprZXlIZWFkZXIublZhcnMtemtleUhlYWRlci5uUHVibGljLTEpKTtcbiAgICBidWZmTCA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoVXRvTEVNKGJ1ZmZMKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3LCA4KTtcbiAgICBhd2FpdCBmZFpLZXlOZXcud3JpdGUoYnVmZkwpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGNvbnN0IG5BID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5BICE9IHprZXlIZWFkZXIublZhcnMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIEFcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uVmFycyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDUpO1xuXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIGNvbnN0IG5CMSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuQjEgIT0gemtleUhlYWRlci5uVmFycykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gQjFcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uVmFycyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGNvbnN0IG5CMiA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuQjIgIT0gemtleUhlYWRlci5uVmFycykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gQjJcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMiooemtleUhlYWRlci5uVmFycyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDcpO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlTVBDUGFyYW1zKGZkWktleU5ldywgY3VydmUsIG5ld01QQ1BhcmFtcyk7XG5cbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkWktleU5ldy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkWktleU9sZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoZmQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKGZkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMi5mcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29udHJpYnV0aW9uSXNFcXVhbChjMSwgYzIpIHtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YUFmdGVyICAgLCBjMi5kZWx0YUFmdGVyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhLmcxX3MgICAsIGMyLmRlbHRhLmcxX3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGEuZzFfc3ggICwgYzIuZGVsdGEuZzFfc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoYzEuZGVsdGEuZzJfc3B4ICwgYzIuZGVsdGEuZzJfc3B4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwoYzEudHJhbnNjcmlwdCwgYzIudHJhbnNjcmlwdCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_import_bellman.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_new.js":
/*!*******************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_new.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newZKey)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/../backend/node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/../backend/node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__.ready();\n    const csHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__(64);\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csHeader)(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const A = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const B1 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const B2 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const C = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info((0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash)(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 9);\n        const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`spliting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 4);\n\n        const buffSection = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9uZXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV3QztBQUNRO0FBUW5CO0FBQ2dCO0FBQ0k7QUFDZDtBQUNFOzs7QUFHdEI7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUFhO0FBQ3ZCLHFCQUFxQix5Q0FBTzs7QUFFNUIsV0FBVyxvQ0FBb0MsUUFBUSxnRUFBVztBQUNsRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7QUFDckQsV0FBVyxvQ0FBb0MsUUFBUSxnRUFBVztBQUNsRSx1QkFBdUIsd0RBQWM7O0FBRXJDLHlCQUF5QixrRUFBYTs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsOENBQUk7O0FBRXpCO0FBQ0Esb0ZBQW9GLGtCQUFrQixVQUFVLE1BQU07QUFDdEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHNFQUFpQjtBQUMzQixnQ0FBZ0M7QUFDaEMsVUFBVSxvRUFBZTs7QUFFekI7QUFDQTs7QUFFQSxVQUFVLHNFQUFpQjtBQUMzQjtBQUNBLDhCQUE4QixnREFBTTs7QUFFcEM7QUFDQSw4QkFBOEIsZ0RBQU07QUFDcEMsZUFBZSxnREFBTSxLQUFLLGdEQUFNO0FBQ2hDLDJCQUEyQixnREFBTSxLQUFLLGdEQUFNOztBQUU1QztBQUNBLFVBQVUsZ0VBQVc7QUFDckI7QUFDQSxVQUFVLGdFQUFXO0FBQ3JCLGlFQUFpRTtBQUNqRSw0REFBNEQ7QUFDNUQsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLFVBQVUsb0VBQWU7O0FBRXpCO0FBQ0Esc0JBQXNCLGdFQUFXOztBQUVqQyxrQkFBa0Isb0RBQVE7QUFDMUIsbUJBQW1CLG9EQUFRO0FBQzNCLG1CQUFtQixvREFBUTtBQUMzQixrQkFBa0Isb0RBQVE7QUFDMUI7O0FBRUE7QUFDQSx1QkFBdUIsZ0VBQVc7QUFDbEM7QUFDQSx1QkFBdUIsZ0VBQVc7QUFDbEM7QUFDQSw0QkFBNEIsZ0VBQVc7QUFDdkM7QUFDQSwyQkFBMkIsZ0VBQVc7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHNFQUFpQjtBQUMzQjtBQUNBO0FBQ0EsVUFBVSxvRUFBZTs7QUFFekIsNEJBQTRCLG9EQUFVOzs7QUFHdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0IsNEJBQTRCLG1EQUFTO0FBQ3JDO0FBQ0EsK0JBQStCLGdFQUFXO0FBQzFDLDBCQUEwQixlQUFlO0FBQ3pDLCtFQUErRSxFQUFFLEdBQUcsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG9EQUFRO0FBQ2xDLHNCQUFzQixxQkFBcUI7QUFDM0Msa0ZBQWtGLEVBQUUsR0FBRyxrQkFBa0I7QUFDekc7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGNBQWMsc0VBQWlCOztBQUUvQixnQ0FBZ0MsbURBQVM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLDJFQUEyRSxFQUFFLEdBQUcsYUFBYTtBQUM3RjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvRUFBZTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7O0FBRS9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRSxZQUFZLElBQUksRUFBRSxHQUFHLFdBQVc7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFlBQVksSUFBSSxHQUFHLEdBQUcsV0FBVztBQUNyRztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvRUFBZTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EseUJBQXlCLG1EQUFTO0FBQ2xDLDJCQUEyQixtREFBUztBQUNwQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQywwRkFBMEYsWUFBWSxJQUFJLEVBQUUsR0FBRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RCx1QkFBdUIsd0NBQXdDO0FBQy9ELHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLGlCQUFpQjtBQUMxQyx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQiwrQkFBK0I7QUFDL0IseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixpQkFBaUI7QUFDMUMseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsT0FBTztBQUN4QixjQUFjO0FBQ2QsdUJBQXVCLGtEQUFrRDs7QUFFekU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEMseURBQXlELEVBQUUsR0FBRyxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQix5Q0FBeUM7QUFDNUQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCLFVBQVU7QUFDVixtQkFBbUIsNkNBQTZDOztBQUVoRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfbmV3LmpzP2Q4OWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtyZWFkUjFjc0hlYWRlcn0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICByZWFkQmluRmlsZSxcbiAgICBjcmVhdGVCaW5GaWxlLFxuICAgIHJlYWRTZWN0aW9uLFxuICAgIHdyaXRlQmlnSW50LFxuICAgIHN0YXJ0V3JpdGVTZWN0aW9uLFxuICAgIGVuZFdyaXRlU2VjdGlvbixcbn0gZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGxvZzIsIGZvcm1hdEhhc2ggfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCBCaWdBcnJheSBmcm9tIFwiLi9iaWdhcnJheS5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIG5ld1pLZXkocjFjc05hbWUsIHB0YXVOYW1lLCB6a2V5TmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBUQVVfRzEgPSAwO1xuICAgIGNvbnN0IFRBVV9HMiA9IDE7XG4gICAgY29uc3QgQUxQSEFUQVVfRzEgPSAyO1xuICAgIGNvbnN0IEJFVEFUQVVfRzEgPSAzO1xuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcbiAgICBjb25zdCBjc0hhc2hlciA9IEJsYWtlMmIoNjQpO1xuXG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdU5hbWUsIFwicHRhdVwiLCAxLCAxPDwyMiwgMTw8MjQpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBzZWN0aW9uc1BUYXUpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHIxY3NOYW1lLCBcInIxY3NcIiwgMSwgMTw8MjIsIDE8PDI0KTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NIZWFkZXIoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIGZhbHNlKTtcblxuICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAxLCAxMCwgMTw8MjIsIDE8PDI0KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBpZiAocjFjcy5wcmltZSAhPSBjdXJ2ZS5yKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IGNpclBvd2VyID0gbG9nMihyMWNzLm5Db25zdHJhaW50cyArIHIxY3MublB1YklucHV0cyArIHIxY3Mubk91dHB1dHMgKzEgLTEpICsxO1xuXG4gICAgaWYgKGNpclBvd2VyID4gcG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBjaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgcG93ZXIgb2YgdGF1IGNlcmVtb255LiAke3IxY3MubkNvbnN0cmFpbnRzfSoyID4gMioqJHtwb3dlcn1gKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghc2VjdGlvbnNQVGF1WzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlcnMgb2YgdGF1IGlzIG5vdCBwcmVwYXJlZC5cIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCBuUHVibGljID0gcjFjcy5uT3V0cHV0cyArIHIxY3MublB1YklucHV0cztcbiAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBjaXJQb3dlcjtcblxuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMSk7IC8vIEdyb3RoXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAvLyBXcml0ZSB0aGUgR3JvdGggaGVhZGVyIHNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAyKTtcbiAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgY29uc3QgUnIgPSBTY2FsYXIubW9kKFNjYWxhci5zaGwoMSwgbjhyKjgpLCBwcmltZVIpO1xuICAgIGNvbnN0IFIyciA9IGN1cnZlLkZyLmUoU2NhbGFyLm1vZChTY2FsYXIubXVsKFJyLFJyKSwgcHJpbWVSKSk7XG5cbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHEpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVIsIG44cik7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocjFjcy5uVmFycyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBiYXJzXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoblB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKGRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcblxuICAgIGxldCBiQWxwaGExO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBmZFBUYXUucmVhZChzRzEsIHNlY3Rpb25zUFRhdVs0XVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYkFscGhhMSk7XG4gICAgYkFscGhhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJBbHBoYTEpO1xuICAgIGNzSGFzaGVyLnVwZGF0ZShiQWxwaGExKTtcblxuICAgIGxldCBiQmV0YTE7XG4gICAgYkJldGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNV1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJCZXRhMSk7XG4gICAgYkJldGExID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYkJldGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkJldGExKTtcblxuICAgIGxldCBiQmV0YTI7XG4gICAgYkJldGEyID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cyLCBzZWN0aW9uc1BUYXVbNl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJCZXRhMik7XG4gICAgYkJldGEyID0gYXdhaXQgY3VydmUuRzIuYmF0Y2hMRU10b1UoYkJldGEyKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkJldGEyKTtcblxuICAgIGNvbnN0IGJnMSA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgY3VydmUuRzEudG9ScHJMRU0oYmcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjb25zdCBiZzIgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByTEVNKGJnMiwgMCwgY3VydmUuRzIuZyk7XG4gICAgY29uc3QgYmcxVSA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYmcxVSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyVSA9IG5ldyBVaW50OEFycmF5KHNHMik7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYmcyVSwgMCwgY3VydmUuRzIuZyk7XG5cbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcyKTsgICAgICAgIC8vIGdhbW1hMlxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzEpOyAgICAgICAgLy8gZGVsdGExXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBkZWx0YTJcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZ2FtbWEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMVUpOyAgICAgIC8vIGRlbHRhMVxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzJVKTsgICAgICAvLyBkZWx0YTJcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyByMWNzXCIpO1xuICAgIGxldCBzUjFjcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcblxuICAgIGNvbnN0IEEgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQjEgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQjIgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQyA9IG5ldyBCaWdBcnJheShyMWNzLm5WYXJzLSBuUHVibGljIC0xKTtcbiAgICBjb25zdCBJQyA9IG5ldyBBcnJheShuUHVibGljKzEpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcxXCIpO1xuICAgIGxldCBzVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTIsIChkb21haW5TaXplIC0xKSpzRzEsIGRvbWFpblNpemUqc0cxKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgdGF1RzJcIik7XG4gICAgbGV0IHNUYXVHMiA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxMywgKGRvbWFpblNpemUgLTEpKnNHMiwgZG9tYWluU2l6ZSpzRzIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyBhbHBoYXRhdUcxXCIpO1xuICAgIGxldCBzQWxwaGFUYXVHMSA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxNCwgKGRvbWFpblNpemUgLTEpKnNHMSwgZG9tYWluU2l6ZSpzRzEpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyBiZXRhdGF1RzFcIik7XG4gICAgbGV0IHNCZXRhVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTUsIChkb21haW5TaXplIC0xKSpzRzEsIGRvbWFpblNpemUqc0cxKTtcblxuICAgIGF3YWl0IHByb2Nlc3NDb25zdHJhaW50cygpO1xuXG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDMsIFwiRzFcIiwgSUMsIFwiSUNcIik7XG5cbiAgICBhd2FpdCB3cml0ZUhzKCk7XG5cbiAgICBhd2FpdCBoYXNoSFBvaW50cygpO1xuXG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDgsIFwiRzFcIiwgQywgXCJDXCIpO1xuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg1LCBcIkcxXCIsIEEsIFwiQVwiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNiwgXCJHMVwiLCBCMSwgXCJCMVwiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNywgXCJHMlwiLCBCMiwgXCJCMlwiKTtcblxuICAgIGNvbnN0IGNzSGFzaCA9IGNzSGFzaGVyLmRpZ2VzdCgpO1xuICAgIC8vIENvbnRyaWJ1dGlvbnMgc2VjdGlvblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMTApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShjc0hhc2gpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDApO1xuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjc0hhc2gsIFwiQ2lyY3VpdCBoYXNoOiBcIikpO1xuXG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIHJldHVybiBjc0hhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUhzKCkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDkpO1xuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKnNHMSk7XG4gICAgICAgIGlmIChjaXJQb3dlciA8IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgIGxldCBzVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTIsIChkb21haW5TaXplKjItMSkqc0cxLCBkb21haW5TaXplKjIqc0cxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGBzcGxpdGluZyBidWZmZXI6ICR7aX0vJHtkb21haW5TaXplfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBzVGF1RzEuc2xpY2UoIChpKjIrMSkqc0cxLCAoaSoyKzEpKnNHMSArIHNHMSApO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGJ1ZmYsIGkqc0cxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaXJQb3dlciA9PSBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gc2VjdGlvbnNQVGF1WzEyXVswXS5wICsgKCgyICoqIChjaXJQb3dlcisxKSkgLTEpKnNHMTtcbiAgICAgICAgICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoYnVmZk91dCwgMCwgZG9tYWluU2l6ZSpzRzEsIG8gKyBkb21haW5TaXplKnNHMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJDaXJjdWl0IHRvbyBiaWdcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgY3VydmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ29uc3RyYWludHMoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZiA9IG5ldyBVaW50OEFycmF5KDEyICsgY3VydmUuRnIubjgpO1xuICAgICAgICBjb25zdCBidWZmQ29lZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmZDb2VmZi5idWZmZXIpO1xuICAgICAgICBjb25zdCBiT25lID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjgpO1xuICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJPbmUsIDAsIGN1cnZlLkZyLmUoMSkpO1xuXG4gICAgICAgIGxldCByMWNzUG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiByMWNzX3JlYWRVTEUzMigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBzUjFjcy5zbGljZShyMWNzUG9zLCByMWNzUG9zKzQpO1xuICAgICAgICAgICAgcjFjc1BvcyArPSA0O1xuICAgICAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZWZzID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGM9MDsgYzxyMWNzLm5Db25zdHJhaW50czsgYysrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihjJTEwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHByb2Nlc3NpbmcgY29uc3RyYWludHM6ICR7Y30vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG5BID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwyID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBW3NdID09PSBcInVuZGVmaW5lZFwiKSBBW3NdID0gW107XG4gICAgICAgICAgICAgICAgQVtzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MgLSBuUHVibGljIC0xXS5wdXNoKFtsMnQsIGwyLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFswLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQiA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgY29uc3QgbDJ0ID0gVEFVX0cyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwyID0gc0cyKmM7XG4gICAgICAgICAgICAgICAgY29uc3QgbDN0ID0gQUxQSEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDMgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIxW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMVtzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIxW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCMltzXSA9PT0gXCJ1bmRlZmluZWRcIikgQjJbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBCMltzXS5wdXNoKFtsMnQsIGwyLCBjb2VmcF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsM3QsIGwzLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29lZnMucHVzaChbMSwgYywgcywgY29lZnBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbkMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmIChzIDw9IG5QdWJsaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBJQ1tzXSA9PT0gXCJ1bmRlZmluZWRcIikgSUNbc10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgSUNbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIENbcy0gblB1YmxpYyAtMV0gPT09IFwidW5kZWZpbmVkXCIpIENbcy0gblB1YmxpYyAtMV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgQ1tzLSBuUHVibGljIC0xXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDw9IG5QdWJsaWMgOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKihyMWNzLm5Db25zdHJhaW50cyArIHMpO1xuICAgICAgICAgICAgY29uc3QgbDJ0ID0gQkVUQVRBVV9HMTtcbiAgICAgICAgICAgIGNvbnN0IGwyID0gc0cxKihyMWNzLm5Db25zdHJhaW50cyArIHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBBW3NdID09PSBcInVuZGVmaW5lZFwiKSBBW3NdID0gW107XG4gICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIC0xXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgSUNbc10ucHVzaChbbDJ0LCBsMiwgLTFdKTtcbiAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIHIxY3MubkNvbnN0cmFpbnRzICsgcywgcywgLTFdKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA0KTtcblxuICAgICAgICBjb25zdCBidWZmU2VjdGlvbiA9IG5ldyBCaWdCdWZmZXIoY29lZnMubGVuZ3RoKigxMitjdXJ2ZS5Gci5uOCkgKyA0KTtcblxuICAgICAgICBjb25zdCBidWZmNCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBidWZmNFYgPSBuZXcgRGF0YVZpZXcoYnVmZjQuYnVmZmVyKTtcbiAgICAgICAgYnVmZjRWLnNldFVpbnQzMigwLCBjb2Vmcy5sZW5ndGgsIHRydWUpO1xuICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZjQpO1xuICAgICAgICBsZXQgY29lZnNQb3MgPSA0O1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29lZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgY29lZmZzOiAke2l9LyR7Y29lZnMubGVuZ3RofWApO1xuICAgICAgICAgICAgd3JpdGVDb2VmKGNvZWZzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmU2VjdGlvbik7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlQ29lZihjKSB7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMigwLCBjWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDQsIGNbMV0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoOCwgY1syXSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChjWzNdPj0wKSB7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnZlLkZyLmZyb21ScHJMRShzUjFjcy5zbGljZShjWzNdLCBjWzNdICsgY3VydmUuRnIubjgpLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnZlLkZyLmZyb21ScHJMRShiT25lLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5SMiA9IGN1cnZlLkZyLm11bChuLCBSMnIpO1xuICAgICAgICAgICAgY3VydmUuRnIudG9ScHJMRShidWZmQ29lZmYsIDEyLCBuUjIpO1xuICAgICAgICAgICAgYnVmZlNlY3Rpb24uc2V0KGJ1ZmZDb2VmZiwgY29lZnNQb3MpO1xuICAgICAgICAgICAgY29lZnNQb3MgKz0gYnVmZkNvZWZmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcG9zZUFuZFdyaXRlUG9pbnRzKGlkU2VjdGlvbiwgZ3JvdXBOYW1lLCBhcnIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IENIVU5LX1NJWkU9IDE8PDE1O1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcblxuICAgICAgICBoYXNoVTMyKGFyci5sZW5ndGgpO1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIGlkU2VjdGlvbik7XG5cbiAgICAgICAgbGV0IG9wUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBsZXQgaT0wO1xuICAgICAgICB3aGlsZSAoaTxhcnIubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGxldCB0PTA7XG4gICAgICAgICAgICB3aGlsZSAoKGk8YXJyLmxlbmd0aCkmJih0PGN1cnZlLnRtLmNvbmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpICBsb2dnZXIuZGVidWcoYFdyaXRpbmcgcG9pbnRzIHN0YXJ0ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IDE7XG4gICAgICAgICAgICAgICAgbGV0IG5QID0gKGFycltpXSA/IGFycltpXS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGkgKyBuIDwgYXJyLmxlbmd0aCkgJiYgKG5QICsgKGFycltpK25dID8gYXJyW2krbl0ubGVuZ3RoIDogMCkgPCBDSFVOS19TSVpFKSAmJiAobjxDSFVOS19TSVpFKSkge1xuICAgICAgICAgICAgICAgICAgICBuUCArPSAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgbiArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQXJyID0gYXJyLnNsaWNlKGksIGkgKyBuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfaSA9IGk7XG4gICAgICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIHN1YkFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgZW5kICR7c2VjdGlvbk5hbWV9OiAke19pfS8ke2Fyci5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpICs9IG47XG4gICAgICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrPHJlc3VsdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShyZXN1bHRba11bMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHNUaHJlYWQoZ3JvdXBOYW1lLCBhcnIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHaW4gPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3Qgc0dtaWQgPSBHLkYubjgqMztcbiAgICAgICAgY29uc3Qgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgbGV0IGZuRXhwLCBmbk11bHRpRXhwLCBmbkJhdGNoVG9BZmZpbmUsIGZuWmVybztcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuRXhwID0gXCJnMW1fdGltZXNTY2FsYXJBZmZpbmVcIjtcbiAgICAgICAgICAgIGZuTXVsdGlFeHAgPSBcImcxbV9tdWx0aWV4cEFmZmluZVwiO1xuICAgICAgICAgICAgZm5CYXRjaFRvQWZmaW5lID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgZm5aZXJvID0gXCJnMW1femVyb1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGZuRXhwID0gXCJnMm1fdGltZXNTY2FsYXJBZmZpbmVcIjtcbiAgICAgICAgICAgIGZuTXVsdGlFeHAgPSBcImcybV9tdWx0aWV4cEFmZmluZVwiO1xuICAgICAgICAgICAgZm5CYXRjaFRvQWZmaW5lID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgZm5aZXJvID0gXCJnMm1femVyb1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWNjID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSBhY2MgKz0gYXJyW2ldID8gYXJyW2ldLmxlbmd0aCA6IDA7XG4gICAgICAgIGxldCBiQmFzZXMsIGJTY2FsYXJzO1xuICAgICAgICBpZiAoYWNjPiAyPDwxNCkge1xuICAgICAgICAgICAgYkJhc2VzID0gbmV3IEJpZ0J1ZmZlcihhY2Mqc0dpbik7XG4gICAgICAgICAgICBiU2NhbGFycyA9IG5ldyBCaWdCdWZmZXIoYWNjKmN1cnZlLkZyLm44KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJCYXNlcyA9IG5ldyBVaW50OEFycmF5KGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKmN1cnZlLkZyLm44KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcEIgPTA7XG4gICAgICAgIGxldCBwUyA9MDtcblxuICAgICAgICBjb25zdCBzQnVmZnMgPSBbXG4gICAgICAgICAgICBzVGF1RzEsXG4gICAgICAgICAgICBzVGF1RzIsXG4gICAgICAgICAgICBzQWxwaGFUYXVHMSxcbiAgICAgICAgICAgIHNCZXRhVGF1RzFcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBiT25lID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjgpO1xuICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJPbmUsIDAsIGN1cnZlLkZyLmUoMSkpO1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWFycltpXSkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8YXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaikmJihqJTEwMDAwID09IDApKSAgbG9nZ2VyLmRlYnVnKGBDb25maWd1cmluZyBiaWcgYXJyYXkgJHtzZWN0aW9uTmFtZX06ICR7an0vJHthcnJbaV0ubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGJCYXNlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHNCdWZmc1thcnJbaV1bal1bMF1dLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzFdICsgc0dpblxuICAgICAgICAgICAgICAgICAgICApLCBvZmZzZXQqc0dpblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXVtqXVsyXT49MCkge1xuICAgICAgICAgICAgICAgICAgICBiU2NhbGFycy5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzUjFjcy5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldW2pdWzJdICsgY3VydmUuRnIubjhcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQqY3VydmUuRnIubjhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiU2NhbGFycy5zZXQoYk9uZSwgb2Zmc2V0KmN1cnZlLkZyLm44KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyci5sZW5ndGg+MSkge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBiQmFzZXN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYlNjYWxhcnN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHbWlkfSk7XG4gICAgICAgICAgICBwQiA9IDA7XG4gICAgICAgICAgICBwUyA9IDA7XG4gICAgICAgICAgICBsZXQgcEQgPTA7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuWmVybywgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IHBEfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgIHBEICs9IHNHbWlkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5FeHAsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBwQn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IHBTfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IGN1cnZlLkZyLm44fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5NdWx0aUV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogYXJyW2ldLmxlbmd0aH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IHBEfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBCICs9IHNHaW4qYXJyW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwUyArPSBjdXJ2ZS5Gci5uOCphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBEICs9IHNHbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuQmF0Y2hUb0FmZmluZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAge3ZhbDogYXJyLmxlbmd0aH0sXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogYXJyLmxlbmd0aCpzR291dH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiQmFzZXMsIGJTY2FsYXJzLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJlcyA9IFsgRy50b0FmZmluZShyZXMpIF07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50cygpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRSA9IDE8PDE0O1xuXG4gICAgICAgIGhhc2hVMzIoZG9tYWluU2l6ZS0xKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ZG9tYWluU2l6ZS0xOyBpKz0gQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZ0hQb2ludHM6ICR7aX0vJHtkb21haW5TaXplfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKGRvbWFpblNpemUtMSwgQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBhd2FpdCBoYXNoSFBvaW50c0NodW5rKGksIG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaEhQb2ludHNDaHVuayhvZmZzZXQsIG5Qb2ludHMpIHtcbiAgICAgICAgY29uc3QgYnVmZjEgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgKG9mZnNldCArIGRvbWFpblNpemUpKnNHMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYyID0gYXdhaXQgZmRQVGF1LnJlYWQoblBvaW50cyAqc0cxLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIG9mZnNldCpzRzEpO1xuICAgICAgICBjb25zdCBjb25jdXJyZW5jeT0gY3VydmUudG0uY29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNQZXJUaHJlYWQgPSBNYXRoLmZsb29yKG5Qb2ludHMgLyBjb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IGNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKm5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYxID0gYnVmZjEuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjIgPSBidWZmMi5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goaGFzaEhQb2ludHNUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNzSGFzaGVyLnVwZGF0ZShyZXN1bHRbaV1bMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaEhQb2ludHNUaHJlYWQoYnVmZjEsIGJ1ZmYyKSB7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBidWZmMS5ieXRlTGVuZ3RoL3NHMTtcbiAgICAgICAgY29uc3Qgc0dtaWQgPSBjdXJ2ZS5HMS5GLm44KjM7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmMX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGJ1ZmYyfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHbWlkfSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkNBTExcIixcbiAgICAgICAgICAgICAgICBmbk5hbWU6IFwiZzFtX3N1YkFmZmluZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogaSpzR21pZH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZzFtX2JhdGNoVG9BZmZpbmVcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZzFtX2JhdGNoTEVNdG9VXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzaFUzMihuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYnVmZlYuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcbiAgICAgICAgY3NIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_new.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashG1: () => (/* binding */ hashG1),\n/* harmony export */   hashG2: () => (/* binding */ hashG2),\n/* harmony export */   hashPubKey: () => (/* binding */ hashPubKey),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   readMPCParams: () => (/* binding */ readMPCParams),\n/* harmony export */   readZKey: () => (/* binding */ readZKey),\n/* harmony export */   writeHeader: () => (/* binding */ writeHeader),\n/* harmony export */   writeMPCParams: () => (/* binding */ writeMPCParams),\n/* harmony export */   writeZKey: () => (/* binding */ writeZKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/../backend/node_modules/snarkjs/src/fflonk_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\n\n\n\n\n\n\n\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n}\n\nasync function writeZKey(fileName, zkey) {\n\n    let curve = (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be ommited))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod( ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(n, R2r), zkey.r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader(fd, sections, toObject) {\n    // Read Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstrains = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(zkey.r);\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parametes do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0s7O0FBRUk7QUFDdkI7QUFDOEQ7QUFDbEM7O0FBRXREOztBQUVQO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4Qyw0QkFBNEI7QUFDNUIsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFROztBQUVoQyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLDhCQUE4QixnREFBTTs7QUFFcEM7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsVUFBVSw0REFBd0I7QUFDbEM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnRUFBNEI7OztBQUd0Qzs7QUFFTzs7QUFFUCxnQkFBZ0IseURBQVE7O0FBRXhCLHFCQUFxQiw4REFBMEI7O0FBRS9DO0FBQ0EsOEJBQThCLGdEQUFNO0FBQ3BDLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQyxnQkFBZ0IsZ0RBQU0sS0FBSyxnREFBTTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0RBQU0sTUFBTSxnREFBTTs7QUFFOUIsY0FBYyw0REFBd0I7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsdUJBQXVCLG1FQUFtQjtBQUMxQztBQUNBLE1BQU0sd0JBQXdCLGlFQUFpQjtBQUMvQztBQUNBLE1BQU0sd0JBQXdCLGtFQUFrQjtBQUNoRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7O0FBRTFDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCO0FBQzFDLHVCQUF1Qix5REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCOztBQUUxQztBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1QjtBQUMxQyx1QkFBdUIseURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGtFQUFrQjs7QUFFeEMsVUFBVSx1RUFBbUMsZUFBZSx3RUFBc0I7QUFDbEY7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUMsdUJBQXVCLHlEQUFROztBQUUvQjtBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFTztBQUNQLFdBQVcsY0FBYyxRQUFRLDREQUF3Qjs7QUFFekQ7O0FBRUEsbUJBQW1CLGlEQUFPO0FBQzFCLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQztBQUNBOztBQUVBLHNCQUFzQix5REFBUTs7QUFFOUI7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7O0FBR3JDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QiwyREFBdUI7QUFDL0M7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1AsVUFBVSx1RUFBbUM7QUFDN0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGtFQUE4QjtBQUN4QztBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7QUFDdEM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV91dGlscy5qcz8yMWJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdFxuLy8gPT09PT09XG4vLyBIZWFkZXIoMSlcbi8vICAgICAgUHJvdmVyIFR5cGUgMSBHcm90aFxuLy8gSGVhZGVyR3JvdGgoMilcbi8vICAgICAgbjhxXG4vLyAgICAgIHFcbi8vICAgICAgbjhyXG4vLyAgICAgIHJcbi8vICAgICAgTlZhcnNcbi8vICAgICAgTlB1YlxuLy8gICAgICBEb21haW5TaXplICAobXVsdGlwbGUgb2YgMlxuLy8gICAgICBhbHBoYTFcbi8vICAgICAgYmV0YTFcbi8vICAgICAgZGVsdGExXG4vLyAgICAgIGJldGEyXG4vLyAgICAgIGdhbW1hMlxuLy8gICAgICBkZWx0YTJcbi8vIElDKDMpXG4vLyBDb2Vmcyg0KVxuLy8gUG9pbnRzQSg1KVxuLy8gUG9pbnRzQjEoNilcbi8vIFBvaW50c0IyKDcpXG4vLyBQb2ludHNDKDgpXG4vLyBQb2ludHNIKDkpXG4vLyBDb250cmlidXRpb25zKDEwKVxuXG5pbXBvcnQgeyBTY2FsYXIsIEYxRmllbGQgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcblxuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgbG9nMiB9IGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7RkZMT05LX1BST1RPQ09MX0lELCBHUk9USDE2X1BST1RPQ09MX0lELCBQTE9OS19QUk9UT0NPTF9JRH0gZnJvbSBcIi4vemtleV9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7WktFWV9GRl9IRUFERVJfU0VDVElPTn0gZnJvbSBcIi4vZmZsb25rX2NvbnN0YW50cy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFkZXIoZmQsIHprZXkpIHtcblxuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMigxKTsgLy8gR3JvdGhcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIHRoZSBHcm90aCBoZWFkZXIgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArMSkqODtcblxuICAgIGNvbnN0IHByaW1lUiA9IGN1cnZlLnI7XG4gICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUikgLSAxKSAvIDY0KSArMSkqODtcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjhxKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lUSwgbjhxKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG44cik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBwcmltZVIsIG44cik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5Lm5WYXJzKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIGJhcnNcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkublB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5kb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfYWxwaGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfYmV0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19iZXRhXzIpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2dhbW1hXzIpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2RlbHRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2RlbHRhXzIpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVaS2V5KGZpbGVOYW1lLCB6a2V5KSB7XG5cbiAgICBsZXQgY3VydmUgPSBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgY29uc3QgZmQgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShmaWxlTmFtZSxcInprZXlcIiwgMSwgOSk7XG5cbiAgICBhd2FpdCB3cml0ZUhlYWRlcihmZCwgemtleSk7XG4gICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHprZXkucikgLSAxKSAvIDY0KSArMSkqODtcbiAgICBjb25zdCBSciA9IFNjYWxhci5tb2QoU2NhbGFyLnNobCgxLCBuOHIqOCksIHprZXkucik7XG4gICAgY29uc3QgUjJyID0gU2NhbGFyLm1vZChTY2FsYXIubXVsKFJyLFJyKSwgemtleS5yKTtcblxuICAgIC8vIFdyaXRlIFBvbHMgKEEgYW5kIEIgKEMgY2FuIGJlIG9tbWl0ZWQpKVxuICAgIC8vLy8vLy8vLy8vXG5cbiAgICB6a2V5LmNjb2VmcyA9IHprZXkuY2NvZWZzLmZpbHRlcihjID0+IGMubWF0cml4PDIpO1xuICAgIHprZXkuY2NvZWZzLnNvcnQoIChhLGIpID0+IGEuY29uc3RyYWludCAtIGIuY29uc3RyYWludCApO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5LmNjb2Vmcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmNjb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2VmID0gemtleS5jY29lZnNbaV07XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29lZi5tYXRyaXgpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNvZWYuY29uc3RyYWludCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29lZi5zaWduYWwpO1xuICAgICAgICBhd2FpdCB3cml0ZUZyMihjb2VmLnZhbHVlKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFdyaXRlIElDIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMyk7XG4gICAgZm9yIChsZXQgaT0wOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuSUNbaV0gKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFdyaXRlIEFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNSk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5BW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBCMVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA2KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LkIxW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBCMlxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA3KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LkIyW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBDXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDgpO1xuICAgIGZvciAobGV0IGk9emtleS5uUHVibGljKzE7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LkNbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gV3JpdGUgSCBwb2ludHNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgOSk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LmhFeHBzW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVGcjIobikge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIG1vbnRnb21lcnlcbiAgICAgICAgbiA9IFNjYWxhci5tb2QoIFNjYWxhci5tdWwobiwgUjJyKSwgemtleS5yKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIG4sIG44cik7XG4gICAgfVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEoZmQsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJMRU0oYnVmZiwgMCwgcCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoZmQsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzIudG9ScHJMRU0oYnVmZiwgMCwgcCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjb25zdCByZXMgPSBjdXJ2ZS5HMS5mcm9tUnByTEVNKGJ1ZmYsIDApO1xuICAgIHJldHVybiB0b09iamVjdCA/IGN1cnZlLkcxLnRvT2JqZWN0KHJlcykgOiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjb25zdCByZXMgPSBjdXJ2ZS5HMi5mcm9tUnByTEVNKGJ1ZmYsIDApO1xuICAgIHJldHVybiB0b09iamVjdCA/IGN1cnZlLkcyLnRvT2JqZWN0KHJlcykgOiByZXM7XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zLCB0b09iamVjdCkge1xuICAgIC8vIFJlYWQgSGVhZGVyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxKTtcbiAgICBjb25zdCBwcm90b2NvbElkID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGlmIChwcm90b2NvbElkID09PSBHUk9USDE2X1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkSGVhZGVyR3JvdGgxNihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sSWQgPT09IFBMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkSGVhZGVyUGxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCk7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbElkID09PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJGRmxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdG9jb2wgbm90IHN1cHBvcnRlZDogXCIpO1xuICAgIH1cbn1cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckdyb3RoMTYoZmQsIHNlY3Rpb25zLCB0b09iamVjdCkge1xuICAgIGNvbnN0IHprZXkgPSB7fTtcblxuICAgIHprZXkucHJvdG9jb2wgPSBcImdyb3RoMTZcIjtcblxuICAgIC8vIFJlYWQgR3JvdGggSGVhZGVyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAyKTtcbiAgICBjb25zdCBuOHEgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44cSA9IG44cTtcbiAgICB6a2V5LnEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhxKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHIpO1xuICAgIHprZXkuY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuICAgIHprZXkublZhcnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5QdWJsaWMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LmRvbWFpblNpemUgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LnBvd2VyID0gbG9nMih6a2V5LmRvbWFpblNpemUpO1xuICAgIHprZXkudmtfYWxwaGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfYmV0YV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19iZXRhXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2dhbW1hXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2RlbHRhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHprZXk7XG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlclBsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QpIHtcbiAgICBjb25zdCB6a2V5ID0ge307XG5cbiAgICB6a2V5LnByb3RvY29sID0gXCJwbG9ua1wiO1xuXG4gICAgLy8gUmVhZCBQbG9uayBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHEpO1xuXG4gICAgY29uc3QgbjhyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHIgPSBuOHI7XG4gICAgemtleS5yID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cik7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS5uQWRkaXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uQ29uc3RyYWlucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuUW0gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFsID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RciA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUW8gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFjID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzIgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMzID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5YXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgemtleS5wcm90b2NvbElkID0gRkZMT05LX1BST1RPQ09MX0lEO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OKTtcbiAgICBjb25zdCBuOHEgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44cSA9IG44cTtcbiAgICB6a2V5LnEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhxKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHIpO1xuXG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS5uQWRkaXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uQ29uc3RyYWludHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkudzMgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53NCA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5Lnc4ID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkud3IgPSBhd2FpdCBmZC5yZWFkKG44cik7XG5cbiAgICB6a2V5LlhfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgemtleS5DMCA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFpLZXkoZmlsZU5hbWUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwiemtleVwiLCAxKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucywgdG9PYmplY3QpO1xuXG4gICAgY29uc3QgRnIgPSBuZXcgRjFGaWVsZCh6a2V5LnIpO1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIHprZXkubjhyKjgpLCB6a2V5LnIpO1xuICAgIGNvbnN0IFJyaSA9IEZyLmludihScik7XG4gICAgY29uc3QgUnJpMiA9IEZyLm11bChScmksIFJyaSk7XG5cbiAgICBsZXQgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgLy8gUmVhZCBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHprZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBQID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgICAgICB6a2V5LklDLnB1c2goUCk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQ29lZnNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNCk7XG4gICAgY29uc3QgbkNDb2VmcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuY2NvZWZzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5DQ29lZnM7IGkrKykge1xuICAgICAgICBjb25zdCBtID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgcmVhZEZyMih0b09iamVjdCk7XG4gICAgICAgIHprZXkuY2NvZWZzLnB1c2goe1xuICAgICAgICAgICAgbWF0cml4OiBtLFxuICAgICAgICAgICAgY29uc3RyYWludDogYyxcbiAgICAgICAgICAgIHNpZ25hbDogcyxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgLy8gUmVhZCBBIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA1KTtcbiAgICB6a2V5LkEgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuQVtpXSA9IEE7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNik7XG4gICAgemtleS5CMSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQjEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5CMVtpXSA9IEIxO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEIyIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA3KTtcbiAgICB6a2V5LkIyID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMiA9IGF3YWl0IHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5CMltpXSA9IEIyO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEMgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDgpO1xuICAgIHprZXkuQyA9IFtdO1xuICAgIGZvciAobGV0IGk9emtleS5uUHVibGljKzE7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEMgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5DW2ldID0gQztcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICB6a2V5LmhFeHBzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuaEV4cHMucHVzaChIKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gemtleTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRGcjIoLyogdG9PYmplY3QgKi8pIHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCB6a2V5Lm44cik7XG4gICAgICAgIHJldHVybiBGci5tdWwobiwgUnJpMik7XG4gICAgfVxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYyA9IHtkZWx0YTp7fX07XG4gICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGMudHlwZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgY29uc3QgcGFyYW1MZW5ndGggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjdXJQb3MgPSBmZC5wb3M7XG4gICAgbGV0IGxhc3RUeXBlID0wO1xuICAgIHdoaWxlIChmZC5wb3MtY3VyUG9zIDwgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYnVmZlR5cGUgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgICAgICBjLm5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZlN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZFeHAgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCBmZC5yZWFkKGJ1ZmZMZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmZC5wb3MgIT0gY3VyUG9zICsgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxMCk7XG4gICAgY29uc3QgcmVzID0geyBjb250cmlidXRpb25zOiBbXX07XG4gICAgcmVzLmNzSGFzaCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGNvbnN0IG4gPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCByZWFkQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSk7XG4gICAgICAgIHJlcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGMpIHtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YUFmdGVyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zeCk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIGMuZGVsdGEuZzJfc3B4KTtcbiAgICBhd2FpdCBmZC53cml0ZShjLnRyYW5zY3JpcHQpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoYy50eXBlIHx8IDApO1xuXG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgaWYgKGMubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGMubmFtZS5zdWJzdHJpbmcoMCw2NCkpO1xuICAgICAgICBwYXJhbXMucHVzaChuYW1lRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5hbWVEYXRhLmJ5dGVMZW5ndGg7IGkrKykgcGFyYW1zLnB1c2gobmFtZURhdGFbaV0pO1xuICAgIH1cbiAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMik7ICAgICAgLy8gUGFyYW0gbnVtSXRlcmF0aW9uc0V4cFxuICAgICAgICBwYXJhbXMucHVzaChjLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGMuYmVhY29uSGFzaC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGMuYmVhY29uSGFzaC5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKGMuYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlTVBDUGFyYW1zKGZkLCBjdXJ2ZSwgbXBjUGFyYW1zKSB7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxMCk7XG4gICAgYXdhaXQgZmQud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hHMihoYXNoZXIsY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBwKTtcbiAgICBoYXNoZXIudXBkYXRlKGJ1ZmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzaFB1YktleShoYXNoZXIsIGN1cnZlLCBjKSB7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGhhc2hHMihoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgaGFzaGVyLnVwZGF0ZShjLnRyYW5zY3JpcHQpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_frominit.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_verify_frominit.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromInit)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/../backend/node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/../backend/node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blake2b-wasm */ \"(rsc)/../backend/node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/../backend/node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/../backend/node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/../backend/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_4__.sameRatio;\n\n\n\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__.ready();\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__(64);\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = _misc_js__WEBPACK_IMPORTED_MODULE_4__.cloneHasher(accumulatedHasher);\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_s);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_sx);\n\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = _misc_js__WEBPACK_IMPORTED_MODULE_4__.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(accumulatedHasher, curve, c);\n\n        const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__(64);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript__WEBPACK_IMPORTED_MODULE_7__.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript__WEBPACK_IMPORTED_MODULE_7__.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdInit, curve, sectionsInit);\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_4__.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd1, sections1, idSection);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = new Uint8Array(4*n);\n            crypto__WEBPACK_IMPORTED_MODULE_6__.randomFillSync(scalars);\n\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd1);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_7__.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = crypto__WEBPACK_IMPORTED_MODULE_6__.randomBytes(4).readUInt32BE(0, true);\n        }\n        const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_7__.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verificaition(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubstract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Caluclate odd coeficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verificaition(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubstract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubstractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubstractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbWluaXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3JCO0FBQ0Q7QUFDa0I7QUFDcEQsa0JBQWtCLCtDQUFjO0FBQ0o7QUFDdUI7QUFDTTs7OztBQUkxQzs7QUFFZjtBQUNBLFVBQVUsK0NBQWE7O0FBRXZCLFdBQVcsY0FBYyxRQUFRLDREQUF3QjtBQUN6RCx1QkFBdUIsc0RBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseURBQVE7QUFDaEM7O0FBRUEsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsOEJBQThCLHlDQUFPO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0EsMEJBQTBCLGlEQUFnQjs7QUFFMUMsUUFBUSxzREFBTTtBQUNkLFFBQVEsc0RBQU07O0FBRWQsYUFBYSxpREFBZ0I7QUFDN0IsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTs7QUFFQSw0QkFBNEIscURBQVE7O0FBRXBDO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlEQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDBEQUFVOztBQUVsQixtQ0FBbUMseUNBQU87QUFDMUMsUUFBUSwwREFBVTs7QUFFbEI7O0FBRUE7QUFDQTs7O0FBR0EsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7QUFDL0UsMkJBQTJCLHNEQUFvQjs7QUFFL0M7QUFDQTtBQUNBOztBQUVBLFlBQVksZ0RBQU07QUFDbEIsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLHlEQUF1QjtBQUN2RCxTQUFTLGlEQUFnQjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsK0RBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0RBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0RBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0RBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0RBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBOztBQUVBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsc0NBQXNDLEtBQUssRUFBRSxxQkFBcUI7QUFDakg7QUFDQSx5REFBeUQsbURBQWtCLGVBQWU7QUFDMUYsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBbUM7QUFDakQsY0FBYyx1RUFBbUM7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakMseURBQXlELFlBQVksS0FBSyxFQUFFLEdBQUcsUUFBUTtBQUN2RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtEQUFxQjs7O0FBR2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekMsY0FBYywrREFBMkI7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0NBQW9DLFFBQVEsNERBQXdCOztBQUVuRix5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLCtDQUFrQjtBQUN4QztBQUNBLHdCQUF3QixnREFBTTtBQUM5QixzQkFBc0IscUJBQXFCLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLCtEQUErRCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1RUFBbUM7QUFDakQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLG9FQUFvRSxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQix5Q0FBeUM7QUFDNUQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CLDZDQUE2Qzs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdmVyaWZ5X2Zyb21pbml0LmpzPzIwYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQge2hhc2hHMSwgaGFzaFB1YktleX0gZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBDaGFDaGEsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMnZlcmlmeUZyb21Jbml0KGluaXRGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgbGV0IHNyO1xuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZCwgc2VjdGlvbnMsIGZhbHNlKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgYWNjdW11bGF0ZWRIYXNoZXIgPSBCbGFrZTJiKDY0KTtcbiAgICBhY2N1bXVsYXRlZEhhc2hlci51cGRhdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgbGV0IGN1ckRlbHRhID0gY3VydmUuRzEuZztcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBjb25zdCBvdXJIYXNoZXIgPSBtaXNjLmNsb25lSGFzaGVyKGFjY3VtdWxhdGVkSGFzaGVyKTtcblxuICAgICAgICBoYXNoRzEob3VySGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgaGFzaEcxKG91ckhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuXG4gICAgICAgIGlmICghbWlzYy5oYXNoSXNFcXVhbChvdXJIYXNoZXIuZGlnZXN0KCksIGMudHJhbnNjcmlwdCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBJbmNvbnNpc3RlbnQgdHJhbnNjcmlwdCBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhX2cyX3NwID0gaGFzaFRvRzIoY3VydmUsIGMudHJhbnNjcmlwdCk7XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGMuZGVsdGEuZzFfcywgYy5kZWx0YS5nMV9zeCwgZGVsdGFfZzJfc3AsIGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogcHVibGljIGtleSBHMSBhbmQgRzIgZG8gbm90IGhhdmUgdGhlIHNhbWUgcmF0aW9uIGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ckRlbHRhLCBjLmRlbHRhQWZ0ZXIsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IGRlbHRhQWZ0ZXIgZG9lcyBub3QgZmlsbG93IHRoZSBwdWJsaWMga2V5IGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBybmcgPSBtaXNjLnJuZ0Zyb21CZWFjb25QYXJhbXMoYy5iZWFjb25IYXNoLCBjLm51bUl0ZXJhdGlvbnNFeHApO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfcHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZF9nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoZXhwZWN0ZWRfZzFfcywgZXhwZWN0ZWRfcHJ2S2V5KSk7XG4gICAgICAgICAgICBpZiAoY3VydmUuRzEuZXEoZXhwZWN0ZWRfZzFfcywgYy5kZWx0YS5nMV9zKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBLZXkgb2YgdGhlIGJlYWNvbiBkb2VzIG5vdCBtYXRjaC4gZzFfcyBgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VydmUuRzEuZXEoZXhwZWN0ZWRfZzFfc3gsIGMuZGVsdGEuZzFfc3gpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IEtleSBvZiB0aGUgYmVhY29uIGRvZXMgbm90IG1hdGNoLiBnMV9zeCBgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoYXNoUHViS2V5KGFjY3VtdWxhdGVkSGFzaGVyLCBjdXJ2ZSwgYyk7XG5cbiAgICAgICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgICAgIGhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgYyk7XG5cbiAgICAgICAgYy5jb250cmlidXRpb25IYXNoID0gY29udHJpYnV0aW9uSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGN1ckRlbHRhID0gYy5kZWx0YUFmdGVyO1xuICAgIH1cblxuXG4gICAgY29uc3Qge2ZkOiBmZEluaXQsIHNlY3Rpb25zOiBzZWN0aW9uc0luaXR9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKGluaXRGaWxlTmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXlJbml0ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRJbml0LCBzZWN0aW9uc0luaXQsIGZhbHNlKTtcblxuICAgIGlmICh6a2V5SW5pdC5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5aW5pdCBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGlmICggICghU2NhbGFyLmVxKHprZXlJbml0LnEsIHprZXkucSkpXG4gICAgICAgIHx8KCFTY2FsYXIuZXEoemtleUluaXQuciwgemtleS5yKSlcbiAgICAgICAgfHwoemtleUluaXQubjhxICE9IHprZXkubjhxKVxuICAgICAgICB8fCh6a2V5SW5pdC5uOHIgIT0gemtleS5uOHIpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIERpZmZlcmVudCBjdXJ2ZXNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoICAoemtleUluaXQublZhcnMgIT0gemtleS5uVmFycylcbiAgICAgICAgfHwoemtleUluaXQublB1YmxpYyAhPSAgemtleS5uUHVibGljKVxuICAgICAgICB8fCh6a2V5SW5pdC5kb21haW5TaXplICE9IHprZXkuZG9tYWluU2l6ZSkpXG4gICAge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgRGlmZmVyZW50IGNpcmN1aXQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19hbHBoYV8xLCB6a2V5SW5pdC52a19hbHBoYV8xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBhbHBoYTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcSh6a2V5LnZrX2JldGFfMSwgemtleUluaXQudmtfYmV0YV8xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBiZXRhMVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKHprZXkudmtfYmV0YV8yLCB6a2V5SW5pdC52a19iZXRhXzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIGJldGEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzIuZXEoemtleS52a19nYW1tYV8yLCB6a2V5SW5pdC52a19nYW1tYV8yKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBnYW1tYTJcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcSh6a2V5LnZrX2RlbHRhXzEsIGN1ckRlbHRhKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBkZWx0YTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1cnZlLkcxLmcsIGN1ckRlbHRhLCBjdXJ2ZS5HMi5nLCB6a2V5LnZrX2RlbHRhXzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBkZWx0YTJcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtcGNQYXJhbXNJbml0ID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRJbml0LCBjdXJ2ZSwgc2VjdGlvbnNJbml0KTtcbiAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobXBjUGFyYW1zLmNzSGFzaCwgbXBjUGFyYW1zSW5pdC5jc0hhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBDaXJjdWl0IGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc2l6ZXMgb2Ygc2VjdGlvbnNcbiAgICBpZiAoc2VjdGlvbnNbOF1bMF0uc2l6ZSAhPSBzRzEqKHprZXkublZhcnMtemtleS5uUHVibGljLTEpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIEwgc2VjdGlvbiBzaXplXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb25zWzldWzBdLnNpemUgIT0gc0cxKih6a2V5LmRvbWFpblNpemUpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJbnZhbGlkIEggc2VjdGlvbiBzaXplXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHNzO1xuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDMpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIElDIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDQpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQ29lZmZzIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDUpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQSBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA2KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkIxIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDcpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiQjIgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgTFxuICAgIHNyID0gYXdhaXQgc2VjdGlvbkhhc1NhbWVSYXRpbyhcIkcxXCIsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmZCwgc2VjdGlvbnMsIDgsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMiwgXCJMIHNlY3Rpb25cIik7XG4gICAgaWYgKHNyIT09dHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJMIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBIXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW9IKCk7XG4gICAgaWYgKHNyIT09dHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJIIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkSW5pdC5jbG9zZSgpO1xuXG4gICAgZm9yIChsZXQgaT1tcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goYy5jb250cmlidXRpb25IYXNoLCBgY29udHJpYnV0aW9uICMke2krMX0gJHtjLm5hbWUgPyBjLm5hbWUgOiBcIlwifTpgKSk7XG4gICAgICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7bWlzYy5ieXRlQXJyYXkyaGV4KGMuYmVhY29uSGFzaCl9YCk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgQmVhY29uIGl0ZXJhdGlvbnMgRXhwOiAke2MubnVtSXRlcmF0aW9uc0V4cH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlpLZXkgT2shXCIpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlY3Rpb25IYXNTYW1lUmF0aW8oZ3JvdXBOYW1lLCBmZDEsIHNlY3Rpb25zMSwgZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbiwgZzJzcCwgZzJzcHgsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MjA7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZDEsIHNlY3Rpb25zMSwgaWRTZWN0aW9uKTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbik7XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IHNlY3Rpb25zMVtpZFNlY3Rpb25dWzBdLnNpemUgLyBzRztcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBTYW1lIHJhdGlvIGNoZWNrICR7c2VjdGlvbk5hbWV9OiAgJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMSA9IGF3YWl0IGZkMS5yZWFkKG4qc0cpO1xuICAgICAgICAgICAgY29uc3QgYmFzZXMyID0gYXdhaXQgZmQyLnJlYWQobipzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjYWxhcnMgPSBuZXcgVWludDhBcnJheSg0Km4pO1xuICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHNjYWxhcnMpO1xuXG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlczEsIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzMiwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQxKTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkMik7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIFIxLCBSMiwgZzJzcCwgZzJzcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzYW1lUmF0aW9IKCkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDIwO1xuICAgICAgICBjb25zdCBHID0gY3VydmUuRzE7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHBUYXVGaWxlTmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgICAgIGxldCBidWZmX3IgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIHprZXkubjhyKTtcblxuICAgICAgICBjb25zdCBzZWVkPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgICAgIHNlZWRbaV0gPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZFVJbnQzMkJFKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemUtMTsgaSsrKSB7ICAgLy8gTm90ZSB0aGF0IGxhc3Qgb25lIGlzIHplcm9cbiAgICAgICAgICAgIGNvbnN0IGUgPSBGci5mcm9tUm5nKHJuZyk7XG4gICAgICAgICAgICBGci50b1JwckxFKGJ1ZmZfciwgaSp6a2V5Lm44ciwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgRnIudG9ScHJMRShidWZmX3IsICh6a2V5LmRvbWFpblNpemUtMSkqemtleS5uOHIsIEZyLnplcm8pO1xuXG4gICAgICAgIGxldCBSMSA9IEcuemVybztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIIFZlcmlmaWNhaXRpb24odGF1KTogICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oemtleS5kb21haW5TaXplIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgemtleS5kb21haW5TaXplKnNHICsgaSpzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgaSpzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZCID0gYXdhaXQgYmF0Y2hTdWJzdHJhY3QoYnVmZjEsIGJ1ZmYyKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZCLCBidWZmUyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsdWNsYXRlIG9kZCBjb2VmaWNpZW50cyBpbiB0cmFuc2Zvcm1lZCBkb21haW5cblxuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAvLyBjb25zdCBmaXJzdCA9IGN1cnZlLkZyLm5lZyhjdXJ2ZS5Gci5pbnYoY3VydmUuRnIuZSgyKSkpO1xuICAgICAgICAvLyBXb3JrcyoyICAgY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuZSgyKSk7XG5cblxuICAgICAgICBsZXQgZmlyc3Q7XG5cbiAgICAgICAgaWYgKHprZXkucG93ZXIgPCBGci5zKSB7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLm5lZyhGci5lKDIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsX20gID0gMiAqKiBGci5zO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxfbSk7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLnN1Yiggc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0IGluYyA9IGN1cnZlLkZyLmludihjdXJ2ZS5QRnIud1t6a2V5LnBvd2VyKzFdKTtcbiAgICAgICAgY29uc3QgaW5jID0gemtleS5wb3dlciA8IEZyLnMgPyBGci53W3prZXkucG93ZXIrMV0gOiBGci5zaGlmdDtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmX3IsIGZpcnN0LCBpbmMpO1xuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5mZnQoYnVmZl9yKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgOSk7XG4gICAgICAgIGxldCBSMiA9IEcuemVybztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIIFZlcmlmaWNhaXRpb24obGFncmFuZ2UpOiAgJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbih6a2V5LmRvbWFpblNpemUgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKm4pO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZiwgYnVmZlMpO1xuXG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnN0cmFjdChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBidWZmMS5ieXRlTGVuZ3RoIC8gc0c7XG4gICAgICAgIGNvbnN0IGNvbmN1cnJlbmN5PSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgblBvaW50c1BlclRocmVhZCA9IE1hdGguZmxvb3IoblBvaW50cyAvIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjEgPSBidWZmMS5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMiA9IGJ1ZmYyLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChiYXRjaFN1YnN0cmFjdFRocmVhZChzdWJCdWZmMSwgc3ViQnVmZjIpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgY29uc3QgZnVsbEJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICAgICAgcCs9cmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnN0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_frominit.js\n");

/***/ }),

/***/ "(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_fromr1cs.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/snarkjs/src/zkey_verify_fromr1cs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromR1cs)\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await (0,_zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await (0,_zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDeUI7O0FBRTlDOztBQUVmO0FBQ0EsMEJBQTBCO0FBQzFCLFVBQVUsd0RBQU87O0FBRWpCLGlCQUFpQixvRUFBb0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X3ZlcmlmeV9mcm9tcjFjcy5qcz9kZjE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBuZXdaS2V5IGZyb20gXCIuL3prZXlfbmV3LmpzXCI7XG5pbXBvcnQgcGhhc2UydmVyaWZ5RnJvbUluaXQgZnJvbSBcIi4vemtleV92ZXJpZnlfZnJvbWluaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGhhc2UydmVyaWZ5RnJvbVIxY3MocjFjc0ZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAvLyBjb25zdCBpbml0RmlsZU5hbWUgPSBcIn5cIiArIHprZXlGaWxlTmFtZSArIFwiLmluaXRcIjtcbiAgICBjb25zdCBpbml0RmlsZU5hbWUgPSB7dHlwZTogXCJiaWdNZW1cIn07XG4gICAgYXdhaXQgbmV3WktleShyMWNzRmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgaW5pdEZpbGVOYW1lLCBsb2dnZXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHBoYXNlMnZlcmlmeUZyb21Jbml0KGluaXRGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcik7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../backend/node_modules/snarkjs/src/zkey_verify_fromr1cs.js\n");

/***/ })

};
;